(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.cartodb || (g.cartodb = {})).deepInsights = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  createDashboard: require('./src/create-dashboard')
};

},{"./src/create-dashboard":25}],2:[function(require,module,exports){
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction (sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toObject     = toObject;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],3:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = require('./src/js/main');

},{"./src/js/main":9}],4:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

function oldAdd(element, className) {
  var classes = element.className.split(' ');
  if (classes.indexOf(className) < 0) {
    classes.push(className);
  }
  element.className = classes.join(' ');
}

function oldRemove(element, className) {
  var classes = element.className.split(' ');
  var idx = classes.indexOf(className);
  if (idx >= 0) {
    classes.splice(idx, 1);
  }
  element.className = classes.join(' ');
}

exports.add = function (element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    oldAdd(element, className);
  }
};

exports.remove = function (element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    oldRemove(element, className);
  }
};

exports.list = function (element) {
  if (element.classList) {
    return Array.prototype.slice.apply(element.classList);
  } else {
    return element.className.split(' ');
  }
};

},{}],5:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var DOM = {};

DOM.e = function (tagName, className) {
  var element = document.createElement(tagName);
  element.className = className;
  return element;
};

DOM.appendTo = function (child, parent) {
  parent.appendChild(child);
  return child;
};

function cssGet(element, styleName) {
  return window.getComputedStyle(element)[styleName];
}

function cssSet(element, styleName, styleValue) {
  if (typeof styleValue === 'number') {
    styleValue = styleValue.toString() + 'px';
  }
  element.style[styleName] = styleValue;
  return element;
}

function cssMultiSet(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === 'number') {
      val = val.toString() + 'px';
    }
    element.style[key] = val;
  }
  return element;
}

DOM.css = function (element, styleNameOrObject, styleValue) {
  if (typeof styleNameOrObject === 'object') {
    // multiple set with object
    return cssMultiSet(element, styleNameOrObject);
  } else {
    if (typeof styleValue === 'undefined') {
      return cssGet(element, styleNameOrObject);
    } else {
      return cssSet(element, styleNameOrObject, styleValue);
    }
  }
};

DOM.matches = function (element, query) {
  if (typeof element.matches !== 'undefined') {
    return element.matches(query);
  } else {
    if (typeof element.matchesSelector !== 'undefined') {
      return element.matchesSelector(query);
    } else if (typeof element.webkitMatchesSelector !== 'undefined') {
      return element.webkitMatchesSelector(query);
    } else if (typeof element.mozMatchesSelector !== 'undefined') {
      return element.mozMatchesSelector(query);
    } else if (typeof element.msMatchesSelector !== 'undefined') {
      return element.msMatchesSelector(query);
    }
  }
};

DOM.remove = function (element) {
  if (typeof element.remove !== 'undefined') {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
};

DOM.queryChildren = function (element, selector) {
  return Array.prototype.filter.call(element.childNodes, function (child) {
    return DOM.matches(child, selector);
  });
};

module.exports = DOM;

},{}],6:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var EventElement = function (element) {
  this.element = element;
  this.events = {};
};

EventElement.prototype.bind = function (eventName, handler) {
  if (typeof this.events[eventName] === 'undefined') {
    this.events[eventName] = [];
  }
  this.events[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};

EventElement.prototype.unbind = function (eventName, handler) {
  var isHandlerProvided = (typeof handler !== 'undefined');
  this.events[eventName] = this.events[eventName].filter(function (hdlr) {
    if (isHandlerProvided && hdlr !== handler) {
      return true;
    }
    this.element.removeEventListener(eventName, hdlr, false);
    return false;
  }, this);
};

EventElement.prototype.unbindAll = function () {
  for (var name in this.events) {
    this.unbind(name);
  }
};

var EventManager = function () {
  this.eventElements = [];
};

EventManager.prototype.eventElement = function (element) {
  var ee = this.eventElements.filter(function (eventElement) {
    return eventElement.element === element;
  })[0];
  if (typeof ee === 'undefined') {
    ee = new EventElement(element);
    this.eventElements.push(ee);
  }
  return ee;
};

EventManager.prototype.bind = function (element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};

EventManager.prototype.unbind = function (element, eventName, handler) {
  this.eventElement(element).unbind(eventName, handler);
};

EventManager.prototype.unbindAll = function () {
  for (var i = 0; i < this.eventElements.length; i++) {
    this.eventElements[i].unbindAll();
  }
};

EventManager.prototype.once = function (element, eventName, handler) {
  var ee = this.eventElement(element);
  var onceHandler = function (e) {
    ee.unbind(eventName, onceHandler);
    handler(e);
  };
  ee.bind(eventName, onceHandler);
};

module.exports = EventManager;

},{}],7:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = (function () {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
               .toString(16)
               .substring(1);
  }
  return function () {
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
           s4() + '-' + s4() + s4() + s4();
  };
})();

},{}],8:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('./class')
  , d = require('./dom');

exports.toInt = function (x) {
  return parseInt(x, 10) || 0;
};

exports.clone = function (obj) {
  if (obj === null) {
    return null;
  } else if (typeof obj === 'object') {
    var result = {};
    for (var key in obj) {
      result[key] = this.clone(obj[key]);
    }
    return result;
  } else {
    return obj;
  }
};

exports.extend = function (original, source) {
  var result = this.clone(original);
  for (var key in source) {
    result[key] = this.clone(source[key]);
  }
  return result;
};

exports.isEditable = function (el) {
  return d.matches(el, "input,[contenteditable]") ||
         d.matches(el, "select,[contenteditable]") ||
         d.matches(el, "textarea,[contenteditable]") ||
         d.matches(el, "button,[contenteditable]");
};

exports.removePsClasses = function (element) {
  var clsList = cls.list(element);
  for (var i = 0; i < clsList.length; i++) {
    var className = clsList[i];
    if (className.indexOf('ps-') === 0) {
      cls.remove(element, className);
    }
  }
};

exports.outerWidth = function (element) {
  return this.toInt(d.css(element, 'width')) +
         this.toInt(d.css(element, 'paddingLeft')) +
         this.toInt(d.css(element, 'paddingRight')) +
         this.toInt(d.css(element, 'borderLeftWidth')) +
         this.toInt(d.css(element, 'borderRightWidth'));
};

exports.startScrolling = function (element, axis) {
  cls.add(element, 'ps-in-scrolling');
  if (typeof axis !== 'undefined') {
    cls.add(element, 'ps-' + axis);
  } else {
    cls.add(element, 'ps-x');
    cls.add(element, 'ps-y');
  }
};

exports.stopScrolling = function (element, axis) {
  cls.remove(element, 'ps-in-scrolling');
  if (typeof axis !== 'undefined') {
    cls.remove(element, 'ps-' + axis);
  } else {
    cls.remove(element, 'ps-x');
    cls.remove(element, 'ps-y');
  }
};

exports.env = {
  isWebKit: 'WebkitAppearance' in document.documentElement.style,
  supportsTouch: (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: window.navigator.msMaxTouchPoints !== null
};

},{"./class":4,"./dom":5}],9:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var destroy = require('./plugin/destroy')
  , initialize = require('./plugin/initialize')
  , update = require('./plugin/update');

module.exports = {
  initialize: initialize,
  update: update,
  destroy: destroy
};

},{"./plugin/destroy":11,"./plugin/initialize":19,"./plugin/update":23}],10:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = {
  maxScrollbarLength: null,
  minScrollbarLength: null,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  stopPropagationOnClick: true,
  suppressScrollX: false,
  suppressScrollY: false,
  swipePropagation: true,
  useBothWheelAxes: false,
  useKeyboard: true,
  useSelectionScroll: false,
  wheelPropagation: false,
  wheelSpeed: 1
};

},{}],11:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances');

module.exports = function (element) {
  var i = instances.get(element);

  if (!i) {
    return;
  }

  i.event.unbindAll();
  d.remove(i.scrollbarX);
  d.remove(i.scrollbarY);
  d.remove(i.scrollbarXRail);
  d.remove(i.scrollbarYRail);
  h.removePsClasses(element);

  instances.remove(element);
};

},{"../lib/dom":5,"../lib/helper":8,"./instances":20}],12:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindClickRailHandler(element, i) {
  function pageOffset(el) {
    return el.getBoundingClientRect();
  }
  var stopPropagation = window.Event.prototype.stopPropagation.bind;

  if (i.settings.stopPropagationOnClick) {
    i.event.bind(i.scrollbarY, 'click', stopPropagation);
  }
  i.event.bind(i.scrollbarYRail, 'click', function (e) {
    var halfOfScrollbarLength = h.toInt(i.scrollbarYHeight / 2);
    var positionTop = i.railYRatio * (e.pageY - window.scrollY - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength);
    var maxPositionTop = i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
    var positionRatio = positionTop / maxPositionTop;

    if (positionRatio < 0) {
      positionRatio = 0;
    } else if (positionRatio > 1) {
      positionRatio = 1;
    }

    updateScroll(element, 'top', (i.contentHeight - i.containerHeight) * positionRatio);
    updateGeometry(element);

    e.stopPropagation();
  });

  if (i.settings.stopPropagationOnClick) {
    i.event.bind(i.scrollbarX, 'click', stopPropagation);
  }
  i.event.bind(i.scrollbarXRail, 'click', function (e) {
    var halfOfScrollbarLength = h.toInt(i.scrollbarXWidth / 2);
    var positionLeft = i.railXRatio * (e.pageX - window.scrollX - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength);
    var maxPositionLeft = i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
    var positionRatio = positionLeft / maxPositionLeft;

    if (positionRatio < 0) {
      positionRatio = 0;
    } else if (positionRatio > 1) {
      positionRatio = 1;
    }

    updateScroll(element, 'left', ((i.contentWidth - i.containerWidth) * positionRatio) - i.negativeScrollAdjustment);
    updateGeometry(element);

    e.stopPropagation();
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindClickRailHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],13:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../../lib/dom')
  , h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindMouseScrollXHandler(element, i) {
  var currentLeft = null;
  var currentPageX = null;

  function updateScrollLeft(deltaX) {
    var newLeft = currentLeft + (deltaX * i.railXRatio);
    var maxLeft = i.scrollbarXRail.getBoundingClientRect().left + (i.railXRatio * (i.railXWidth - i.scrollbarXWidth));

    if (newLeft < 0) {
      i.scrollbarXLeft = 0;
    } else if (newLeft > maxLeft) {
      i.scrollbarXLeft = maxLeft;
    } else {
      i.scrollbarXLeft = newLeft;
    }

    var scrollLeft = h.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - (i.railXRatio * i.scrollbarXWidth))) - i.negativeScrollAdjustment;
    updateScroll(element, 'left', scrollLeft);
  }

  var mouseMoveHandler = function (e) {
    updateScrollLeft(e.pageX - currentPageX);
    updateGeometry(element);
    e.stopPropagation();
    e.preventDefault();
  };

  var mouseUpHandler = function () {
    h.stopScrolling(element, 'x');
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  };

  i.event.bind(i.scrollbarX, 'mousedown', function (e) {
    currentPageX = e.pageX;
    currentLeft = h.toInt(d.css(i.scrollbarX, 'left')) * i.railXRatio;
    h.startScrolling(element, 'x');

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    e.stopPropagation();
    e.preventDefault();
  });
}

function bindMouseScrollYHandler(element, i) {
  var currentTop = null;
  var currentPageY = null;

  function updateScrollTop(deltaY) {
    var newTop = currentTop + (deltaY * i.railYRatio);
    var maxTop = i.scrollbarYRail.getBoundingClientRect().top + (i.railYRatio * (i.railYHeight - i.scrollbarYHeight));

    if (newTop < 0) {
      i.scrollbarYTop = 0;
    } else if (newTop > maxTop) {
      i.scrollbarYTop = maxTop;
    } else {
      i.scrollbarYTop = newTop;
    }

    var scrollTop = h.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - (i.railYRatio * i.scrollbarYHeight)));
    updateScroll(element, 'top', scrollTop);
  }

  var mouseMoveHandler = function (e) {
    updateScrollTop(e.pageY - currentPageY);
    updateGeometry(element);
    e.stopPropagation();
    e.preventDefault();
  };

  var mouseUpHandler = function () {
    h.stopScrolling(element, 'y');
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  };

  i.event.bind(i.scrollbarY, 'mousedown', function (e) {
    currentPageY = e.pageY;
    currentTop = h.toInt(d.css(i.scrollbarY, 'top')) * i.railYRatio;
    h.startScrolling(element, 'y');

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    e.stopPropagation();
    e.preventDefault();
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindMouseScrollXHandler(element, i);
  bindMouseScrollYHandler(element, i);
};

},{"../../lib/dom":5,"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],14:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindKeyboardHandler(element, i) {
  var hovered = false;
  i.event.bind(element, 'mouseenter', function () {
    hovered = true;
  });
  i.event.bind(element, 'mouseleave', function () {
    hovered = false;
  });

  var shouldPrevent = false;
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  i.event.bind(i.ownerDocument, 'keydown', function (e) {
    if (e.isDefaultPrevented && e.isDefaultPrevented()) {
      return;
    }

    if (!hovered) {
      return;
    }

    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      // go deeper if element is a webcomponent
      while (activeElement.shadowRoot) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      if (h.isEditable(activeElement)) {
        return;
      }
    }

    var deltaX = 0;
    var deltaY = 0;

    switch (e.which) {
    case 37: // left
      deltaX = -30;
      break;
    case 38: // up
      deltaY = 30;
      break;
    case 39: // right
      deltaX = 30;
      break;
    case 40: // down
      deltaY = -30;
      break;
    case 33: // page up
      deltaY = 90;
      break;
    case 32: // space bar
      if (e.shiftKey) {
        deltaY = 90;
      } else {
        deltaY = -90;
      }
      break;
    case 34: // page down
      deltaY = -90;
      break;
    case 35: // end
      if (e.ctrlKey) {
        deltaY = -i.contentHeight;
      } else {
        deltaY = -i.containerHeight;
      }
      break;
    case 36: // home
      if (e.ctrlKey) {
        deltaY = element.scrollTop;
      } else {
        deltaY = i.containerHeight;
      }
      break;
    default:
      return;
    }

    updateScroll(element, 'top', element.scrollTop - deltaY);
    updateScroll(element, 'left', element.scrollLeft + deltaX);
    updateGeometry(element);

    shouldPrevent = shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent) {
      e.preventDefault();
    }
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindKeyboardHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],15:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindMouseWheelHandler(element, i) {
  var shouldPrevent = false;

  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;

    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      // OS X Safari
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }

    if (e.deltaMode && e.deltaMode === 1) {
      // Firefox in deltaMode 1: Line scrolling
      deltaX *= 10;
      deltaY *= 10;
    }

    if (deltaX !== deltaX && deltaY !== deltaY/* NaN checks */) {
      // IE in some mouse drivers
      deltaX = 0;
      deltaY = e.wheelDelta;
    }

    return [deltaX, deltaY];
  }

  function shouldBeConsumedByTextarea(deltaX, deltaY) {
    var hoveredTextarea = element.querySelector('textarea:hover');
    if (hoveredTextarea) {
      var maxScrollTop = hoveredTextarea.scrollHeight - hoveredTextarea.clientHeight;
      if (maxScrollTop > 0) {
        if (!(hoveredTextarea.scrollTop === 0 && deltaY > 0) &&
            !(hoveredTextarea.scrollTop === maxScrollTop && deltaY < 0)) {
          return true;
        }
      }
      var maxScrollLeft = hoveredTextarea.scrollLeft - hoveredTextarea.clientWidth;
      if (maxScrollLeft > 0) {
        if (!(hoveredTextarea.scrollLeft === 0 && deltaX < 0) &&
            !(hoveredTextarea.scrollLeft === maxScrollLeft && deltaX > 0)) {
          return true;
        }
      }
    }
    return false;
  }

  function mousewheelHandler(e) {
    // FIXME: this is a quick fix for the select problem in FF and IE.
    // If there comes an effective way to deal with the problem,
    // this lines should be removed.
    if (!h.env.isWebKit && element.querySelector('select:focus')) {
      return;
    }

    var delta = getDeltaFromEvent(e);

    var deltaX = delta[0];
    var deltaY = delta[1];

    if (shouldBeConsumedByTextarea(deltaX, deltaY)) {
      return;
    }

    shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      // deltaX will only be used for horizontal scrolling and deltaY will
      // only be used for vertical scrolling - this is the default
      updateScroll(element, 'top', element.scrollTop - (deltaY * i.settings.wheelSpeed));
      updateScroll(element, 'left', element.scrollLeft + (deltaX * i.settings.wheelSpeed));
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      // only vertical scrollbar is active and useBothWheelAxes option is
      // active, so let's scroll vertical bar using both mouse wheel axes
      if (deltaY) {
        updateScroll(element, 'top', element.scrollTop - (deltaY * i.settings.wheelSpeed));
      } else {
        updateScroll(element, 'top', element.scrollTop + (deltaX * i.settings.wheelSpeed));
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      // useBothWheelAxes and only horizontal bar is active, so use both
      // wheel axes for horizontal bar
      if (deltaX) {
        updateScroll(element, 'left', element.scrollLeft + (deltaX * i.settings.wheelSpeed));
      } else {
        updateScroll(element, 'left', element.scrollLeft - (deltaY * i.settings.wheelSpeed));
      }
      shouldPrevent = true;
    }

    updateGeometry(element);

    shouldPrevent = (shouldPrevent || shouldPreventDefault(deltaX, deltaY));
    if (shouldPrevent) {
      e.stopPropagation();
      e.preventDefault();
    }
  }

  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element, 'wheel', mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element, 'mousewheel', mousewheelHandler);
  }
}

module.exports = function (element) {
  var i = instances.get(element);
  bindMouseWheelHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],16:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('../instances')
  , updateGeometry = require('../update-geometry');

function bindNativeScrollHandler(element, i) {
  i.event.bind(element, 'scroll', function () {
    updateGeometry(element);
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindNativeScrollHandler(element, i);
};

},{"../instances":20,"../update-geometry":21}],17:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindSelectionHandler(element, i) {
  function getRangeNode() {
    var selection = window.getSelection ? window.getSelection() :
                    document.getSelection ? document.getSelection() : '';
    if (selection.toString().length === 0) {
      return null;
    } else {
      return selection.getRangeAt(0).commonAncestorContainer;
    }
  }

  var scrollingLoop = null;
  var scrollDiff = {top: 0, left: 0};
  function startScrolling() {
    if (!scrollingLoop) {
      scrollingLoop = setInterval(function () {
        if (!instances.get(element)) {
          clearInterval(scrollingLoop);
          return;
        }

        updateScroll(element, 'top', element.scrollTop + scrollDiff.top);
        updateScroll(element, 'left', element.scrollLeft + scrollDiff.left);
        updateGeometry(element);
      }, 50); // every .1 sec
    }
  }
  function stopScrolling() {
    if (scrollingLoop) {
      clearInterval(scrollingLoop);
      scrollingLoop = null;
    }
    h.stopScrolling(element);
  }

  var isSelected = false;
  i.event.bind(i.ownerDocument, 'selectionchange', function () {
    if (element.contains(getRangeNode())) {
      isSelected = true;
    } else {
      isSelected = false;
      stopScrolling();
    }
  });
  i.event.bind(window, 'mouseup', function () {
    if (isSelected) {
      isSelected = false;
      stopScrolling();
    }
  });

  i.event.bind(window, 'mousemove', function (e) {
    if (isSelected) {
      var mousePosition = {x: e.pageX, y: e.pageY};
      var containerGeometry = {
        left: element.offsetLeft,
        right: element.offsetLeft + element.offsetWidth,
        top: element.offsetTop,
        bottom: element.offsetTop + element.offsetHeight
      };

      if (mousePosition.x < containerGeometry.left + 3) {
        scrollDiff.left = -5;
        h.startScrolling(element, 'x');
      } else if (mousePosition.x > containerGeometry.right - 3) {
        scrollDiff.left = 5;
        h.startScrolling(element, 'x');
      } else {
        scrollDiff.left = 0;
      }

      if (mousePosition.y < containerGeometry.top + 3) {
        if (containerGeometry.top + 3 - mousePosition.y < 5) {
          scrollDiff.top = -5;
        } else {
          scrollDiff.top = -20;
        }
        h.startScrolling(element, 'y');
      } else if (mousePosition.y > containerGeometry.bottom - 3) {
        if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
          scrollDiff.top = 5;
        } else {
          scrollDiff.top = 20;
        }
        h.startScrolling(element, 'y');
      } else {
        scrollDiff.top = 0;
      }

      if (scrollDiff.top === 0 && scrollDiff.left === 0) {
        stopScrolling();
      } else {
        startScrolling();
      }
    }
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindSelectionHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],18:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);

    if (magnitudeY > magnitudeX) {
      // user is perhaps trying to swipe up/down the page

      if (((deltaY < 0) && (scrollTop === i.contentHeight - i.containerHeight)) ||
          ((deltaY > 0) && (scrollTop === 0))) {
        return !i.settings.swipePropagation;
      }
    } else if (magnitudeX > magnitudeY) {
      // user is perhaps trying to swipe left/right across the page

      if (((deltaX < 0) && (scrollLeft === i.contentWidth - i.containerWidth)) ||
          ((deltaX > 0) && (scrollLeft === 0))) {
        return !i.settings.swipePropagation;
      }
    }

    return true;
  }

  function applyTouchMove(differenceX, differenceY) {
    updateScroll(element, 'top', element.scrollTop - differenceY);
    updateScroll(element, 'left', element.scrollLeft - differenceX);

    updateGeometry(element);
  }

  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  var inGlobalTouch = false;
  var inLocalTouch = false;

  function globalTouchStart() {
    inGlobalTouch = true;
  }
  function globalTouchEnd() {
    inGlobalTouch = false;
  }

  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      // Maybe IE pointer
      return e;
    }
  }
  function shouldHandle(e) {
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e) {
    if (shouldHandle(e)) {
      inLocalTouch = true;

      var touch = getTouch(e);

      startOffset.pageX = touch.pageX;
      startOffset.pageY = touch.pageY;

      startTime = (new Date()).getTime();

      if (easingLoop !== null) {
        clearInterval(easingLoop);
      }

      e.stopPropagation();
    }
  }
  function touchMove(e) {
    if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
      var touch = getTouch(e);

      var currentOffset = {pageX: touch.pageX, pageY: touch.pageY};

      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;

      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;

      var currentTime = (new Date()).getTime();

      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }

      if (shouldPreventDefault(differenceX, differenceY)) {
        e.stopPropagation();
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (!inGlobalTouch && inLocalTouch) {
      inLocalTouch = false;

      clearInterval(easingLoop);
      easingLoop = setInterval(function () {
        if (!instances.get(element)) {
          clearInterval(easingLoop);
          return;
        }

        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }

        applyTouchMove(speed.x * 30, speed.y * 30);

        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }

  if (supportsTouch) {
    i.event.bind(window, 'touchstart', globalTouchStart);
    i.event.bind(window, 'touchend', globalTouchEnd);
    i.event.bind(element, 'touchstart', touchStart);
    i.event.bind(element, 'touchmove', touchMove);
    i.event.bind(element, 'touchend', touchEnd);
  }

  if (supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(window, 'pointerdown', globalTouchStart);
      i.event.bind(window, 'pointerup', globalTouchEnd);
      i.event.bind(element, 'pointerdown', touchStart);
      i.event.bind(element, 'pointermove', touchMove);
      i.event.bind(element, 'pointerup', touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(window, 'MSPointerDown', globalTouchStart);
      i.event.bind(window, 'MSPointerUp', globalTouchEnd);
      i.event.bind(element, 'MSPointerDown', touchStart);
      i.event.bind(element, 'MSPointerMove', touchMove);
      i.event.bind(element, 'MSPointerUp', touchEnd);
    }
  }
}

module.exports = function (element, supportsTouch, supportsIePointer) {
  var i = instances.get(element);
  bindTouchHandler(element, i, supportsTouch, supportsIePointer);
};

},{"../instances":20,"../update-geometry":21,"../update-scroll":22}],19:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('../lib/class')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateGeometry = require('./update-geometry');

// Handlers
var clickRailHandler = require('./handler/click-rail')
  , dragScrollbarHandler = require('./handler/drag-scrollbar')
  , keyboardHandler = require('./handler/keyboard')
  , mouseWheelHandler = require('./handler/mouse-wheel')
  , nativeScrollHandler = require('./handler/native-scroll')
  , selectionHandler = require('./handler/selection')
  , touchHandler = require('./handler/touch');

module.exports = function (element, userSettings) {
  userSettings = typeof userSettings === 'object' ? userSettings : {};

  cls.add(element, 'ps-container');

  // Create a plugin instance.
  var i = instances.add(element);

  i.settings = h.extend(i.settings, userSettings);

  clickRailHandler(element);
  dragScrollbarHandler(element);
  mouseWheelHandler(element);
  nativeScrollHandler(element);

  if (i.settings.useSelectionScroll) {
    selectionHandler(element);
  }

  if (h.env.supportsTouch || h.env.supportsIePointer) {
    touchHandler(element, h.env.supportsTouch, h.env.supportsIePointer);
  }
  if (i.settings.useKeyboard) {
    keyboardHandler(element);
  }

  updateGeometry(element);
};

},{"../lib/class":4,"../lib/helper":8,"./handler/click-rail":12,"./handler/drag-scrollbar":13,"./handler/keyboard":14,"./handler/mouse-wheel":15,"./handler/native-scroll":16,"./handler/selection":17,"./handler/touch":18,"./instances":20,"./update-geometry":21}],20:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , defaultSettings = require('./default-setting')
  , EventManager = require('../lib/event-manager')
  , guid = require('../lib/guid')
  , h = require('../lib/helper');

var instances = {};

function Instance(element) {
  var i = this;

  i.settings = h.clone(defaultSettings);
  i.containerWidth = null;
  i.containerHeight = null;
  i.contentWidth = null;
  i.contentHeight = null;

  i.isRtl = d.css(element, 'direction') === "rtl";
  i.isNegativeScroll = (function () {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  })();
  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  i.event = new EventManager();
  i.ownerDocument = element.ownerDocument || document;

  i.scrollbarXRail = d.appendTo(d.e('div', 'ps-scrollbar-x-rail'), element);
  i.scrollbarX = d.appendTo(d.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
  i.scrollbarXActive = null;
  i.scrollbarXWidth = null;
  i.scrollbarXLeft = null;
  i.scrollbarXBottom = h.toInt(d.css(i.scrollbarXRail, 'bottom'));
  i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
  i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : h.toInt(d.css(i.scrollbarXRail, 'top'));
  i.railBorderXWidth = h.toInt(d.css(i.scrollbarXRail, 'borderLeftWidth')) + h.toInt(d.css(i.scrollbarXRail, 'borderRightWidth'));
  // Set rail to display:block to calculate margins
  d.css(i.scrollbarXRail, 'display', 'block');
  i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
  d.css(i.scrollbarXRail, 'display', '');
  i.railXWidth = null;
  i.railXRatio = null;

  i.scrollbarYRail = d.appendTo(d.e('div', 'ps-scrollbar-y-rail'), element);
  i.scrollbarY = d.appendTo(d.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
  i.scrollbarYActive = null;
  i.scrollbarYHeight = null;
  i.scrollbarYTop = null;
  i.scrollbarYRight = h.toInt(d.css(i.scrollbarYRail, 'right'));
  i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
  i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : h.toInt(d.css(i.scrollbarYRail, 'left'));
  i.scrollbarYOuterWidth = i.isRtl ? h.outerWidth(i.scrollbarY) : null;
  i.railBorderYWidth = h.toInt(d.css(i.scrollbarYRail, 'borderTopWidth')) + h.toInt(d.css(i.scrollbarYRail, 'borderBottomWidth'));
  d.css(i.scrollbarYRail, 'display', 'block');
  i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));
  d.css(i.scrollbarYRail, 'display', '');
  i.railYHeight = null;
  i.railYRatio = null;
}

function getId(element) {
  if (typeof element.dataset === 'undefined') {
    return element.getAttribute('data-ps-id');
  } else {
    return element.dataset.psId;
  }
}

function setId(element, id) {
  if (typeof element.dataset === 'undefined') {
    element.setAttribute('data-ps-id', id);
  } else {
    element.dataset.psId = id;
  }
}

function removeId(element) {
  if (typeof element.dataset === 'undefined') {
    element.removeAttribute('data-ps-id');
  } else {
    delete element.dataset.psId;
  }
}

exports.add = function (element) {
  var newId = guid();
  setId(element, newId);
  instances[newId] = new Instance(element);
  return instances[newId];
};

exports.remove = function (element) {
  delete instances[getId(element)];
  removeId(element);
};

exports.get = function (element) {
  return instances[getId(element)];
};

},{"../lib/dom":5,"../lib/event-manager":6,"../lib/guid":7,"../lib/helper":8,"./default-setting":10}],21:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('../lib/class')
  , d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateScroll = require('./update-scroll');

function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}

function updateCss(element, i) {
  var xRailOffset = {width: i.railXWidth};
  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + element.scrollTop;
  }
  d.css(i.scrollbarXRail, xRailOffset);

  var yRailOffset = {top: element.scrollTop, height: i.railYHeight};
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  d.css(i.scrollbarYRail, yRailOffset);

  d.css(i.scrollbarX, {left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth});
  d.css(i.scrollbarY, {top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth});
}

module.exports = function (element) {
  var i = instances.get(element);

  i.containerWidth = element.clientWidth;
  i.containerHeight = element.clientHeight;
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;

  var existingRails;
  if (!element.contains(i.scrollbarXRail)) {
    existingRails = d.queryChildren(element, '.ps-scrollbar-x-rail');
    if (existingRails.length > 0) {
      existingRails.forEach(function (rail) {
        d.remove(rail);
      });
    }
    d.appendTo(i.scrollbarXRail, element);
  }
  if (!element.contains(i.scrollbarYRail)) {
    existingRails = d.queryChildren(element, '.ps-scrollbar-y-rail');
    if (existingRails.length > 0) {
      existingRails.forEach(function (rail) {
        d.remove(rail);
      });
    }
    d.appendTo(i.scrollbarYRail, element);
  }

  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(i, h.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
    i.scrollbarXLeft = h.toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
  } else {
    i.scrollbarXActive = false;
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = 0;
  }

  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(i, h.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
    i.scrollbarYTop = h.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
  } else {
    i.scrollbarYActive = false;
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    updateScroll(element, 'top', 0);
  }

  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }

  updateCss(element, i);

  cls[i.scrollbarXActive ? 'add' : 'remove'](element, 'ps-active-x');
  cls[i.scrollbarYActive ? 'add' : 'remove'](element, 'ps-active-y');
};

},{"../lib/class":4,"../lib/dom":5,"../lib/helper":8,"./instances":20,"./update-scroll":22}],22:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('./instances');

var upEvent = document.createEvent('Event')
  , downEvent = document.createEvent('Event')
  , leftEvent = document.createEvent('Event')
  , rightEvent = document.createEvent('Event')
  , yEvent = document.createEvent('Event')
  , xEvent = document.createEvent('Event')
  , xStartEvent = document.createEvent('Event')
  , xEndEvent = document.createEvent('Event')
  , yStartEvent = document.createEvent('Event')
  , yEndEvent = document.createEvent('Event')
  , lastTop
  , lastLeft;

upEvent.initEvent('ps-scroll-up', true, true);
downEvent.initEvent('ps-scroll-down', true, true);
leftEvent.initEvent('ps-scroll-left', true, true);
rightEvent.initEvent('ps-scroll-right', true, true);
yEvent.initEvent('ps-scroll-y', true, true);
xEvent.initEvent('ps-scroll-x', true, true);
xStartEvent.initEvent('ps-x-reach-start', true, true);
xEndEvent.initEvent('ps-x-reach-end', true, true);
yStartEvent.initEvent('ps-y-reach-start', true, true);
yEndEvent.initEvent('ps-y-reach-end', true, true);

module.exports = function (element, axis, value) {
  if (typeof element === 'undefined') {
    throw 'You must provide an element to the update-scroll function';
  }

  if (typeof axis === 'undefined') {
    throw 'You must provide an axis to the update-scroll function';
  }

  if (typeof value === 'undefined') {
    throw 'You must provide a value to the update-scroll function';
  }

  if (axis === 'top' && value <= 0) {
    element.scrollTop = 0;
    element.dispatchEvent(yStartEvent);
    return; // don't allow negative scroll
  }

  if (axis === 'left' && value <= 0) {
    element.scrollLeft = 0;
    element.dispatchEvent(xStartEvent);
    return; // don't allow negative scroll
  }

  var i = instances.get(element);

  if (axis === 'top' && value > i.contentHeight - i.containerHeight) {
    element.scrollTop = i.contentHeight - i.containerHeight;
    element.dispatchEvent(yEndEvent);
    return; // don't allow scroll past container
  }

  if (axis === 'left' && value > i.contentWidth - i.containerWidth) {
    element.scrollLeft = i.contentWidth - i.containerWidth;
    element.dispatchEvent(xEndEvent);
    return; // don't allow scroll past container
  }

  if (!lastTop) {
    lastTop = element.scrollTop;
  }

  if (!lastLeft) {
    lastLeft = element.scrollLeft;
  }

  if (axis === 'top' && value < lastTop) {
    element.dispatchEvent(upEvent);
  }

  if (axis === 'top' && value > lastTop) {
    element.dispatchEvent(downEvent);
  }

  if (axis === 'left' && value < lastLeft) {
    element.dispatchEvent(leftEvent);
  }

  if (axis === 'left' && value > lastLeft) {
    element.dispatchEvent(rightEvent);
  }

  if (axis === 'top') {
    element.scrollTop = lastTop = value;
    element.dispatchEvent(yEvent);
  }

  if (axis === 'left') {
    element.scrollLeft = lastLeft = value;
    element.dispatchEvent(xEvent);
  }

};

},{"./instances":20}],23:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateGeometry = require('./update-geometry');

module.exports = function (element) {
  var i = instances.get(element);

  if (!i) {
    return;
  }

  // Recalcuate negative scrollLeft adjustment
  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;

  // Recalculate rail margins
  d.css(i.scrollbarXRail, 'display', 'block');
  d.css(i.scrollbarYRail, 'display', 'block');
  i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
  i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));

  // Hide scrollbars not to affect scrollWidth and scrollHeight
  d.css(i.scrollbarXRail, 'display', 'none');
  d.css(i.scrollbarYRail, 'display', 'none');

  updateGeometry(element);

  d.css(i.scrollbarXRail, 'display', '');
  d.css(i.scrollbarYRail, 'display', '');
};

},{"../lib/dom":5,"../lib/helper":8,"./instances":20,"./update-geometry":21}],24:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],25:[function(require,module,exports){
var _ = cdb._;
var Model = cdb.core.Model;
var DashboardView = require('./dashboard-view');
var WidgetsCollection = require('./widgets/widgets-collection');
var WidgetModelFactory = require('./widgets/widget-model-factory');
var ListModel = require('./widgets/list/model');
var HistogramModel = require('./widgets/histogram/model');
var CategoryModel = require('./widgets/category/model');
var FormulaModel = require('./widgets/formula/model');
var RangeFilter = require('./windshaft/filters/range');
var CategoryFilter = require('./windshaft/filters/category');
var WindshaftConfig = require('./windshaft/config');
var WindshaftClient = require('./windshaft/client');
var WindshaftDashboard = require('./windshaft/dashboard');
var WindshaftPrivateDashboardConfig = require('./windshaft/private-dashboard-config');
var WindshaftPublicDashboardConfig = require('./windshaft/public-dashboard-config');

module.exports = function(selector, diJSON, visOpts) {
  var widgetModelFactory = new WidgetModelFactory({
    list: function(attrs, opts) {
      return new ListModel(attrs, opts);
    },
    formula: function(attrs, opts) {
      return new FormulaModel(attrs, opts);
    },
    histogram: function(attrs, opts, layerIndex) {
      opts.filter = new RangeFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      return new HistogramModel(attrs, opts);
    },
    'time-series': function(attrs, opts, layerIndex) {
      // change type because time-series because it's really a histogram (for the tiler at least)
      attrs.type = 'histogram';
      opts.filter = new RangeFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      var model = new HistogramModel(attrs, opts);

      // since we changed the type of we need some way to identify that it's intended for a time-series view later
      model.isForTimeSeries = true;

      return model;
    },
    aggregation: function(attrs, opts, layerIndex) {
      opts.filter = new CategoryFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      return new CategoryModel(attrs, opts);
    }
  });

  // TODO keep this collection in sync with layers individual widgets collections
  var widgets = new WidgetsCollection();

  var dashboardInfoModel = new Model({
    title: diJSON.title,
    description: diJSON.description,
    updatedAt: diJSON.updated_at,
    userName: diJSON.user.fullname,
    userAvatarURL: diJSON.user.avatar_url
  });
  var dashboardView = new DashboardView({
    el: document.querySelector(selector),
    widgets: widgets,
    dashboardInfoModel: dashboardInfoModel
  });

  var vis = cdb.createVis(dashboardView.$('#map'), diJSON.vizJSON, visOpts);

  var cartoDBLayerGroup;
  var interactiveLayers = [];
  vis.map.layers.each(function(layer) {
    var layerType = layer.get('type');
    var isLayerGroup = layerType === 'layergroup';

    if (isLayerGroup) {
      cartoDBLayerGroup = layer;
    }

    if (isLayerGroup || layerType === 'namedmap') {
      layer.layers.each(function(subLayer) {
        interactiveLayers.push(subLayer);
      });
    } else {
       if (layerType === 'torque') {
        interactiveLayers.push(layer);
       }
    }
  });

  // TODO: We can probably move this logic somewhere else
  var widgetModels = [];
  for (var id in diJSON.widgets) {
    var d = diJSON.widgets[id];
    var layer = _.find(interactiveLayers, function(l) {
      return d.layerId === l.get('id');
    });
    var layerIndex = interactiveLayers.indexOf(layer);
    if (layer) {
      var attrs = _.extend({
        id: id
      }, d);
      var widgetModel = widgetModelFactory.createModel(layer, layerIndex, attrs);
      widgetModels.push(widgetModel);
    } else {
      // TODO layers in a namedmap doesn't have layerId, need some other way to find the corresponding layer for a given widget
      throw Error('no layer found for defined widget');
    }
  }
  // _.each(interactiveLayers, function(layer, layerIndex) {
  //   var widgetsAttrs = layer.get('widgets') || {};
  //   for (var id in widgetsAttrs) {
  //     var attrs = _.extend({
  //       id: id
  //     }, widgetsAttrs[id]);
  //     var widgetModel = widgetModelFactory.createModel(layer, layerIndex, attrs);
  //     widgetModels.push(widgetModel);
  //   }
  // });

  widgets.reset(widgetModels);

  dashboardView.render();

  // TODO: Perhaps this "endpoint" could be part of the "datasource"?
  var endpoint = WindshaftConfig.MAPS_API_BASE_URL;
  var configGenerator = WindshaftPublicDashboardConfig;
  var datasource = diJSON.datasource;
  // TODO: We can use something else to differentiate types of "datasource"s
  if (datasource.template_name) {
    endpoint = [WindshaftConfig.MAPS_API_BASE_URL, 'named', datasource.template_name].join('/');
    configGenerator = WindshaftPrivateDashboardConfig;
  }

  var windshaftClient = new WindshaftClient({
    endpoint: endpoint,
    urlTemplate: datasource.maps_api_template,
    userName: datasource.user_name,
    statTag: datasource.stat_tag,
    forceCors: datasource.force_cors
  });

  var dashboard = new WindshaftDashboard({
    client: windshaftClient,
    configGenerator: configGenerator,
    statTag: datasource.stat_tag,
    //TODO: assuming here all viz.json has a layergroup and that may not be true
    layerGroup: cartoDBLayerGroup,
    layers: interactiveLayers,
    widgets: widgets,
    map: vis.map
  });

  // TODO: rethink this
  if (widgets.size() > 0) {
    setTimeout(function() {
      vis.mapView.invalidateSize();
    }, 0);
  }

  return dashboardView;
};

},{"./dashboard-view":31,"./widgets/category/model":45,"./widgets/formula/model":65,"./widgets/histogram/model":73,"./widgets/list/model":81,"./widgets/widget-model-factory":101,"./widgets/widgets-collection":107,"./windshaft/client":108,"./windshaft/config":109,"./windshaft/dashboard":111,"./windshaft/filters/category":114,"./windshaft/filters/range":116,"./windshaft/private-dashboard-config":117,"./windshaft/public-dashboard-config":118}],26:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var WidgetViewFactory = require('./widgets/widget-view-factory');
var TimeSeriesContentView = require('./widgets/time-series/content-view');
var TorqueTimeSeriesContentView = require('./widgets/time-series/torque-content-view');

module.exports = View.extend({

  className: 'CDB-Dashboard-belowMap',

  initialize: function(options) {
    this._widgetViewFactory = new WidgetViewFactory([
      {
        match: function(m) {
          // isForTimeSeries is set to true to distinguish from default type 'histogram'
          // This match needs to be done before the default time-series widget's match below to have presedence
          return m.isForTimeSeries && m.layer.get('type') === 'torque';
        },
        createContentView: function(m) {
          return new TorqueTimeSeriesContentView({
            model: m,
            rangeFilter: m.filter,
            torqueLayerModel: m.layer
          });
        },
        customizeWidgetAttrs: function(attrs) {
          attrs.className += ' CDB-Widget--timeSeries';
          return attrs;
        }
      }, {
        match: function(m) {
          // isForTimeSeries is set to true to distinguish from default type 'histogram'
          return m.isForTimeSeries;
        },
        createContentView: function(m) {
          return new TimeSeriesContentView({
            model: m,
            filter: m.filter
          });
        },
        customizeWidgetAttrs: function(attrs) {
          attrs.className += ' CDB-Widget--timeSeries';
          return attrs;
        }
      }
    ]);

    this._widgets = options.widgets;
    this._widgets.bind('add', this._maybeRenderWidgetView, this);
    this._widgets.bind('reset', this.render, this);
    this.add_related_model(this._widgets);
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    this._widgets.each(this._maybeRenderWidgetView, this);
    this.$el.toggle(!_.isEmpty(this._subviews));
    return this;
  },

  _maybeRenderWidgetView: function(widgetModel) {
    var view = this._widgetViewFactory.createWidgetView(widgetModel);
    if (view) {
      this.addView(view);
      this.$el.append(view.render().el);
    }
  }

});

},{"./widgets/time-series/content-view":90,"./widgets/time-series/torque-content-view":93,"./widgets/widget-view-factory":103}],27:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./dashboard-info-view.tpl');
var moment = require('moment');

var DashboardInfoView = View.extend({

  className: 'CDB-Dashboard-info',

  events: {
    'click .js-toggle-view-link': "_toggleView"
  },

  render: function() {
    this.$el.html(
      template({
        title: this.model.get('title'),
        description: this.model.get('description'),
        updatedAt: moment(this.model.get('updatedAt')).fromNow(),
        userName: this.model.get('userName'),
        userAvatarURL: this.model.get('userAvatarURL')
      })
    );

    return this;
  },

  _toggleView: function() {
    this.$el.toggleClass('is-active');
  }
});

module.exports = DashboardInfoView;

},{"./dashboard-info-view.tpl":28,"moment":2}],28:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Dashboard-infoHeader"> <div class="CDB-Dashboard-infoLogo"> <i class="CDB-Icon CDB-Icon-cartofante"></i> </div> <div class="CDB-Dashboard-infoActions"> <button class="CDB-Dashboard-infoActionsLink js-toggle-view-link"></button> </div> <div class="CDB-Dashboard-infoTexts"> <p class="CDB-Dashboard-infoUpdate">UPDATED '+
((__t=( updatedAt ))==null?'':_.escape(__t))+
'</p> <h1 class="CDB-Dashboard-infoTitle">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h1> <h2 class="CDB-Dashboard-infoDescription">'+
((__t=( description ))==null?'':_.escape(__t))+
'</h2> </div> </div> <div class="CDB-Dashboard-infoFooter"> <ul>  <li class="CDB-Dashboard-infoFooterItem"> <div class="CDB-Dashboard-infoMedia CDB-Dashboard-infoAvatar"> <img src="'+
((__t=( userAvatarURL ))==null?'':_.escape(__t))+
'" alt="avatar" class="inline-block"> </div> <p class="CDB-Dashboard-infoFooterTxt">'+
((__t=( userName ))==null?'':_.escape(__t))+
'</p> </li> </ul> </div>';
}
return __p;
};

},{"underscore":24}],29:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var Ps = require('perfect-scrollbar');
var View = cdb.core.View;
var Model = cdb.core.Model;
var CategoryContentView = require('./widgets/category/content_view');
var FormulaContentView = require('./widgets/formula/content_view');
var HistogramContentView = require('./widgets/histogram/content-view');
var ListContentView = require('./widgets/list/content_view');
var WidgetViewFactory = require('./widgets/widget-view-factory');
var template = require('./dashboard-sidebar.tpl');

module.exports = View.extend({

  className: 'CDB-Widget-canvas',

  initialize: function(options) {
    this._widgetViewFactory = new WidgetViewFactory([
      {
        type: 'formula',
        createContentView: function(m) {
          return new FormulaContentView({
            model: m
          });
        }
      }, {
        type: 'list',
        createContentView: function(m) {
          return new ListContentView({
            model: m
          });
        }
      }, {
        match: function(m) {
          return m.get('type') === 'histogram' && m.layer.get('type') !== 'torque';
        },
        createContentView: function(m) {
          return new HistogramContentView({
            dataModel: m,
            viewModel: new Model(),
            filter: m.filter
          });
        }
      }, {
        type: 'aggregation',
        createContentView: function(m) {
          return new CategoryContentView({
            model: m,
            filter: m.filter
          });
        }
      }
    ]);

    this._widgets = options.widgets;

    this._widgets.bind('add', this._maybeRenderWidgetView, this);
    this._widgets.bind('reset', this.render, this);
    this._widgets.bind('change:collapsed', this._onWidgetCollapsed, this);
    this.add_related_model(this._widgets);
  },

  render: function() {
    this._cleanScrollEvent();
    this.clearSubViews();

    this.$el.html(template());
    this._widgets.each(this._maybeRenderWidgetView, this);
    this.$el.toggle(!_.isEmpty(this._subviews));

    this._renderScroll();
    this._renderShadows();
    this._bindScroll();

    return this;
  },

  _$container: function() {
    return $(this._container());
  },

  _container: function() {
    return this.el.querySelector('.js-container');
  },

  _maybeRenderWidgetView: function(widgetModel) {
    var view = this._widgetViewFactory.createWidgetView(widgetModel);
    if (view) {
      this.addView(view);
      this._$container().append(view.render().el);
    }
  },

  _bindScroll: function() {
    this._$container()
      .on('ps-y-reach-start', _.bind(this._onScrollTop, this))
      .on('ps-y-reach-end', _.bind(this._onScrollBottom, this))
      .on('ps-scroll-y', _.bind(this._onScroll, this));
  },

  _renderScroll: function() {
    Ps.initialize(this._container(), {
      wheelSpeed: 2,
      wheelPropagation: true,
      minScrollbarLength: 20
    });
  },

  _onWidgetCollapsed: function() {
    Ps.update(this._container());
  },

  _renderShadows: function() {
    var self = this;
    this.$shadowTop = $('<div>').addClass("CDB-Widget-canvasShadow CDB-Widget-canvasShadow--top");
    this.$shadowBottom = $('<div>').addClass("CDB-Widget-canvasShadow CDB-Widget-canvasShadow--bottom is-visible");
    this.$el.append(this.$shadowTop);
    this.$el.append(this.$shadowBottom);
  },

  _onScrollTop: function() {
    this.$shadowTop.removeClass('is-visible');
  },

  _onScroll: function() {
    var $el = this._$container();
    var currentPos = $el.scrollTop();
    var max = $el.get(0).scrollHeight;
    var height = $el.outerHeight();
    var maxPos = max - height;
    this.$shadowTop.toggleClass('is-visible', currentPos > 0);
    this.$shadowBottom.toggleClass('is-visible', currentPos < maxPos);
  },

  _onScrollBottom: function() {
    this.$shadowBottom.removeClass('is-visible');
  },

  _cleanScrollEvent: function() {
    if (this._$container()) {
      this._$container().off('ps-scroll-y');
    }
  },

  clean: function() {
    this._cleanScrollEvent();
    View.prototype.clean.call(this);
  }

});

},{"./dashboard-sidebar.tpl":30,"./widgets/category/content_view":35,"./widgets/formula/content_view":64,"./widgets/histogram/content-view":69,"./widgets/list/content_view":76,"./widgets/widget-view-factory":103,"perfect-scrollbar":3}],30:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-canvasInner js-container"></div>';
}
return __p;
};

},{"underscore":24}],31:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./dashboard.tpl');
var DashboardBelowMapView = require('./dashboard-below-map-view');
var DashboardInfoView = require('./dashboard-info-view');
var DashboardSidebarView = require('./dashboard-sidebar-view');

/**
 * Dashboard is a wrapper around the map canvas, which contains widget views for the map contdxt
 * Widgets may be rendered in two areas, in the "sidebar" or "below-map".
 */
module.exports = View.extend({

  className: 'CDB-Dashboard-canvas',

  initialize: function(options) {
    this._widgets = options.widgets;
    this._dashboardInfoModel = options.dashboardInfoModel;

    // TODO parent context requires some markup to be present already, but NOT the other views
    this.el.classList.add(this.className);
    this.$el.html(template());
  },

  render: function() {
    this.clearSubViews();

    var view;
    view = new DashboardInfoView({
      model: this._dashboardInfoModel
    });
    this.addView(view);
    this.$el.append(view.render().el);

    view = new DashboardBelowMapView({
      widgets: this._widgets
    });
    this.addView(view);
    this.$('.js-map-wrapper').append(view.render().el);

    view = new DashboardSidebarView({
      widgets: this._widgets
    });
    this.addView(view);
    this.$el.append(view.render().el);

    return this;
  }
});

},{"./dashboard-below-map-view":26,"./dashboard-info-view":27,"./dashboard-sidebar-view":29,"./dashboard.tpl":32}],32:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Dashboard-mapWrapper CDB-Dashboard-mapWrapper--margin js-map-wrapper"> <div class="CDB-Map-canvas"> <div class="CDB-Map" id="map"></div> </div> </div>';
}
return __p;
};

},{"underscore":24}],33:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var d3 = cdb.d3;
var log = cdb.log;
var View = cdb.core.View;

/**
 * Animate between two values
 */
module.exports = View.extend({

  animateFromValues: function(from, to, className, template, opts) {
    var $el = this.$(className);
    var options = opts || {};
    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};
    var debounceWait = options.debounceWait || 500;

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  },

  animateFromCurrentValue: function(value, className, template, opts) {
    var $el = this.$(className);

    var options = opts || {};
    var debounceWait = options.debounceWait || 500;

    var to   = value;
    var from = +this.$(className).text();

    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  },

  animateValue: function(model, what, className, template, opts) {
    var $el = this.$(className);

    var options = opts || {};
    var debounceWait = options.debounceWait || 500;

    var to   = model.get(what);
    var from = model.previous(what) || 0;

    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  }
});

},{}],34:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header js-header"></div> <div class="CDB-Widget-content CDB-Widget-content--noSidesMargin"> <div class="CDB-Widget-listWrapper js-content"></div> </div> <div class="CDB-Widget-footer js-footer"></div>';
}
return __p;
};

},{"underscore":24}],35:[function(require,module,exports){
var _ = cdb._;
var WidgetContent = require('../standard/widget_content_view');
var SearchTitleView = require('./title/search_title_view');
var CategoryOptionsView = require('./options/options_view');
var CategoryItemsView = require('./list/items_view');
var WidgetViewModel = require('../widget_content_model');
var CategoryStatsView = require('./stats/stats_view');
var CategoryPaginatorView = require('./paginator/paginator_view');
var SearchCategoryItemsView = require('./list/search_items_view');
var SearchCategoryPaginatorView = require('./paginator/search_paginator_view');
var template = require('./content_template.tpl');

/**
 * Content view for category widget
 *
 */

module.exports = WidgetContent.extend({

  _ITEMS_PER_PAGE: 6,

  initialize: function(opts) {
    this.viewModel = new WidgetViewModel();
    WidgetContent.prototype.initialize.call(this, arguments);
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(template());
    this._initViews();
    return this;
  },

  _initBinds: function() {
    this.model.bind('change:collapsed', function(mdl, isCollapsed) {
      this.$el.toggleClass('is-collapsed', !!isCollapsed);
    }, this);
  },

  _initViews: function() {
    var searchTitle = new SearchTitleView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-header').append(searchTitle.render().el);
    this.addView(searchTitle);

    var stats = new CategoryStatsView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-header').append(stats.render().el);
    this.addView(stats);

    var options = new CategoryOptionsView({
      dataModel: this.model,
      viewModel: this.viewModel
    });
    this.$('.js-content').html(options.render().el);
    this.addView(options);

    var dataList = new CategoryItemsView({
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE
    });
    this.$('.js-content').append(dataList.render().el);
    this.addView(dataList);

    var pagination = new CategoryPaginatorView({
      $target: dataList.$el,
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE
    });
    this.$('.js-footer').append(pagination.render().el);
    this.addView(pagination);

    var searchList = new SearchCategoryItemsView({
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE,
      paginator: true
    });
    this.$('.js-content').append(searchList.render().el);
    this.addView(searchList);

    var searchPagination = new SearchCategoryPaginatorView({
      $target: searchList.$el,
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE,
      paginator: true
    });
    this.$('.js-footer').append(searchPagination.render().el);
    this.addView(searchPagination);
  }

});

},{"../standard/widget_content_view":85,"../widget_content_model":105,"./content_template.tpl":34,"./list/items_view":42,"./list/search_items_view":44,"./options/options_view":53,"./paginator/paginator_view":55,"./paginator/search_paginator_view":57,"./stats/stats_view":60,"./title/search_title_view":62}],36:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button type="button" class="CDB-Widget-listItemInner CDB-Widget-listButton js-button '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( formattedValue ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState '+
((__t=( isAggregated ? 'CDB-Widget-progressState--pattern' : '' ))==null?'':_.escape(__t))+
'" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%; background-color: '+
((__t=( customColor ? color : '' ))==null?'':_.escape(__t))+
'"></div> </div> </button>';
}
return __p;
};

},{"underscore":24}],37:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-listItemInner '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( formattedValue ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState CDB-Widget-progressState--pattern '+
((__t=( isAggregated ? 'CDB-Widget-progressState--inactive' : '' ))==null?'':_.escape(__t))+
'" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%; background-color: '+
((__t=( customColor ? color : '' ))==null?'':_.escape(__t))+
'"></div> </div> </div>';
}
return __p;
};

},{"underscore":24}],38:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var formatter = cdb.core.format;
var clickableTemplate = require('./item_clickable_template.tpl');
var unclickableTemplate = require('./item_unclickable_template.tpl');

/**
 * Category list item view
 */
module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function(options) {
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    var value = this.model.get('value');
    var template = this.model.get('agg') || this.dataModel.isLocked() ?
      unclickableTemplate : clickableTemplate;

    this.$el.html(
      template({
        customColor: this.dataModel.isColorApplied(),
        isAggregated: this.model.get('agg'),
        name: this.model.get('name'),
        value: value,
        formattedValue: formatter.formatNumber(value),
        percentage: ((value / this.dataModel.get('max')) * 100),
        color: this.model.get('color'),
        isDisabled: !this.model.get('selected') ? 'is-disabled' : '',
        prefix: this.dataModel.get('prefix'),
        suffix: this.dataModel.get('suffix')
      })
    );

    return this;
  },

  _initBinds: function() {
    this.model.bind('change', this.render, this);
    this.dataModel.bind('change:search change:categoryColors', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _onItemClick: function() {
    this.trigger('itemClicked', this.model, this);
  }

});

},{"./item_clickable_template.tpl":36,"./item_unclickable_template.tpl":37}],39:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button type="button" class="CDB-Widget-listItemInner CDB-Widget-listItemInner--fullSpace CDB-Widget-listButton js-button '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Widget-checkbox '+
((__t=( isDisabled ? '' : 'is-checked' ))==null?'':_.escape(__t))+
'"></span> <div class="u-lSpace--xl"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%"></div> </div> </div> </button>';
}
return __p;
};

},{"underscore":24}],40:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var formatter = cdb.core.format;
var template = require('./search_item_clickable_template.tpl');

/**
 * Category search list view
 */
module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function(options) {
    // This data model comes from the original data in order to get
    // the max value and set properly the progress bar and add the
    // necessary suffix and prefix for the item.
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    var value = this.model.get('value');

    this.$el.html(
      template({
        name: this.model.get('name'),
        value: value,
        formattedValue: formatter.formatNumber(value),
        percentage: ((value / this.dataModel.get('max')) * 100),
        isDisabled: !this.model.get('selected'),
        prefix: this.dataModel.get('prefix'),
        suffix: this.dataModel.get('suffix')
      })
    );

    return this;
  },

  _initBinds: function() {
    this.model.bind('change:selected', this.render, this);
  },

  _onItemClick: function() {
    this.model.set('selected', !this.model.get('selected'));
  }

});

},{"./search_item_clickable_template.tpl":39}],41:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li>';
}
return __p;
};

},{"underscore":24}],42:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var CategoryItemView = require('./item/item_view');
var placeholder = require('./items_placeholder_template.tpl');

/**
 * Category list view
 */
module.exports = View.extend({

  options: {
    paginator: false,
    itemsPerPage: 6
  },

  className: 'CDB-Widget-list CDB-Widget-list--wrapped js-list',
  tagName: 'ul',

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var data = this.dataModel.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;

    if (isDataEmpty) {
      this._renderPlaceholder();
    } else {
      this._renderList();
    }
    return this;
  },

  _initBinds: function() {
    this.viewModel.bind('change:search', this.toggle, this);
    this.dataModel.bind('change:data change:searchData', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _renderPlaceholder: function() {
    // Change view classes
    this.$el
      .addClass('CDB-Widget-list--withBorders')
      .removeClass('CDB-Widget-list--wrapped');
    this.$el.append(placeholder());
  },

  _renderList: function() {
    // Change view classes
    this.$el.removeClass('CDB-Widget-list--withBorders');
    this.$el[ this.options.paginator ? 'addClass' : 'removeClass']('CDB-Widget-list--wrapped');

    var groupItem;
    var data = this.dataModel.getData();

    data.each(function(mdl, i) {
      if (i % this.options.itemsPerPage === 0) {
        groupItem = $('<div>').addClass('CDB-Widget-listGroup');
        this.$el.append(groupItem);
      }
      this._addItem(mdl, groupItem);
    }, this);
  },

  _addItem: function(mdl, $parent) {
    var v = new CategoryItemView({
      model: mdl,
      dataModel: this.dataModel
    });
    v.bind('itemClicked', this._setFilters, this);
    this.addView(v);
    $parent.append(v.render().el);
  },

  _setFilters: function(mdl) {
    var isSelected = mdl.get('selected');

    if (isSelected) {
      if (!this.dataModel.getRejectedCount() && !this.dataModel.getAcceptedCount() && this.dataModel.getCount() > 1) {
        var data = this.dataModel.getData();
        var rejects = [];
        // Make elements "unselected"
        data.map(function(m) {
          var name = m.get('name');
          if (name !== mdl.get('name')) {
            m.set('selected', false);
          }
        });
        this.dataModel.acceptFilters(mdl.get('name'));
      } else {
        mdl.set('selected', false);
        this.dataModel.rejectFilters(mdl.get('name'));
      }
    } else {
      mdl.set('selected', true);
      this.dataModel.acceptFilters(mdl.get('name'));
    }
  },

  toggle: function() {
    this[ !this.viewModel.isSearchEnabled() ? 'show' : 'hide']();
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  }

});

},{"./item/item_view":38,"./items_placeholder_template.tpl":41}],43:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<li class="CDB-Widget-listItem"> <h4 class="CDB-Widget-textBig CDB-Widget-textBig--bold">No results</h4> <p class="CDB-Widget-textSmall u-tSpace-xl">Your search "'+
((__t=( q ))==null?'':_.escape(__t))+
'" didn\'t match<br>with any value.</p> <p class="CDB-Widget-textSmall u-tSpace-xl">Try searching again.</p> </li>';
}
return __p;
};

},{"underscore":24}],44:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var CategoryItemsView = require('./items_view');
var WidgetSearchCategoryItemView = require('./item/search_item_view');
var placeholder = require('./search_items_no_results_template.tpl');

/**
 * Category list view
 */
module.exports = CategoryItemsView.extend({

  className: 'CDB-Widget-list is-hidden CDB-Widget-list--wrapped js-list',

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var data = this.dataModel.getSearchResult();
    var isDataEmpty = data.isEmpty() || data.size() === 0;

    if (isDataEmpty) {
      this._renderPlaceholder();
    } else {
      this._renderList();
    }
    return this;
  },

  _renderList: function() {
    this.$el.removeClass('CDB-Widget-list--withBorders CDB-Widget-list--noresults');
    this.$el.addClass('CDB-Widget-list--wrapped');

    var groupItem;
    var data = this.dataModel.getSearchResult();

    data.each(function(mdl, i) {
      if (i % this.options.itemsPerPage === 0) {
        groupItem = $('<div>').addClass('CDB-Widget-listGroup');
        this.$el.append(groupItem);
      }
      this._addItem(mdl, groupItem);
    }, this);
  },

  _renderPlaceholder: function() {
    // Change view classes
    this.$el
      .addClass('CDB-Widget-list--noresults')
      .removeClass('CDB-Widget-list--wrapped');

    this.$el.html(
      placeholder({
        q: this.dataModel.getSearchQuery()
      })
    );
  },

  _addItem: function(mdl, $parent) {
    var v = new WidgetSearchCategoryItemView({
      model: mdl,
      dataModel: this.dataModel
    });
    this.addView(v);
    $parent.append(v.render().el);
  },

  toggle: function() {
    this[ this.viewModel.isSearchEnabled() ? 'show' : 'hide']();
  }

});

},{"./item/search_item_view":40,"./items_view":42,"./search_items_no_results_template.tpl":43}],45:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;
var d3 = cdb.d3;
var CategoryColors = require('./models/category_colors');
var WidgetModel = require('../widget_model');
var WidgetSearchModel = require('./models/search_model');
var CategoryModelRange = require('./models/category_model_range');
var CategoriesCollection = require('./models/categories_collection');
var LockedCatsCollection = require('./models/locked_categories_collection');

/**
 *  Category widget model
 *
 *  - It has several internal models/collections
 *
 *  · search model: it manages category search results.
 *  · locked collection: it stores locked items.
 *  · filter model: it knows which items are accepted or rejected.
 *
 */

module.exports = WidgetModel.extend({

  url: function() {
    return this.get('url') + '?bbox=' + this.get('boundingBox') + '&own_filter=' + (this.get('locked') ? 1 : 0);
  },

  initialize: function(attrs, opts) {
    this._data = new CategoriesCollection();

    WidgetModel.prototype.initialize.call(this, attrs, opts);

    // Locked categories collection
    this.locked = new LockedCatsCollection();

    // Internal model for calculating total amount of values in the category
    this.rangeModel = new CategoryModelRange();

    // Colors class
    this.colors = new CategoryColors();

    // Search model
    this.search = new WidgetSearchModel({}, {
      locked: this.locked
    });
  },

  // Set any needed parameter when they have changed in this model
  _setInternalModels: function() {
    var url = this.get('url');

    this.search.set({
      url: url,
      boundingBox: this.get('boundingBox')
    });

    this.rangeModel.setUrl(url);
  },

  _onChangeBinds: function() {
    this._setInternalModels();

    this.rangeModel.bind('change:totalCount', function(mdl, value) {
      this.set('totalCount', value);
    }, this);

    this.bind('change:url', function(){
      if (this.get('sync') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:boundingBox', function() {
      // If a search is applied and bounding bounds has changed,
      // don't fetch new raw data
      if (this.get('bbox') && !this.isSearchApplied() && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:url change:boundingBox', function() {
      this.search.set({
        url: this.get('url'),
        boundingBox: this.get('boundingBox')
      });
    }, this);

    this.bind('change:collapsed', function(mdl, isCollapsed) {
      if (!isCollapsed) {
        if (mdl.changedAttributes(this._previousAttrs)) {
          this._fetch();
        }
      } else {
        this._previousAttrs = {
          url: this.get('url'),
          boundingBox: this.get('boundingBox')
        };
      }
    }, this);

    this.locked.bind('change add remove', function() {
      this.trigger('change:lockCollection', this.locked, this);
    }, this);

    this.search.bind('loading', function() {
      this.trigger("loading", this);
    }, this);
    this.search.bind('sync', function() {
      this.trigger("sync", this);
    }, this);
    this.search.bind('error', function(e) {
      if (!e || (e && e.statusText !== "abort")) {
        this.trigger("error", this);
      }
    }, this);
    this.search.bind('change:data', function() {
      this.trigger('change:searchData', this.search, this);
    }, this);
  },

  /*
   *  Helper methods for internal models/collections
   *
   */

  applyCategoryColors: function() {
    this.set('categoryColors', true);
    var colorsData = this._data.map(function(m){
      return [ m.get('name'), m.get('color') ];
    });
    this.trigger('applyCategoryColors', colorsData, this);
  },

  cancelCategoryColors: function() {
    this.set('categoryColors', false);
    this.trigger('cancelCategoryColors', this);
  },

  isColorApplied: function() {
    return this.get('categoryColors');
  },

  // Locked collection helper methods //

  getLockedSize: function() {
    return this.locked.size();
  },

  isLocked: function() {
    return this.get('locked');
  },

  canBeLocked: function() {
    return this.isLocked() ||
      this.getAcceptedCount() > 0;
  },

  canApplyLocked: function() {
    var acceptedCollection = this.filter.getAccepted();
    if (this.filter.getAccepted().size() !== this.locked.size()) {
      return true;
    }

    return acceptedCollection.find(function(m) {
      return !this.locked.isItemLocked(m.get('name'));
    }, this);
  },

  applyLocked: function() {
    var currentLocked = this.locked.getItemsName();
    if (!currentLocked.length) {
      this.unlockCategories();
      return false;
    }
    this.set('locked', true);
    this.filter.cleanFilter(false);
    this.filter.accept(currentLocked);
    this.filter.applyFilter();
    this.cleanSearch();
  },

  lockCategories: function() {
    this.set('locked', true);
    this._fetch();
  },

  unlockCategories: function() {
    this.set('locked', false);
    this.acceptAll();
  },

  // Search model helper methods //

  getSearchQuery: function() {
    return this.search.getSearchQuery();
  },

  setSearchQuery: function(q) {
    this.search.set('q', q);
  },

  isSearchValid: function() {
    return this.search.isValid();
  },

  getSearchResult: function() {
    return this.search.getData();
  },

  getSearchCount: function() {
    return this.search.getCount();
  },

  applySearch: function() {
    this.search.fetch();
  },

  isSearchApplied: function() {
    return this.search.isSearchApplied();
  },

  cleanSearch: function() {
    this.locked.resetItems([]);
    this.search.resetData();
  },

  setupSearch: function() {
    if (!this.isSearchApplied()) {
      var acceptedCats = this.filter.getAccepted().toJSON();
      this.locked.addItems(acceptedCats);
      this.search.setData(
        this._data.toJSON()
      );
    }
  },

  // Filter model helper methods //

  getRejectedCount: function() {
    return this.filter.rejectedCategories.size();
  },

  getAcceptedCount: function() {
    return this.filter.acceptedCategories.size();
  },

  acceptFilters: function(values) {
    this.filter.accept(values);
  },

  rejectFilters: function(values) {
    this.filter.reject(values);
  },

  rejectAll: function() {
    this.filter.rejectAll();
  },

  acceptAll: function() {
    this.filter.acceptAll();
  },

  isAllFiltersRejected: function() {
    return this.filter.get('rejectAll');
  },

  // Proper model helper methods //

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  getCount: function() {
    return this.get('categoriesCount');
  },

  refresh: function() {
    if (this.isSearchApplied()) {
      this.search.fetch();
    } else {
      this._fetch();
    }
  },

  // Data parser methods //

  _parseData: function(categories) {
    var newData = [];
    var _tmpArray = {};
    var acceptedCats = this.filter.getAccepted();

    // Update colors by data categories
    this.colors.updateData(
      _.uniq(
        _.union(
          _.pluck(categories, 'category'),
          _.pluck(acceptedCats, 'name')
        )
      )
    );

    _.each(categories, function(datum, i) {
      var category = datum.category;
      var isRejected = this.filter.isRejected(category);
      _tmpArray[category] = true;

      newData.push({
        selected: !isRejected,
        name: category,
        agg: datum.agg,
        value: datum.value,
        color: this.colors.getColorByCategory(category)
      });
    }, this);

    if (this.isLocked()) {
      // Add accepted items that are not present in the categories data
      acceptedCats.each(function(mdl, i) {
        var category = mdl.get('name').toString();
        if (!_tmpArray[category]) {
          newData.push({
            selected: true,
            color: this.colors.getColorByCategory(category),
            name: category,
            agg: false,
            value: 0
          });
        }
      }, this);
    }

    return {
      data: newData
    }
  },

  setCategories: function(d) {
    var attrs = this._parseData(d);
    this._data.reset(attrs.data);
    this.set(attrs);
    if (this.isColorApplied()) {
      this.applyCategoryColors();
    }
  },

  parse: function(d) {
    var categories = d.categories;
    var attrs = this._parseData(categories);

    _.extend(attrs, {
        nulls: d.nulls,
        min: d.min,
        max: d.max,
        count: d.count,
        categoriesCount: d.categoriesCount
      }
    );
    this._data.reset(attrs.data);
    if (this.isColorApplied()) {
      this.applyCategoryColors();
    }
    return attrs;
  },

  // Backbone toJson function override

  toJSON: function() {
    return {
      type: "aggregation",
      options: {
        column: this.get('column'),
        aggregation: this.get('aggregation'),
        aggregationColumn: this.get('aggregationColumn')
      }
    };
  }

});

},{"../widget_model":106,"./models/categories_collection":46,"./models/category_colors":47,"./models/category_model_range":49,"./models/locked_categories_collection":50,"./models/search_model":51}],46:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var CategoryItemModel = require('./category_item_model');

/**
 *  Data categories collection
 *
 *  - It basically sorts by (value, selected and "Other").
 */

module.exports = Backbone.Collection.extend({

  model: CategoryItemModel,

  comparator: function(a,b) {
    if (a.get('name') === 'Other') {
      return 1;
    } else if (b.get('name') === 'Other') {
      return -1;
    } else if (a.get('value') === b.get('value')) {
      return (a.get('selected') < b.get('selected')) ? 1 : -1;
    } else {
      return (a.get('value') < b.get('value')) ? 1 : -1;
    }
  }

});

},{"./category_item_model":48}],47:[function(require,module,exports){
var _ = cdb._;
// var colorbrewer = require('colorbrewer');
// var categoryColors = _.initial(colorbrewer.Accent[8]); // Color brewer colors
var categoryColors = ['#2CA095','#E5811B','#4A4DBA','#AD2BAD','#559030','#E1C221']; // Demo colors
var defaultColor = '#CCC';

/**
 *  Class to set categories to each color
 *  - Right now, there is a relation 1 color to 1 category.
 *  - If that category is not available in the new data, that
 *    color will be freed.
 *
 */

function CategoryColors() {
  this.colors = {};
  _.each(categoryColors, function(c) {
    this.colors[c] = null;
  }, this);
}

CategoryColors.prototype.updateData = function(d) {
  // Remove categories from colors where they are not present anymore
  _.each(this.colors, function(value, key) {
    if (!_.contains(d, value)) {
      this.colors[key] = null;
    } else {
      d = _.without(d, value);
    }
  }, this);

  // Set colors by new categories
  _.each(d, function(category) {
    var nextFreeColor = this.getNextAvailableColor();
    if (nextFreeColor) {
      this.colors[nextFreeColor] = category;
    }
  }, this);
};

CategoryColors.prototype.getNextAvailableColor = function() {
  for (var i in this.colors) {
    if (this.colors[i] === null) {
      return i;
    }
  }
  return null;
};

CategoryColors.prototype.getColorByCategory = function (category) {
  for (var i in this.colors) {
    if (this.colors[i] === category) {
      return i;
    }
  }
  return defaultColor;
};

CategoryColors.prototype.getCategoryByColor = function (color) {
  return this.colors[color];
};

module.exports = CategoryColors;

},{}],48:[function(require,module,exports){

var Model = cdb.core.Model;

/**
 *
 */

module.exports = Model.extend({

  defaults: {
    name: '',
    agg: false,
    value: 0
  }

});

},{}],49:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;

/**
 *  This model is used for getting the total amount of values
 *  from the category.
 *
 */

module.exports = Model.extend({

  defaults: {
    url: '',
    totalCount: 0
  },

  url: function() {
    return this.get('url');
  },

  initialize: function() {
    this.bind('change:url', function() {
      this.fetch();
    }, this);
  },

  setUrl: function(url) {
    this.set('url', url);
  },

  parse: function(d) {
    // Calculating the total amount of all categories with the sum of all
    // values from this model included the aggregated (Other)

    return {
      totalCount: _.reduce(
        _.pluck(d.categories, 'value'),
        function(memo, value) {
          return memo + value;
        },
        0
      )
    };
  }
});

},{}],50:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var CategoryItemModel = require('./category_item_model');

/**
 *  Locked categories collection
 *
 */

module.exports = Backbone.Collection.extend({

  model: CategoryItemModel,

  addItem: function(mdl) {
    if (!this.isItemLocked(mdl.get('name'))) {
      this.add(mdl);
    }
  },

  addItems: function(mdls) {
    _.each(mdls, function(m) {
      if (!this.isItemLocked(m.name)) {
        this.add(m);
      }
    }, this);
  },

  resetItems: function(mdls) {
    this.reset(mdls);
  },

  removeItem: function(mdl) {
    var lockedItem = this.isItemLocked(mdl.get('name'));
    if (lockedItem) {
      this.remove(lockedItem);
    }
  },

  removeItems: function() {
    this.reset([]);
  },

  isItemLocked: function(name) {
    return this.find(function(d) {
      return d.get('name') === name;
    });
  },

  getItemsName: function() {
    return this.pluck('name');
  }

});

},{"./category_item_model":48}],51:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;
var CategoriesCollection = require('./categories_collection');

/**
 * Category search model
 */
module.exports = Model.extend({

  defaults: {
    q: '',
    data: [],
    url: ''
  },

  url: function() {
    return this.get('url') + '/search?q=' + encodeURIComponent(this.get('q'));
  },

  initialize: function(attrs, opts) {
    // Locked collection will have the status
    // of the selected/locked items
    this.locked = opts.locked;
    this._data = new CategoriesCollection();
    this._initBinds();
  },

  _initBinds: function() {
    this._data.bind('change:selected', this._onChangeSelected, this);
    this.bind('change:boundingBox', function() {
      if (this.isSearchApplied()) {
        this.fetch();
      }
    }, this);
  },

  setData: function(data) {
    var categories = this._parseData(data);
    this._data.reset(categories);
    this.set('data', categories);
  },

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  getCount: function() {
    return this.getSize();
  },

  isValid: function() {
    var str = this.get('q');
    return !!(str||'');
  },

  isLocked: function() {},

  resetData: function() {
    this.setData([]);
    this.set('q', '');
  },

  getSearchQuery: function() {
    return this.get('q');
  },

  isSearchApplied: function() {
    return this.isValid() && this.getSize() > 0;
  },

  _onChangeSelected: function(mdl, isSelected) {
    this.locked[ isSelected ? 'addItem' : 'removeItem' ](mdl);
  },

  _parseData: function(categories) {
    var newData = [];
    _.each(categories, function(d) {
      if (!d.agg) {
        var category = (d.category || d.name).toString();
        var isLocked = this.locked.isItemLocked(category);
        newData.push({
          selected: isLocked,
          name: category,
          agg: d.agg,
          value: d.value
        });
      }
    }, this);

    return newData;
  },

  parse: function(r) {
    var categories = this._parseData(r.categories);
    this._data.reset(categories);
    return {
      data: categories
    };
  },

  fetch: function(opts) {
    this.trigger("loading", this);
    return Model.prototype.fetch.call(this, opts);
  },

  sync: function() {
    var self = arguments[1];
    if (this._xhr) {
      this._xhr.abort();
    }
    this._xhr = Model.prototype.sync.apply(this, arguments);
    this._xhr.always(function() {
      self._xhr = null;
    });
    return this._xhr;
  }

});

},{"./categories_collection":46}],52:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) { 
__p+=' <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark CDB-Widget-textSmaller--upper">'+
((__t=( totalLocked ))==null?'':_.escape(__t))+
' selected</p> ';
 } else { 
__p+=' <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark CDB-Widget-textSmaller--upper"> ';
 if (isLocked) { 
__p+=' '+
((__t=( totalCats ))==null?'':_.escape(__t))+
' blocked <button class="CDB-Widget-link u-lSpace js-unlock">unlock</button> ';
 } else { 
__p+=' '+
((__t=( rejectedCats === 0 && acceptedCats === 0 || acceptedCats >= totalCats ? "All selected" : acceptedCats + " selected" ))==null?'':_.escape(__t))+
' ';
 if (canBeLocked) { 
__p+=' <button class="CDB-Widget-link u-lSpace js-lock">lock</button> ';
 }
__p+=' ';
 }
__p+=' </p> ';
 if (!isLocked) { 
__p+=' <div class="CDB-Widget-filterButtons"> ';
 if (rejectedCats > 0 || acceptedCats > 0 || isAllRejected) { 
__p+=' <button class="CDB-Widget-link CDB-Widget-filterButton js-all">all</button> ';
 } 
__p+=' ';
 if (totalCats > rejectedCats && !isAllRejected) { 
__p+=' <button class="CDB-Widget-link CDB-Widget-filterButton js-none">none</button> ';
 } 
__p+=' </div> ';
 } 
__p+=' ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],53:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var template = require('./options_template.tpl');

/**
 * Category filter view
 *
 */
module.exports = View.extend({

  className: 'CDB-Widget-filter CDB-Widget-contentSpaced CDB-Widget-contentSpaced--sideMargins',

  events: {
    'click .js-all': '_onSelectAll',
    'click .js-none': '_onUnselectAll',
    'click .js-lock': '_lockCategories',
    'click .js-unlock': '_unlockCategories'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this.viewModel = this.options.viewModel;
    this._initBinds();
  },

  render: function() {
    var totalCats = this.dataModel.getData().size();
    var rejectedCats = this.dataModel.getRejectedCount();
    var acceptedCats = this.dataModel.getAcceptedCount();

    this.$el.html(
      template({
        isLocked: this.dataModel.isLocked(),
        canBeLocked: this.dataModel.canBeLocked(),
        totalLocked: this.dataModel.getLockedSize(),
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        isSearchApplied: this.dataModel.isSearchApplied(),
        isAllRejected: this.dataModel.isAllFiltersRejected(),
        totalCats: totalCats,
        rejectedCats: rejectedCats,
        acceptedCats: acceptedCats
      })
    );
    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:data change:filter change:locked change:lockCollection', this.render, this);
    this.viewModel.bind('change:search', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _lockCategories: function() {
    this.dataModel.lockCategories();
  },

  _unlockCategories: function() {
    this.dataModel.unlockCategories();
  },

  _onUnselectAll: function() {
    this.dataModel.rejectAll();
  },

  _onSelectAll: function() {
    this.dataModel.acceptAll();
  }

});

},{"./options_template.tpl":52}],54:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-contentFlex"> <button class="u-rSpace--m CDB-Widget-buttonIcon CDB-Widget-textSmaller CDB-Widget-textSmaller--upper js-searchToggle"> <i class="CDB-Icon CDB-Icon--center CDB-Icon-lens u-rSpace"></i> <span class="u-iBlock"> search </span> </button> </div> ';
 if (showPaginator) { 
__p+=' <div class="CDB-Widget-navDots js-dots"> ';
 for (var i = 0, l = pages; i < l; i++) { 
__p+='<button class="CDB-Shape-dot CDB-Widget-dot--navigation js-page ';
 if (currentPage === i) { 
__p+='is-selected';
 } 
__p+='" data-page="'+
((__t=( i ))==null?'':_.escape(__t))+
'"></button>';
 } 
__p+=' </div> ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],55:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var Model = cdb.core.Model;
var defaultTemplate = require('./paginator_template.tpl');

module.exports = View.extend({

  options: {
    itemsPerPage: 6,
    template: defaultTemplate,
    paginator: false
  },

  className: 'CDB-Widget-nav CDB-Widget-contentSpaced',

  events: {
    'click .js-searchToggle': '_onSearchClicked',
    'click .js-page': '_onDotClick'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this.viewModel = this.options.viewModel;
    this._$target = this.options.$target;
    this.model = new Model({
      page: 0
    });
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var pages = Math.ceil(this.dataModel.getSize() / this.options.itemsPerPage);
    var template = this.options.template;
    this.$el.html(
      template({
        showPaginator: this.options.paginator,
        currentPage: this.model.get('page'),
        pages: pages
      })
    );
    this._scrollToPage();

    return this;
  },

  _initBinds: function() {
    $(window).bind('resize.' + this.cid, _.bind(this._scrollToPage, this));
    this.model.bind('change:page', this.render, this);
    this.dataModel.bind('change:data change:searchData', function() {
      this._setPage();
      this.render();
    }, this);
    this.viewModel.bind('change:search', this.toggle, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  // If current page doesn't exist due to a data change, we should reset it
  _setPage: function() {
    var count = this.dataModel.getSize();
    var pages = Math.ceil(count / this._ITEMS_PER_PAGE);
    if (this.model.get('page') > (pages - 1)) {
      this.model.set({ page: 0 }, { silent :true });
    }
  },

  _onSearchClicked: function() {
    this.dataModel.setupSearch();
    this.viewModel.toggleSearch();
  },

  _scrollToPage: function() {
    var page = this.model.get('page');
    var pageWidth = this._$target.find('.CDB-Widget-listGroup:eq(0)').outerWidth();
    this._$target.css('margin-left', - (page * pageWidth));
  },

  _onDotClick: function(ev) {
    var page = $(ev.target).data('page');
    this.model.set('page', page);
  },

  toggle: function() {
    this[ this.viewModel.isSearchEnabled() ? 'hide' : 'show' ]();
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  clean: function() {
    $(window).unbind('resize.' + this.cid);
    View.prototype.clean.call(this);
  }

});

},{"./paginator_template.tpl":54}],56:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-contentFlex"> <button class="u-rSpace--m CDB-Widget-link js-searchToggle">cancel</button> </div> ';
 if (showPaginator) { 
__p+=' <div class="CDB-Widget-navDots js-dots"> ';
 for (var i = 0, l = pages; i < l; i++) { 
__p+='<button class="CDB-Shape-dot CDB-Widget-dot--navigation js-page ';
 if (currentPage === i) { 
__p+='is-selected';
 } 
__p+='" data-page="'+
((__t=( i ))==null?'':_.escape(__t))+
'"></button>';
 } 
__p+=' </div> ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],57:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var Model = cdb.core.Model;
var PaginatorView = require('./paginator_view');
var searchTemplate = require('./search_paginator_template.tpl');

module.exports = PaginatorView.extend({

  className: 'CDB-Widget-nav is-hidden CDB-Widget-contentSpaced',

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var pages = Math.ceil(this.dataModel.getSearchCount() / this.options.itemsPerPage);
    this.$el.html(
      searchTemplate({
        showPaginator: true,
        currentPage: this.model.get('page'),
        pages: pages
      })
    );
    this._scrollToPage();

    return this;
  },

  _setPage: function() {
    var count = this.dataModel.getSearchCount();
    var pages = Math.ceil(count / this._ITEMS_PER_PAGE);
    if (this.model.get('page') > (pages - 1)) {
      this.model.set({ page: 0 }, { silent :true });
    }
  },

  toggle: function() {
    this[ !this.viewModel.isSearchEnabled() ? 'hide' : 'show' ]();
  },

  _onSearchClicked: function() {
    this.dataModel.cleanSearch();
    this.viewModel.toggleSearch();
  }

});

},{"./paginator_view":55,"./search_paginator_template.tpl":56}],58:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( value ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],59:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) { 
__p+=' <dt class="CDB-Widget-infoItem"> ';
 if (isSearchApplied) { 
__p+=' '+
((__t=( resultsCount ))==null?'':_.escape(__t))+
' found ';
 } else { 
__p+=' &nbsp; ';
 } 
__p+=' </dt> ';
 } else { 
__p+=' <dt class="CDB-Widget-infoItem">'+
((__t=( nullsPer ))==null?'':_.escape(__t))+
'% null rows</dt> <dt class="CDB-Widget-infoItem"><span class="js-cats">'+
((__t=( catsPer ))==null?'':_.escape(__t))+
'</span>% in '+
((__t=( totalCats ))==null?'':_.escape(__t))+
' categor'+
((__t=( totalCats !== 1 ? 'ies' : 'y' ))==null?'':_.escape(__t))+
'</dt> ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],60:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var d3 = cdb.d3;
var formatter = cdb.core.format;
var template = require('./stats_template.tpl');
var animationTemplate = require('./cats_template.tpl');
var AnimateValues = require('../../animate_values');

/**
 * Category stats info view
 *
 */

module.exports = View.extend({

  className: 'CDB-Widget-info CDB-Widget-textSmaller CDB-Widget-textSmaller--upper',
  tagName: 'dl',

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.$el.html(
      template({
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        isSearchApplied: this.dataModel.isSearchApplied(),
        resultsCount: this.dataModel.getSearchCount(),
        totalCats: this._getCategoriesSize(),
        nullsPer: this._getNullPercentage(),
        catsPer: this._getCurrentCategoriesPercentage()
      })
    );

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateFromValues(this._getPreviousCategoriesPercentage(), this._getCurrentCategoriesPercentage(), '.js-cats',
      animationTemplate, { defaultValue: '-', animationSpeed: 700, formatter: formatter.formatValue }
    );

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:data change:locked change:search change:totalCount', this.render, this);
    this.viewModel.bind('change:search', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _getNullPercentage: function() {
    var nulls = this.dataModel.get('nulls');
    var total = this.dataModel.get('totalCount') || 0;
    return !nulls ? 0 : ((nulls/total) * 100).toFixed(2);
  },

  _getPreviousCategoriesPercentage: function() {
    var total = this.dataModel.previous('totalCount') || 0;
    var data = this.dataModel.getPreviousData();
    return this._getCategoriesPercentage(data, total);
  },

  _getCurrentCategoriesPercentage: function() {
    var total = this.dataModel.get('totalCount') || 0;
    var data = this.dataModel.getData().toJSON();
    return this._getCategoriesPercentage(data, total);
  },

  _getCategoriesPercentage: function(data, total) {
    if (!total) {
      return 0;
    }

    var currentTotal = data.reduce(function(memo, mdl) {
      return !mdl.agg ? ( memo + parseFloat(mdl.value)) : memo;
    }, 0);

    if (!currentTotal) {
      return 0;
    }

    return ((currentTotal / total) * 100).toFixed(2);
  },

  _getCategoriesSize: function() {
    return _.pluck(
      this.dataModel.getData().reject(function(mdl) {
        return mdl.get('agg');
      }), 'name').length;
  }
});

},{"../../animate_values":33,"./cats_template.tpl":58,"./stats_template.tpl":59}],61:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) { 
__p+=' <form class="CDB-Widget-search js-form"> <i class="CDB-Icon CDB-Icon-lens CDB-Widget-searchLens"></i> <input type="text" class="CDB-Widget-textInput CDB-Widget-searchTextInput js-textInput" value="'+
((__t=( q ))==null?'':_.escape(__t))+
'" placeholder="Search by '+
((__t=( columnName ))==null?'':_.escape(__t))+
'"> ';
 if (canShowApply) { 
__p+=' <button type="button" class="CDB-Widget-link CDB-Widget-searchApply js-applyLocked">apply</button> ';
 } 
__p+=' </form> ';
 } else { 
__p+=' <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-options CDB-Widget-contentSpaced"> <button class="CDB-Widget-buttonIcon CDB-Widget-buttonIcon--circle js-colors '+
((__t=( isColorApplied ? 'is-selected' : '' ))==null?'':_.escape(__t))+
' '+
((__t=( isColorApplied ? 'js-cancelColors' : 'js-applyColors' ))==null?'':_.escape(__t))+
'" data-tooltip="\n          '+
((__t=( isColorApplied ? 'Remove colors' : 'Apply colors' ))==null?'':_.escape(__t))+
'\n        "> <i class="CDB-Icon CDB-Icon-syringe CDB-Icon--top"></i> </button> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div> </div> ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],62:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var View = cdb.core.View;
var TooltipView = require('../../widget-tooltip-view');
var template = require('./search_title_template.tpl');

/**
 *  Show category title or search any category
 *  + another options for this widget, as in,
 *  colorize categories, lock defined categories...
 *
 */

module.exports = View.extend({

  events: {
    'keyup .js-textInput': '_onKeyupInput',
    'submit .js-form': '_onSubmitForm',
    'click .js-applyLocked': '_applyLocked',
    'click .js-applyColors': '_applyColors',
    'click .js-cancelColors': '_cancelColors',
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(
      template({
        isCollapsed: this.dataModel.isCollapsed(),
        isColorApplied: this.dataModel.isColorApplied(),
        title: this.dataModel.get('title'),
        columnName: this.dataModel.get('column'),
        q: this.dataModel.getSearchQuery(),
        isLocked: this.dataModel.isLocked(),
        canBeLocked: this.dataModel.canBeLocked(),
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        canShowApply: this.dataModel.canApplyLocked()
      })
    );
    this._initViews();
    return this;
  },

  _initBinds: function() {
    this.viewModel.bind('change:search', this._onSearchToggled, this);
    this.dataModel.bind('change:filter change:lockCollection change:categoryColors change:collapsed', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _initViews: function() {
    var collapseTooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(collapseTooltip.render().el);
    this.addView(collapseTooltip);

    var colorsTooltip = new TooltipView({
      target: this.$('.js-colors')
    });
    $('body').append(colorsTooltip.render().el);
    this.addView(colorsTooltip);
  },

  _onSearchToggled: function() {
    var isSearchEnabled = this.viewModel.isSearchEnabled();
    this[isSearchEnabled ? '_bindESC' : '_unbindESC']();
    this.render();
    if (isSearchEnabled) {
      this._focusOnInput();
    }
  },

  _onSubmitForm: function(ev) {
    if (ev) {
      ev.preventDefault();
    }
    var q = this.$('.js-textInput').val();
    if (this.dataModel.getSearchQuery() !== q) {
      this.dataModel.setSearchQuery(q);
      if (this.dataModel.isSearchValid()) {
        this.dataModel.applySearch();
      }
    }
  },

  _focusOnInput: function() {
    var self = this;
    setTimeout(function() {
      self.$('.js-textInput').focus();
    }, 0);
  },

  _onKeyupInput: _.debounce(
    function(ev) {
      var q = this.$('.js-textInput').val();
      if (ev.keyCode !== 13 && ev.keyCode !== 27 && q !== "") {
        this._onSubmitForm();
      }
    }, 250
  ),

  _bindESC: function() {
    $(document).bind("keyup." + this.cid, _.bind(this._onKeyUp, this));
  },

  _unbindESC: function() {
    $(document).unbind("keyup." + this.cid);
  },

  _onKeyUp: function(ev) {
    if (ev.keyCode === 27) {
      this._cancelSearch();
      return false;
    }
  },

  _applyLocked: function() {
    this.viewModel.toggleSearch();
    this.dataModel.applyLocked();
  },

  _applyColors: function() {
    this.dataModel.applyCategoryColors();
  },

  _cancelColors: function() {
    this.dataModel.cancelCategoryColors();
  },

  _cancelSearch: function() {
    this.dataModel.cleanSearch();
    this.viewModel.disableSearch();
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  },

  clean: function() {
    this._unbindESC();
    View.prototype.clean.call(this);
  }

});

},{"../../widget-tooltip-view":102,"./search_title_template.tpl":61}],63:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],64:[function(require,module,exports){
var _ = cdb._;
var formatter = cdb.core.format;
var d3 = cdb.d3;
var $ = cdb.$;
var WidgetContent = require('../standard/widget_content_view');
var WidgetViewModel = require('../widget_content_model');
var template = require('./template.tpl');
var TooltipView = require('../widget-tooltip-view');
var animationTemplate = require('./animation_template.tpl');
var AnimateValues = require('../animate_values.js');

/**
 * Default widget content view:
 */
module.exports = WidgetContent.extend({

  events: {
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.dataModel = this.model;
    this.viewModel = new WidgetViewModel();
    WidgetContent.prototype.initialize.call(this);
  },

  render: function() {
    this.clearSubViews();
    var value = this.dataModel.get('data');

    var format = function(value) {
      var formatter = d3.format('0,000');

      if (_.isNumber(value)) {
        return formatter(value.toFixed(2));
      }
      return 0;
    };

    var nulls = !_.isUndefined(this.dataModel.get('nulls')) && formatter.formatNumber(this.dataModel.get('nulls')) || '-';
    var isCollapsed = this.dataModel.isCollapsed();

    var prefix = this.dataModel.get('prefix');
    var suffix = this.dataModel.get('suffix');

    this.$el.html(
      template({
        title: this.dataModel.get('title'),
        operation: this.dataModel.get('operation'),
        value: value,
        nulls: nulls,
        prefix: prefix,
        suffix: suffix,
        isCollapsed: isCollapsed
      })
    );

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateValue(this.dataModel, 'data', '.js-value', animationTemplate, { animationSpeed: 700, formatter: format, templateData: { prefix: prefix, suffix: suffix }});

    this.$el.toggleClass('is-collapsed', !!isCollapsed);

    this._initViews();

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:collapsed', this.render, this);
    WidgetContent.prototype._initBinds.call(this);
  },

  _initViews: function() {
    var tooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(tooltip.render().el);
    this.addView(tooltip);
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  }

});

},{"../animate_values.js":33,"../standard/widget_content_view":85,"../widget-tooltip-view":102,"../widget_content_model":105,"./animation_template.tpl":63,"./template.tpl":66}],65:[function(require,module,exports){
var _ = cdb._;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  defaults: _.extend(
    {},
    WidgetModel.prototype.defaults,
    {
      data: '',
      suffix: '',
      prefix: ''
    }
  ),

  // TODO: The response format has probably changed
  parse: function(r) {
    return {
      data: r.result,
      nulls: r.nulls
    };
  },

  toJSON: function(d) {
    return {
      type: "formula",
      options: {
        column: this.get('column'),
        operation: this.get('operation')
      }
    };
  }

});

},{"../widget_model":106}],66:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <div class="CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-tag CDB-Widget-tag--'+
((__t=( operation ))==null?'':_.escape(__t))+
'"> <span class="CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( operation ))==null?'':_.escape(__t))+
'</span> </div> </div> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( nulls ))==null?'':_.escape(__t))+
' null rows</dt> </dl> </div> <div class="CDB-Widget-content"> ';
 if (value) { 
__p+=' <h4 class="CDB-Widget-textBigger CDB-Widget-textBigger--maxWidth js-value" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'"> '+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
' </h4> ';
 } else { 
__p+=' <div class="CDB-Widget-listItem--fake"></div> ';
 } 
__p+=' </div>';
}
return __p;
};

},{"underscore":24}],67:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],68:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var d3 = cdb.d3;
var formatter = cdb.core.format;
var Model = cdb.core.Model;
var View = cdb.core.View;

module.exports = View.extend({

  defaults: {
     // render the chart once the width is set as default, provide false value for this prop to disable this behavior
     // e.g. for "mini" histogram behavior
    showOnWidthChange: true,

    labelsMargin: 16, // px
    hasAxisTip: false,
    minimumBarHeight: 2,
    animationSpeed: 750,
    handleWidth: 6,
    handleHeight: 23,
    handleRadius: 3,
    divisionWidth: 80,
    animationBarDelay: function(d, i) {
      return Math.random() * (100 + (i * 10));
    },
    transitionType: 'elastic'
  },

  initialize: function() {
    if (!_.isNumber(this.options.height)) throw new Error('height is required');

    this.options = _.extend({}, this.defaults, this.options);

    _.bindAll(this, '_selectBars', '_adjustBrushHandles', '_onBrushMove', '_onBrushStart', '_onMouseMove', '_onMouseOut');

    // Use this special setup for each view instance ot have its own debounced listener
    // TODO in theory there's the possiblity that the callback is called before the view is rendered in the DOM,
    //  which would lead to the view not being visible until an explicit window resize.
    //  a wasAddedToDOM event would've been nice to have
    this._onWindowResize = _.debounce(this._resizeToParentElement.bind(this), 50);
    $(window).bind('resize', this._onWindowResize);

    // using tagName: 'svg' doesn't work,
    // and w/o class="" d3 won't instantiate properly
    this.setElement($('<svg class=""></svg>')[0]);

    this.canvas = d3.select(this.el)
    .attr('width', 0)
    .attr('height', this.options.height);

    this.canvas
    .append('g')
    .attr('class', 'CDB-WidgetCanvas');

    this._setupModel();
    this._setupBindings();
    this._setupDimensions();
    this._setupD3Bindings();

    this.hide(); // will be toggled on width change
  },

  render: function() {
    this._generateChart();
    this._generateChartContent();
    return this;
  },

  clean: function() {
    $(window).unbind('resize', this._onWindowResize);
    View.prototype.clean.call(this);
  },

  replaceData: function(data) {
    this.model.set({ data: data });
  },

  toggleLabels: function(show) {
    this.model.set('showLabels', show);
  },

  chartWidth: function() {
    var m = this.model.get('margin');

    // Get max because width might be negative initially
    return Math.max(0, this.model.get('width') - m.left - m.right);
  },

  chartHeight: function() {
    var m = this.model.get('margin');
    var labelsMargin = this.model.get('showLabels')
      ? this.defaults.labelsMargin
      : 0;
    return this.model.get('height') - m.top - m.bottom - labelsMargin;
  },

  _resizeToParentElement: function() {

    if (this.$el.parent()) {
      // Hide this view temporarily to get actual size of the parent container
      var wasHidden = this.isHidden();

      this.hide();

      var width = this.$el.parent().width() || 0;

      if (wasHidden) {
        this.hide();
      } else {
        this.show();
      }

      this.model.set('width', width);
    }
  },

  _onChangeLeftAxisTip: function() {
    this._updateAxisTip('left');
  },

  _onChangeRightAxisTip: function() {
    this._updateAxisTip('right');
  },

  _updateAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip  = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);
    var handle    = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);

    textLabel.data([this.model.get(className + '_axis_tip')]).text(function(d) {
      return formatter.formatNumber(d);
    });

    var width = textLabel.node().getBBox().width;
    rectLabel.attr('width', width + 4);

    var parts = /translate\(\s*([^\s,)]+), ([^\s,)]+)/.exec(handle.attr('transform'));
    var xPos = +parts[1] + 3;

    if ((xPos - width/2) < 0) {
      axisTip.attr('transform', 'translate(0, 52)');
      textLabel.attr('dx', -xPos);
      rectLabel.attr('x',  -xPos);
    } else if ((xPos + width/2 + 2) >= this.chartWidth()) {
      axisTip.attr('transform', 'translate(0, 52)');
      textLabel.attr('dx', this.chartWidth() - (xPos + width - 2));
      rectLabel.attr('x', this.chartWidth() - (xPos + width));
    } else {
      axisTip.attr('transform', 'translate(-' + (width/2) + ', 52)');
      rectLabel.attr('x', 0);
      textLabel.attr('dx', +2);
    }
  },

  _onChangeData: function() {
    if (this.model.previous('data').length != this.model.get('data').length) {
      this.reset();
    } else {
      this.refresh();
    }
  },

  _onChangeRange: function() {
    if (this.model.get('lo_index') === 0 && this.model.get('hi_index') === 0) {
      return;
    }
    this.trigger('range_updated', this.model.get('lo_index'), this.model.get('hi_index'));
  },

  _onChangeWidth: function() {
    var width = this.model.get('width');
    this.$el.width(width);
    this.chart.attr('width', width);
    if (this.options.showOnWidthChange && width > 0) {
      this.show();
    }
    this.reset();

    var loBarIndex = this.model.get('lo_index');
    var hiBarIndex = this.model.get('hi_index');
    this.selectRange(loBarIndex, hiBarIndex);
  },

  _onChangeHeight: function() {
    var height = this.model.get('height');

    this.$el.height(height);
    this.chart.attr('height', height);
    this.leftHandle.attr('height', height);
    this.rightHandle.attr('height', height);

    this.reset();
  },

  _onChangShowLabels: function() {
    this._axis.style('opacity', this.model.get('showLabels') ? 1 : 0);
  },

  _onChangePos: function() {
    var pos = this.model.get('pos');
    var margin = this.model.get('margin');

    var x = +pos.x;
    var y = +pos.y;

    this.chart
    .transition()
    .duration(150)
    .attr('transform', 'translate(' + (margin.left + x) + ', ' + (margin.top + y) + ')');
  },

  _onBrushStart: function() {
    var extent = this.brush.extent();
    var hiExtent = extent[1];
    var rightX = this.xScale(hiExtent) - this.options.handleWidth / 2;

    this.chart.classed('is-selectable', true);
  },

  _onChangeDragging: function() {
    this.chart.classed('is-dragging', this.model.get('dragging'));
    this._updateAxisTipOpacity('right');
    this._updateAxisTipOpacity('left');
  },

  _showAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip   = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);

    if (textLabel) {
      textLabel.transition().duration(200).attr('opacity',  1);
    }
    if (rectLabel) {
      rectLabel.transition().duration(200).attr('opacity',  1);
    }
  },

  _hideAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip   = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);

    if (textLabel) {
      textLabel.transition().duration(200).attr('opacity',  0);
    }
    if (rectLabel) {
      rectLabel.transition().duration(200).attr('opacity',  0);
    }
  },

  _updateAxisTipOpacity: function(className) {
    if (this.model.get('dragging')) {
      this._showAxisTip(className);
    } else {
      this._hideAxisTip(className);
    }
  },

  _onBrushMove: function() {
    this.model.set({ dragging: true });
    this._selectBars();
    this._adjustBrushHandles();
  },

  _onMouseOut: function() {
    var bars = this.chart.selectAll('.CDB-Chart-bar');
    bars.classed('is-highlighted', false);
    this.trigger('hover', { value: null });
  },

  _onMouseMove: function() {
    var x = d3.event.offsetX;
    var y = d3.event.offsetY;

    var barIndex = Math.floor(x / this.barWidth);
    var data = this.model.get('data');

    if (data[barIndex] === undefined || data[barIndex] === null) {
      return;
    }

    var freq = data[barIndex].freq;
    var hoverProperties = {};

    var bar = this.chart.select('.CDB-Chart-bar:nth-child(' + (barIndex + 1) + ')');

    if (bar && bar.node() && !bar.classed('is-selected')) {

      var left = (barIndex * this.barWidth) + (this.barWidth/2);

      var top = this.yScale(freq);

      var h = this.chartHeight() - this.yScale(freq);

      if (h < this.options.minimumBarHeight && h > 0) {
        top = this.chartHeight() - this.options.minimumBarHeight;
      }

      if (!this._isDragging() && freq > 0) {
        var d = formatter.formatNumber(freq);
        hoverProperties = { top: top, left: left, data: d };
      } else {
        hoverProperties = null;
      }

    } else {
      hoverProperties = null;
    }

    this.trigger('hover', hoverProperties);

    this.chart.selectAll('.CDB-Chart-bar')
    .classed('is-highlighted', false);

    if (bar && bar.node()) {
      bar.classed('is-highlighted', true);
    }
  },

  reset: function() {
    this._removeChartContent();
    this._setupDimensions();
    this._calcBarWidth();
    this._generateChartContent();
    this._removeShadowBars();
    this._generateShadowBars();
  },

  refresh: function() {
    this._setupDimensions();
    this._removeAxis();
    this._generateAxis();
    this._updateChart();

    this._generateShadowBars();
    this.chart.select('.CDB-Chart-handles').moveToFront();
    this.chart.select('.Brush').moveToFront();
  },

  resetIndexes: function() {
    this.model.set({ lo_index: null, hi_index: null });
  },

  removeShadowBars: function() {
    this.model.set('show_shadow_bars', false);
  },

  _removeShadowBars: function() {
    this.chart.selectAll('.CDB-Chart-shadowBars').remove();
  },

  _removeBars: function() {
    this.chart.selectAll('.CDB-Chart-bars').remove();
  },

  _removeBrush: function() {
    this.chart.selectAll('.Brush').remove();
    this.chart.classed('is-selectable', false);
  },

  _removeLines: function() {
    this.chart.select('.CDB-Chart-lines').remove();
  },

  _removeChartContent: function() {
    this._removeBrush();
    this._removeHandles();
    this._removeBars();
    this._removeAxis();
    this._removeLines();
  },

  _generateChartContent: function() {
    this._generateAxis();
    this._generateLines();

    this._generateBars();
    this._generateHandles();
    this._setupBrush();
  },

  _generateLines: function() {
    this._generateHorizontalLines();

    if (this.options.type !== 'time') {
      this._generateVerticalLines();
    }
  },

  _generateVerticalLines: function() {
    var lines = this.chart.select('.CDB-Chart-lines');

    lines.append('g')
    .selectAll('.CDB-Chart-line')
    .data(this.verticalRange.slice(1, this.verticalRange.length - 1))
    .enter().append('svg:line')
    .attr('class', 'CDB-Chart-line')
    .attr('y1', 0)
    .attr('x1', function(d) { return d; })
    .attr('y2', this.chartHeight())
    .attr('x2', function(d) { return d; });
  },

  _generateHorizontalLines: function() {
    var lines = this.chart.append('g')
    .attr('class', 'CDB-Chart-lines');

    lines.append('g')
    .attr('class', 'y')
    .selectAll('.CDB-Chart-line')
    .data(this.horizontalRange)
    .enter().append('svg:line')
    .attr('class', 'CDB-Chart-line')
    .attr('x1', 0)
    .attr('y1', function(d) { return d; })
    .attr('x2', this.chartWidth())
    .attr('y2', function(d) { return d; });

    this.bottomLine = lines
    .append('line')
    .attr('class', 'CDB-Chart-line CDB-Chart-line--bottom')
    .attr('x1', 0)
    .attr('y1', this.chartHeight())
    .attr('x2', this.chartWidth() - 1)
    .attr('y2', this.chartHeight());
  },

   _setupD3Bindings: function() { // TODO: move to a helper

    d3.selection.prototype.moveToBack = function() {
      return this.each(function() {
        var firstChild = this.parentNode.firstChild;
        if (firstChild) {
          this.parentNode.insertBefore(this, firstChild);
        }
      });
    };

    d3.selection.prototype.moveToFront = function() {
      return this.each(function(){
        this.parentNode.appendChild(this);
      });
    };
  },

  _setupModel: function() {
    this.model = new Model({
      showLabels: true,
      data: this.options.data,
      height: this.options.height,
      display: true,
      show_shadow_bars: this.options.shadowData,
      margin: _.clone(this.options.margin),
      width: 0, // will be set on resize listener
      pos: { x: 0, y: 0 }
    });
  },

  _setupBindings: function() {
    this.model.bind('change:data', this._onChangeData, this);
    this.model.bind('change:display', this._onChangeDisplay, this);
    this.model.bind('change:dragging', this._onChangeDragging, this);
    this.model.bind('change:height', this._onChangeHeight, this);
    this.model.bind('change:left_axis_tip', this._onChangeLeftAxisTip, this);
    this.model.bind('change:lo_index change:hi_index', this._onChangeRange, this);
    this.model.bind('change:pos', this._onChangePos, this);
    this.model.bind('change:right_axis_tip', this._onChangeRightAxisTip, this);
    this.model.bind('change:showLabels', this._onChangShowLabels, this);
    this.model.bind('change:show_shadow_bars', this._onChangeShowShadowBars, this);
    this.model.bind('change:width', this._onChangeWidth, this);
  },

  _setupDimensions: function() {
    this._setupScales();
    this._setupRanges();
    this._onWindowResize();
  },

  _setupScales: function() {
    var data = this.model.get('data');

    this.xScale = d3.scale.linear().domain([0, 100]).range([0, this.chartWidth()]);
    this.yScale = d3.scale.linear().domain([0, d3.max(data, function(d) { return _.isEmpty(d) ? 0 : d.freq; } )]).range([this.chartHeight(), 0]);

    if (!data || !data.length) {
      return;
    }

    if (this.options.type === 'time') {
      this.xAxisScale = d3.time.scale().domain([data[0].start * 1000, data[data.length - 1].end * 1000]).nice().range([0, this.chartWidth()]);
    } else {
      this.xAxisScale = d3.scale.linear().range([data[0].start, data[data.length - 1].end]).domain([0, this.chartWidth()]);
    }
  },

  _setupRanges: function() {
    var n = Math.round(this.chartWidth() / this.options.divisionWidth);
    this.verticalRange = d3.range(0, this.chartWidth() + this.chartWidth() / n, this.chartWidth() / n);
    this.horizontalRange = d3.range(0, this.chartHeight() + this.chartHeight() / 2, this.chartHeight() / 2);
  },

  _calcBarWidth: function() {
    this.barWidth = this.chartWidth() / this.model.get('data').length;
  },

  _generateChart: function() {
    var margin = this.model.get('margin');

    this.chart = d3.select(this.el)
    .selectAll('.CDB-WidgetCanvas')
    .append('g')
    .attr('class', 'CDB-Chart')
    .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');

    this.chart.classed(this.options.className || '', true);
  },

  _onChangeShowShadowBars: function() {
    if (this.model.get('show_shadow_bars')) {
      this._generateShadowBars();
    } else {
      this._removeShadowBars();
    }
  },

  _onChangeDisplay: function() {
    if (this.model.get('display')) {
      this._show();
    } else {
      this._hide();
    }
  },

  hide: function() {
    this.model.set('display', false);
  },

  show: function() {
    this.model.set('display', true);
  },

  _hide: function() {
    this.$el.hide();
  },

  _show: function() {
    this.$el.show();
  },

  isHidden: function() {
    return !this.model.get('display');
  },

  _selectBars: function() {
    var self = this;
    var extent = this.brush.extent();
    var lo = extent[0];
    var hi = extent[1];


    this.model.set({ lo_index: this._getLoBarIndex(), hi_index: this._getHiBarIndex() });

    this.chart.selectAll('.CDB-Chart-bar').classed('is-selected', function(d, i) {
      var a = Math.floor(i * self.barWidth);
      var b = Math.floor(a + self.barWidth);
      var LO = Math.floor(self.xScale(lo));
      var HI = Math.floor(self.xScale(hi));
      var isIn = (a > LO && a < HI) || (b > LO && b < HI) || (a <= LO && b >= HI);
      return !isIn;
    });
  },

  _isDragging: function() {
    return this.model.get('dragging');
  },

  _move: function(pos) {
    this.model.set({ pos: pos });
  },

  expand: function(height) {
    this.canvas.attr('height', this.model.get('height') + height);
    this._move({ x: 0, y: height });
  },

  contract: function(height) {
    this.canvas.attr('height', height);
    this._move({ x: 0, y: 0 });
  },

  resizeHeight: function(height) {
    this.model.set('height', height);
  },

  removeSelection: function() {
    this.resetIndexes();
    this.chart.selectAll('.CDB-Chart-bar').classed('is-selected', false);
    this._removeBrush();
    this._setupBrush();
  },

  selectRange: function(loBarIndex, hiBarIndex) {
    if (!loBarIndex && !hiBarIndex) {
      return;
    }

    var loPosition = this._getBarPosition(loBarIndex);
    var hiPosition = this._getBarPosition(hiBarIndex);

    this._selectRange(loPosition, hiPosition);
  },

  _selectRange: function(loPosition, hiPosition) {
    this.chart.select('.Brush').transition()
    .duration(this.brush.empty() ? 0 : 150)
    .call(this.brush.extent([loPosition, hiPosition]))
    .call(this.brush.event);
  },

  _getLoBarIndex: function() {
    var extent = this.brush.extent();
    return Math.round(this.xScale(extent[0]) / this.barWidth);
  },

  _getHiBarIndex: function() {
    var extent = this.brush.extent();
    return Math.round(this.xScale(extent[1]) / this.barWidth);
  },

  _getBarIndex: function() {
    var x = d3.event.sourceEvent.offsetX;
    return Math.floor(x / this.barWidth);
  },

  _getBarPosition: function(index) {
    var data = this.model.get('data');
    return index * (100 / data.length);
  },

  _setupBrush: function() {
    var self = this;

    var xScale = this.xScale;
    var brush = this.brush = d3.svg.brush().x(this.xScale);

    function onBrushEnd() {
      var data = self.model.get('data');
      var loPosition, hiPosition;

      self.model.set({ dragging: false });

      if (brush.empty()) {
        self.chart.selectAll('.CDB-Chart-bar').classed('is-selected', false);
        d3.select(this).call(brush.extent([0, 0]));
      } else {

        var loBarIndex = self._getLoBarIndex();
        var hiBarIndex = self._getHiBarIndex();

        loPosition = self._getBarPosition(loBarIndex);
        hiPosition = self._getBarPosition(hiBarIndex);

        if (!d3.event.sourceEvent) {
          return;
        }

        if (loBarIndex === hiBarIndex) {
          if (hiBarIndex >= data.length) {
            loPosition = self._getBarPosition(loBarIndex - 1);
          } else {
            hiPosition = self._getBarPosition(hiBarIndex + 1);
          }
        }

        self._selectRange(loPosition, hiPosition);
        self.model.set({ lo_index: loBarIndex, hi_index: hiBarIndex });
        self._adjustBrushHandles();
        self._selectBars();

        self.trigger('on_brush_end', self.model.get('lo_index'), self.model.get('hi_index'));
      }

      if (d3.event.sourceEvent && loPosition === undefined && hiPosition === undefined) {
        var barIndex = self._getBarIndex();

        loPosition = self._getBarPosition(barIndex);
        hiPosition = self._getBarPosition(barIndex + 1);

        self.model.set({ lo_index: barIndex, hi_index: barIndex + 1 });
        self._selectRange(loPosition, hiPosition);
        self.trigger('on_brush_end', self.model.get('lo_index'), self.model.get('hi_index'));
      }
    }

    var data = this.model.get('data');

    this.brush
    .on('brushstart', this._onBrushStart)
    .on('brush', this._onBrushMove)
    .on('brushend', onBrushEnd);

    this.chart.append('g')
    .attr('class', 'Brush')
    .call(this.brush)
    .selectAll('rect')
    .attr('y', 0)
    .attr('height', this.chartHeight())
    .on('mouseout', this._onMouseOut)
    .on('mousemove', this._onMouseMove);
  },

  _adjustBrushHandles: function() {
    var extent = this.brush.extent();

    var loExtent = extent[0];
    var hiExtent = extent[1];

    var leftX  = this.xScale(loExtent) - this.options.handleWidth / 2;
    var rightX = this.xScale(hiExtent) - this.options.handleWidth / 2;

    this.chart.select('.CDB-Chart-handle-left')
    .attr('transform', 'translate(' + leftX + ', 0)');

    this.chart.select('.CDB-Chart-handle-right')
    .attr('transform', 'translate(' + rightX + ', 0)');

    if (this.options.hasAxisTip) {
      this.model.set({
        left_axis_tip: this.xAxisScale(leftX + 3),
        right_axis_tip: this.xAxisScale(rightX + 3)
      });
    }
  },

  _generateAxisTip: function(className) {

    var handle = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);

    var axisTip = handle.selectAll("g")
    .data([''])
    .enter().append("g")
    .attr('class', 'CDB-Chart-axisTip CDB-Chart-axisTip-' + className)
    .attr("transform", function(d, i) { return "translate(0,52)"; });

    this.rectLabel = axisTip.append("rect")
    .attr('class', 'CDB-Chart-axisTipRect CDB-Chart-axisTip-' + className)
    .attr("height", 12)
    .attr("width", 10);

    this.textLabel = axisTip.append("text")
    .attr('class', 'CDB-Chart-axisTipText CDB-Chart-axisTip-' + className)
    .attr("dy", "11")
    .attr("dx", "0")
    .text(function(d) { return d; });
  },

  _generateHandle: function(className) {
    var opts = { width: this.options.handleWidth, height: this.options.handleHeight, radius: this.options.handleRadius };
    var yPos = (this.chartHeight() / 2) - (this.options.handleHeight / 2);

    var handle = this.chart.select('.CDB-Chart-handles')
    .append('g')
    .attr('class', 'CDB-Chart-handle CDB-Chart-handle-' + className);

    if (this.options.hasAxisTip) {
      this._generateAxisTip(className);
    }

    handle
    .append('line')
    .attr('class', 'CDB-Chart-handleLine')
    .attr('x1', 3)
    .attr('y1', -4)
    .attr('x2', 3)
    .attr('y2', this.chartHeight() + 4);

    if (this.options.hasHandles) {
      handle
      .append('rect')
      .attr('class', 'CDB-Chart-handleRect')
      .attr('transform', 'translate(0, ' + yPos + ')')
      .attr('width', opts.width)
      .attr('height', opts.height)
      .attr('rx', opts.radius)
      .attr('ry', opts.radius);

      var y = 21; // initial position of the first grip

      for (var i = 0; i < 3; i++) {
        handle
        .append('line')
        .attr('class', 'CDB-Chart-handleGrip')
        .attr('x1', 2)
        .attr('y1', y + i*3)
        .attr('x2', 4)
        .attr('y2', y + i*3);
      }
    }

    return handle;
  },

  _generateHandles: function() {
    this.chart.append('g').attr('class', 'CDB-Chart-handles');
    this.leftHandle  = this._generateHandle('left');
    this.rightHandle = this._generateHandle('right');
  },

  _generateHandleLine: function() {
    return this.chart.select('.CDB-Chart-handles').append('line')
    .attr('class', 'CDB-Chart-handleLine')
    .attr('x1', 0)
    .attr('y1', 0)
    .attr('x2', 0)
    .attr('y2', this.chartHeight());
  },

  _removeHandles: function() {
    this.chart.select('.CDB-Chart-handles').remove();
  },

  _removeAxis: function() {
    this.canvas.select('.CDB-Chart-axis').remove();
  },

  _generateAdjustAnchorMethod: function(ticks) {

    return function(d, i) {
      if (i === 0) {
        return 'start';
      } else if (i === (ticks.length - 1)) {
        return 'end';
      } else {
        return 'middle';
      }
    };
  },

  _generateAxis: function() {
    this._axis = this.options.type === 'time'
      ? this._generateTimeAxis()
      : this._generateNumericAxis();

    this._onChangShowLabels();
  },

  _generateNumericAxis: function() {
    var self = this;
    var adjustTextAnchor = this._generateAdjustAnchorMethod(this.verticalRange);

    var axis = this.chart.append('g')
    .attr('class', 'CDB-Chart-axis');

    axis
    .append('g')
    .selectAll('.Label')
    .data(this.verticalRange)
    .enter().append("text")
    .attr("x", function(d) { return d; })
    .attr("y", function(d) { return self.chartHeight() + 15; })
    .attr("text-anchor", adjustTextAnchor)
    .text(function(d) {
      return formatter.formatNumber(self.xAxisScale(d));
    });

    return axis;
  },

  _generateTimeAxis: function() {
    var adjustTextAnchor = this._generateAdjustAnchorMethod(this.xAxisScale.ticks());

    var xAxis = d3.svg.axis()
    .orient("bottom")
    .tickPadding(5)
    .innerTickSize(-this.chartHeight())
    .scale(this.xAxisScale)
    .orient('bottom');

    var axis = this.canvas.append('g')
    .attr("class", 'CDB-Chart-axis')
    .attr("transform", "translate(0," + (this.chartHeight() + 5) + ")")
    .call(xAxis);

    axis.selectAll('text').style('text-anchor', adjustTextAnchor);
    axis.moveToBack();

    return axis;
  },

  _updateChart: function() {
    var self = this;
    var data = this.model.get('data');

    var bars = this.chart.selectAll('.CDB-Chart-bar')
    .data(data);

    bars
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-bar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * self.barWidth) + ', 0 )';
    })
    .attr('y', self.chartHeight())
    .attr('height', 0)
    .attr('width', Math.max(0, this.barWidth - 1));

    bars
    .transition()
    .duration(200)
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return self.yScale(d.freq);
      }
    });

    bars
    .exit()
    .transition()
    .duration(200)
    .attr('height', function(d) {
      return 0;
    })
    .attr('y', function(d) {
      return self.chartHeight();
    });
  },

  _generateBars: function() {
    var self = this;
    var data = this.model.get('data');

    this._calcBarWidth();

    var bars = this.chart.append('g')
    .attr('transform', 'translate(0, 0)')
    .attr('class', 'CDB-Chart-bars')
    .selectAll('.CDB-Chart-bar')
    .data(data);

    bars
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-bar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * self.barWidth) + ', 0 )';
    })
    .attr('y', self.chartHeight())
    .attr('height', 0)
    .attr('width', Math.max(0, this.barWidth - 1));

    bars
    .transition()
    .ease(this.options.transitionType)
    .duration(this.options.animationSpeed)
    .delay(this.options.animationBarDelay)
    .transition()
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return self.yScale(d.freq);
      }
    });
  },

  showShadowBars: function() {
    this.model.set('show_shadow_bars', true);
  },

  _generateShadowBars: function() {
    var data = this.options.shadowData;

    if (!data || !data.length || !this.model.get('show_shadow_bars')) {
      this._removeShadowBars();
      return;
    }

    this._removeShadowBars();

    var self = this;

    var yScale = d3.scale.linear().domain([0, d3.max(data, function(d) { return _.isEmpty(d) ? 0 : d.freq; } )]).range([this.chartHeight(), 0]);
    var barWidth = this.chartWidth() / data.length;

    var bars = this.chart.append('g')
    .attr('transform', 'translate(0, 0)')
    .attr('class', 'CDB-Chart-shadowBars')
    .selectAll('.CDB-Chart-shadowBar')
    .data(data)
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-shadowBar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * barWidth) + ', 0 )';
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return yScale(d.freq);
      }
    })
    .attr('width', Math.max(0, barWidth - 1))
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    });

    // We need to explicitly move the lines of the grid behind the shadow bars
    this.chart.selectAll('.CDB-Chart-shadowBars').moveToBack();
    this.chart.selectAll('.CDB-Chart-lines').moveToBack();
  }
});

},{}],69:[function(require,module,exports){
var _ = cdb._;
var formatter = cdb.core.format;
var HistogramTitleView = require('./histogram_title_view');
var WidgetContent = require('../standard/widget_content_view');
var WidgetViewModel = require('../widget_content_model');
var HistogramChartView = require('./chart');
var placeholder = require('./placeholder.tpl');
var template = require('./content.tpl');
var AnimateValues = require('../animate_values.js');
var animationTemplate = require('./animation_template.tpl');

/**
 * Widget content view for a histogram
 */
module.exports = WidgetContent.extend({

  defaults: {
    chartHeight: 48 + 20 + 4
  },

  events: {
    'click .js-clear': '_clear',
    'click .js-zoom': '_zoom'
  },

  initialize: function() {
    this.model = this.options.dataModel;
    this.viewModel = new WidgetViewModel();
    this.lockedByUser = false;
    WidgetContent.prototype.initialize.call(this);
  },

  _initViews: function() {
    var titleView = new HistogramTitleView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-title').html(titleView.render().el);
    this.addView(titleView);

    this._renderMiniChart();
    this._renderMainChart();
  },

  _initBinds: function() {
    this.model.once('change:data', this._onFirstLoad, this);
    this.model.bind('change:collapsed', function(mdl, isCollapsed) {
      this.$el.toggleClass('is-collapsed', !!isCollapsed);
    }, this);
  },

  _onFirstLoad: function() {
    this.render();
    this._storeBounds();

    this.model.bind('change', this._onChangeModel, this);
    this.model._fetch();
  },

  _storeBounds: function() {
    var data = this.model.getData();
    if (data && data.length > 0) {
      this.start = data[0].start;
      this.end = data[data.length - 1].end;
      this.binsCount = data.length;
      this.model.set({ start: this.start, end: this.end, bins: this.binsCount });
    }
  },

  _isZoomed: function() {
    return this.viewModel.get('zoomed');
  },

  _onChangeModel: function() {

    // When the histogram is zoomed, we don't need to rely
    // on the change url to update the histogram
    if (this.model.changed.url && this._isZoomed()) {
      return;
    }

    // if the action was initiated by the user
    // don't replace the stored data
    if (this.lockedByUser) {
      this.lockedByUser = false;
    } else {
      if (this._isZoomed()) {
        this.zoomedData = this.model.getData();
      } else {
        this.histogramChartView.showShadowBars();
        this.originalData = this.model.getData();
      }
        this.histogramChartView.replaceData(this.model.getData());
    }

    if (this.unsettingRange) {
      this._unsetRange();
    } else {
      if (this._isZoomed() && !this.lockZoomedData) {
        this.lockZoomedData = true;
        this.zoomedData = this.model.getData();
      }
    }

    this._updateStats();
  },

  render: function() {
    this.clearSubViews();

    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;

    this.$el.html(
      template({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? data.length : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    } else {
      this.originalData = this.model.getData();
      this._setupBindings();
      this._initViews();
    }

    return this;
  },

  _unsetRange: function() {
    this.unsettingRange = false;
    this.histogramChartView.replaceData(this.originalData);
    this.viewModel.set({ lo_index: null, hi_index: null });

    if (!this._isZoomed()) {
      this.histogramChartView.showShadowBars();
    }
  },

  _addPlaceholder: function() {
    this.$('.js-content').append(placeholder());
  },

  _renderMainChart: function() {
    this.histogramChartView = new HistogramChartView(({
      margin: { top: 4, right: 4, bottom: 4, left: 4 },
      hasShadowBards: true,
      hasHandles: true,
      hasAxisTip: true,
      width: this.canvasWidth,
      height: this.defaults.chartHeight,
      data: this.model.getData(),
      shadowData: this.model.getData()
    }));

    this.$('.js-content').append(this.histogramChartView.el);
    this.addView(this.histogramChartView);

    this.histogramChartView.bind('range_updated', this._onRangeUpdated, this);
    this.histogramChartView.bind('on_brush_end', this._onBrushEnd, this);
    this.histogramChartView.bind('hover', this._onValueHover, this);
    this.histogramChartView.render().show();

    this._updateStats();
  },

  _renderMiniChart: function() {
    this.miniHistogramChartView = new HistogramChartView(({
      className: 'CDB-Chart--mini',
      margin: { top: 0, right: 0, bottom: 4, left: 4 },
      height: 40,
      showOnWidthChange: false,
      data: this.model.getData()
    }));

    this.addView(this.miniHistogramChartView);
    this.$('.js-content').append(this.miniHistogramChartView.el);
    this.miniHistogramChartView.bind('on_brush_end', this._onMiniRangeUpdated, this);
    this.miniHistogramChartView.render();
  },

  _setupBindings: function() {
    this.viewModel.bind('change:zoomed', this._onChangeZoomed, this);
    this.viewModel.bind('change:zoom_enabled', this._onChangeZoomEnabled, this);
    this.viewModel.bind('change:filter_enabled', this._onChangeFilterEnabled, this);
    this.viewModel.bind('change:total', this._onChangeTotal, this);
    this.viewModel.bind('change:nulls', this._onChangeNulls, this);
    this.viewModel.bind('change:max',   this._onChangeMax, this);
    this.viewModel.bind('change:min',   this._onChangeMin, this);
    this.viewModel.bind('change:avg',   this._onChangeAvg, this);
  },

  _clearTooltip: function() {
    this.$(".js-tooltip").stop().hide();
  },

  _onValueHover: function(info) {
    var $tooltip = this.$(".js-tooltip");

    if (info && info.data) {
      var bottom = this.defaults.chartHeight + 3 - info.top;

      $tooltip.css({ bottom: bottom, left: info.left });
      $tooltip.text(info.data);
      $tooltip.css({ left: info.left - $tooltip.width()/2 });
      $tooltip.fadeIn(70);
    } else {
      this._clearTooltip();
    }
  },

  _onMiniRangeUpdated: function(loBarIndex, hiBarIndex) {
    this.lockedByUser = false;
    this.lockZoomedData = false;

    this._clearTooltip();
    this.histogramChartView.removeSelection();

    var data = this.originalData;

    if (loBarIndex >= 0 && loBarIndex < data.length && (hiBarIndex - 1) >= 0 && (hiBarIndex - 1) < data.length) {
      this.filter.setRange(
        data[loBarIndex].start,
        data[hiBarIndex - 1].end
      );
      this._updateStats();
    } else {
      console.error('Error accessing array bounds', loBarIndex, hiBarIndex, data);
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this._getData();
    
    if (!data || !data.length) {
      return;
    }

    if (this._isZoomed()) {
      this.lockedByUser = true;
    }

    var properties = { filter_enabled: true, lo_index: loBarIndex, hi_index: hiBarIndex };

    if (!this.viewModel.get('zoomed')) {
      properties.zoom_enabled = true;
    }

    this.viewModel.set(properties);

    if (loBarIndex >= 0 && loBarIndex < data.length && (hiBarIndex - 1) >= 0 && (hiBarIndex - 1) < data.length) {
      this.filter.setRange(
        data[loBarIndex].start,
        data[hiBarIndex - 1].end
      );
      this._updateStats();
    } else {
      console.error('Error accessing array bounds', loBarIndex, hiBarIndex, data);
    }
  },

  _onRangeUpdated: function(loBarIndex, hiBarIndex) {

    var self = this;
    if (this.viewModel.get('zoomed')) {
      this.viewModel.set({ zoom_enabled: false, lo_index: loBarIndex, hi_index: hiBarIndex });
    } else {
      this.viewModel.set({ lo_index: loBarIndex, hi_index: hiBarIndex });
    }

    var updateStats = _.debounce(function() { self._updateStats(); }, 400);
    updateStats();
  },

  _getData: function() {
    var data = this.model.getData();

    if (this._isZoomed()) {
      data = this.zoomedData;
    }
    return data;
  },

  _onChangeFilterEnabled: function() {
    this.$(".js-filter").toggleClass('is-hidden', !this.viewModel.get('filter_enabled'));
  },

  _onChangeZoomEnabled: function() {
    this.$(".js-zoom").toggleClass('is-hidden', !this.viewModel.get('zoom_enabled'));
  },

  _changeHeaderValue: function(className, what, suffix) {
    if (this.viewModel.get(what) === undefined) {
      this.$(className).text('0 ' + suffix);
      return;
    }

    this._addTitleForValue(className, what, suffix);

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateValue(this.viewModel, what, className, animationTemplate, {
      formatter: formatter.formatNumber,
      templateData: { suffix: " " + suffix }
    });
  },

  _onChangeNulls: function() {
    this._changeHeaderValue('.js-nulls', 'nulls', 'NULL ROWS');
  },

  _onChangeTotal: function() {
    this._changeHeaderValue('.js-val', 'total', 'SELECTED');
  },

  _onChangeMax: function() {
    this._changeHeaderValue('.js-max', 'max', 'MAX');
  },

  _onChangeMin: function() {
    this._changeHeaderValue('.js-min', 'min', 'MIN');
  },

  _onChangeAvg: function() {
    this._changeHeaderValue('.js-avg', 'avg', 'AVG');
  },

  _addTitleForValue: function(className, what, unit) {
    this.$(className).attr('title', this._formatNumberWithCommas(this.viewModel.get(what).toFixed(2)) + ' ' + unit);
  },

  _formatNumberWithCommas: function(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  },

  _updateStats: function() {
    var data = this.originalData;

    if (this._isZoomed()) {
      data = this.zoomedData;
    }

    var nulls = this.model.get('nulls');

    var min, max;

    if (data && data.length) {

      var loBarIndex = this.viewModel.get('lo_index') || 0;
      var hiBarIndex = this.viewModel.get('hi_index') || data.length;

      var sum = this._calcSum(data, loBarIndex, hiBarIndex);
      var avg = this._calcAvg(data, loBarIndex, hiBarIndex);

      if (loBarIndex >= 0 && loBarIndex < data.length) {
        min = data[loBarIndex].start;
      }

      if (hiBarIndex >= 0 && hiBarIndex - 1 < data.length) {
        max = data[hiBarIndex - 1].end;
      }

      this.viewModel.set({ total: sum, nulls: nulls, min: min, max: max, avg: avg });
    }
  },

  _calcAvg: function(data, start, end) {

    var selectedData = data.slice(start, end);

    var total = this._calcSum(data, start, end, total);

    if (!total) {
      return 0;
    }

    var area = _.reduce(selectedData, function(memo, d) {
      return (d.avg && d.freq) ? (d.avg * d.freq) + memo : memo;
    }, 0);

    return area / total;
  },

  _calcSum: function(data, start, end) {
    return _.reduce(data.slice(start, end), function(memo, d) {
      return d.freq + memo;
    }, 0);
  },

  _onChangeZoomed: function() {
    if (this.viewModel.get('zoomed')) {
      this._onZoomIn();
    } else {
      this._onZoomOut();
    }
  },

  _onZoomIn: function() {
    this._showMiniRange();
    this.histogramChartView.expand(20);

    this.histogramChartView.removeShadowBars();

    this.model.set({ start: null, end: null, bins: null, own_filter: 1 });
    this.model._fetch();
    this.lockedByUser = false;
  },

  _zoom: function() {
    this.lockedByUser = true;
    this.viewModel.set({ zoomed: true, zoom_enabled: false });
    this.histogramChartView.removeSelection();
  },

  _onZoomOut: function() {
    this.lockedByUser   = true;
    this.lockZoomedData = false;
    this.unsettingRange = true;

    this.model.set({ start: this.start, end: this.end, bins: this.binsCount, own_filter: null });

    this.viewModel.set({ zoom_enabled: false, filter_enabled: false, lo_index: null, hi_index: null });

    this.filter.unsetRange();

    this.histogramChartView.contract(this.defaults.chartHeight);
    this.histogramChartView.resetIndexes();

    this.miniHistogramChartView.hide();
  },

  _showMiniRange: function() {
    var data = this.model.getData();

    var loBarIndex = this.viewModel.get('lo_index');
    var hiBarIndex = this.viewModel.get('hi_index');

    this.miniHistogramChartView.selectRange(loBarIndex, hiBarIndex);
    this.miniHistogramChartView.show();
  },

  _clear: function() {
    this.histogramChartView.removeSelection();
    this.viewModel.set({ zoomed: false, zoom_enabled: false });
    this.viewModel.trigger('change:zoomed');
  }
});

},{"../animate_values.js":33,"../standard/widget_content_view":85,"../widget_content_model":105,"./animation_template.tpl":67,"./chart":68,"./content.tpl":70,"./histogram_title_view":72,"./placeholder.tpl":74}],70:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="js-title"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> </div> <dl class="CDB-Widget-info CDB-Widget-textSmaller CDB-Widget-textSmaller--upper"> <dt class="CDB-Widget-infoItem js-nulls">0 NULL ROWS</dt> <dt class="CDB-Widget-infoItem js-min">0 MIN</dt> <dt class="CDB-Widget-infoItem js-avg">0 AVG</dt> <dt class="CDB-Widget-infoItem js-max">0 MAX</dt> </dl> </div> <div class="CDB-Widget-content js-content"> <div class="CDB-Widget-tooltip js-tooltip"></div> <div class="CDB-Widget-filter CDB-Widget-contentSpaced js-filter is-hidden"> <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--upper js-val"></p> <div class="CDB-Widget-filterButtons"> <button class="CDB-Widget-link CDB-Widget-filterButton js-zoom">zoom</button> <button class="CDB-Widget-link CDB-Widget-filterButton js-clear">clear</button> </div> </div> </div>';
}
return __p;
};

},{"underscore":24}],71:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-options CDB-Widget-contentSpaced"> <button class="CDB-Widget-buttonIcon CDB-Widget-buttonIcon--circle js-sizes '+
((__t=( isSizesApplied ? 'is-selected' : '' ))==null?'':_.escape(__t))+
' '+
((__t=( isSizesApplied ? 'js-cancelSizes' : 'js-applySizes' ))==null?'':_.escape(__t))+
'" data-tooltip="'+
((__t=( isSizesApplied ? 'Remove sizes' : 'Apply sizes' ))==null?'':_.escape(__t))+
'"> <i class="CDB-Icon CDB-Icon-syringe CDB-Icon--top"></i> </button> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div>';
}
return __p;
};

},{"underscore":24}],72:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var View = cdb.core.View;
var TooltipView = require('../widget-tooltip-view');
var template = require('./histogram_title_template.tpl');

/**
 *  Show title + show if histogram sizes are applied or not
 *
 */

module.exports = View.extend({

  className: 'CDB-Widget-title CDB-Widget-contentSpaced',

  events: {
    'click .js-applySizes': '_applySizes',
    'click .js-cancelSizes': '_cancelSizes',
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.$el.html(
      template({
        title: this.dataModel.get('title'),
        isSizesApplied: this.dataModel.get('histogramSizes'),
        isCollapsed: this.dataModel.isCollapsed()
      })
    );
    this._initViews();

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:histogramSizes change:collapsed', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _initViews: function() {
    var sizesTooltip = new TooltipView({
      target: this.$('.js-sizes')
    });
    $('body').append(sizesTooltip.render().el);
    this.addView(sizesTooltip);

    var collapseTooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(collapseTooltip.render().el);
    this.addView(collapseTooltip);
  },

  _applySizes: function() {
    this.dataModel.set('histogramSizes', true);
  },

  _cancelSizes: function() {
    this.dataModel.set('histogramSizes', false);
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  }

});

},{"../widget-tooltip-view":102,"./histogram_title_template.tpl":71}],73:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  url: function() {
    var params = [];

    if (this.get('columnType')) {
      params.push('column_type=' + this.get('columnType'));
    }
    if (_.isNumber(this.get('start'))) {
      params.push('start=' + this.get('start'));
    }
    if (_.isNumber(this.get('end'))) {
      params.push('end=' + this.get('end'));
    }
    if (_.isNumber(this.get('bins'))) {
      params.push('bins=' + this.get('bins'));
    }
    if (_.isNumber(this.get('own_filter'))) {
      params.push('own_filter=' + this.get('own_filter'));
    }
    if (this.get('boundingBox') && this.get('submitBBox')) {
      params.push('bbox=' + this.get('boundingBox'));
    }

    var url = this.get('url');
    if (params.length > 0) {
        url += '?' + params.join('&');
    }
    return url;
  },

  initialize: function(attrs, opts) {
    WidgetModel.prototype.initialize.apply(this, arguments);
    this._data = new Backbone.Collection(this.get('data'));

    // BBox should only be included until after the first fetch, since we want to get the range of the full dataset
    this.once('change:data', function() {
      this.set('submitBBox', true);
    }, this);

    this.layer.bind('change:meta', this._onChangeLayerMeta, this);
  },

  getData: function() {
    return this._data.toJSON();
  },

  getSize: function() {
    return this._data.size();
  },

  parse: function(data) {
    var numberOfBins = data.bins_count;
    var width = data.bin_width;
    var nulls = data.nulls_count;
    var start = data.bins_start;

    var buckets = new Array(numberOfBins);

    _.each(data.bins, function(b) {
      buckets[b.bin] = b;
    });

    for (var i = 0; i < numberOfBins; i++) {
      buckets[i] = _.extend({
        bin: i,
        start: start + (i * width),
        end: start + ((i + 1) * width),
        freq: 0
      }, buckets[i]);
    }

    this._data.reset(buckets);

    return {
      data: buckets,
      nulls: data.nulls
    };
  },

  // set bins for the histograms
  // @bins should be an array with the format [{ start: ..., end: ..., freq: ..., min: ..., max:   }, ...]
  //    - start, end: are the bucket bounds
  //    - min, max: the min and the max value for all the points in that bucket
  //    - freq: count
  setBins: function(bins, options) {
    this._data.reset(bins, options);
    this.set('data', { bins: bins }, options);
    return this;
  },

  toJSON: function(d) {
    return {
      type: "histogram",
      options: {
        column: this.get('column'),
        bins: this.get('bins')
      }
    };
  },

  _onChangeLayerMeta: function() {
    this.filter.set('columnType', this.layer.get('meta').column_type);
  },

  _onChangeBinds: function() {
    WidgetModel.prototype._onChangeBinds.call(this);
    this.bind('change:histogramSizes', function(mdl, isSizesApplied, d) {
      if (isSizesApplied) {
        this.trigger('histogramSizes', this);
      }
    }, this);
  }
});

},{"../widget_model":106}],74:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-chart CDB-Widget-chart--fake"> ';
 for (var i = 0; i < 15; i++) { 
__p+=' <li class="CDB-Widget-chartItem CDB-Widget-chartItem--'+
((__t=( _.sample(['small', 'medium', 'big'], 1)[0] ))==null?'':_.escape(__t))+
' Widget-chartItem--fake"></li> ';
 } 
__p+=' </ul>';
}
return __p;
};

},{"underscore":24}],75:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( itemsCount ))==null?'':_.escape(__t))+
' rows</dt> </dl> </div> <div class="CDB-Widget-content CDB-Widget-content--noSidesMargin"> <div class="CDB-Widget-listWrapper js-content"></div> </div> <div class="CDB-Widget-footer js-footer"></div>';
}
return __p;
};

},{"underscore":24}],76:[function(require,module,exports){
var _ = cdb._;
var format = cdb.core.format;
var WidgetContentView = require('../standard/widget_content_view');
var WidgetListItemsView = require('./items_view');
var WidgetListPaginatorView = require('./paginator_view');
var WidgetListEdgesView = require('./edges_view');
var template = require('./content_template.tpl');
var templatePlaceholder = require('./placeholder_template.tpl');

/**
 * Default widget content view:
 */
module.exports = WidgetContentView.extend({

  options: {
    showScroll: false
  },

  render: function() {
    this.clearSubViews();
    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;
    this.$el.html(
      template({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? format.formatValue(data.length) : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    } else {
      this._initViews();
    }

    return this;
  },

  _initViews: function() {
    var count = this.model.getSize();

    // List view -> items view
    this._list = new WidgetListItemsView({
      model: this.model
    });
    this.$('.js-content').html(this._list.render().el);
    this.addView(this._list);

    var isScrollList = (this._list.$el.get(0).scrollHeight - this._list.$el.outerHeight()) > 0;

    if (isScrollList || this.options.showScroll) {
      // Paginator
      this._pagination = new WidgetListPaginatorView({
        $target: this._list.$el
      });
      this.$('.js-footer').append(this._pagination.render().el);
      this.addView(this._pagination);

      // Edges
      this._edges = new WidgetListEdgesView({
        $target: this._list.$el
      });
      this.$('.js-content').append(this._edges.render().el);
      this.addView(this._edges);
    }
  }

});

},{"../standard/widget_content_view":85,"./content_template.tpl":75,"./edges_view":77,"./items_view":80,"./paginator_view":82,"./placeholder_template.tpl":83}],77:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;

/**
 *  List edges view:
 *
 *  - It shows the borders and the shadows, if needed.
 */
module.exports = View.extend({

  _TEMPLATE: ' ' +
    '<div class="CDB-Widget-listEdge CDB-Widget-listEdge--top">'+
      '<div class="CDB-Widget-listEdgeShadow js-topShadow"></div>'+
      '<div class="CDB-Widget-listEdgeBorder"></div>'+
    '</div>'+
    '<div class="CDB-Widget-listEdge CDB-Widget-listEdge--bottom">'+
      '<div class="CDB-Widget-listEdgeShadow js-bottomShadow"></div>'+
      '<div class="CDB-Widget-listEdgeBorder"></div>'+
    '</div>',

  initialize: function() {
    this._$target = this.options.$target;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    var template = _.template(this._TEMPLATE);
    this.$el.html(template());
    this._checkScroll();
    return this;
  },

  _initBinds: function() {
    var self = this;
    this._$target.bind('scroll', function() {
      self._checkScroll();
    });
  },

  _unbindScroll: function() {
    this._$target.unbind('scroll');
  },

  _checkScroll: function() {
    var currentScroll = this._$target.scrollTop();
    var maxScroll = this._$target.get(0).scrollHeight - this._$target.outerHeight();
    this.$('.js-topShadow').toggle(currentScroll !== 0);
    this.$('.js-bottomShadow').toggle(currentScroll !== maxScroll);
  },

  clean: function() {
    this._unbindScroll();
    View.prototype.clean.call(this);
  }

});

},{}],78:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isClickable) { 
__p+=' <button type="button" class="CDB-Widget-listItemInner CDB-Widget-listButton CDB-Widget-listButton--withBorder js-button"> ';
 } else { 
__p+=' <div class="CDB-Widget-listItemInner CDB-Widget-listItemInner--withBorders"> ';
 } 
__p+=' <div class="CDB-Widget-contentSpaced CDB-Widget-contentSpaced--topAligned CDB-Widget-contentSpaced--start"> <em class="CDB-Shape-dot CDB-Widget-listDot"></em> ';
 if (itemsCount > 0) { 
__p+=' <div class="CDB-Widget-contentFull"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--upper CDB-Widget-textSmall--bold" title="'+
((__t=( items[0][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[0][1] ))==null?'':_.escape(__t))+
'</p> ';
 if (itemsCount > 2) { 
__p+=' <dl class="CDB-Widget-inlineList"> ';
 for (var i = 1, l = itemsCount; i < l; i++) { 
__p+=' <div class="CDB-Widget-inlineListItem CDB-Widget-textSmaller CDB-Widget-textSmaller--noEllip"> <dd class="CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark u-rSpace" title="'+
((__t=( items[i][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[i][1] ))==null?'':_.escape(__t))+
'</dd> <dt title="'+
((__t=( items[i][0] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[i][0] ))==null?'':_.escape(__t))+
'</dt> </div> ';
 } 
__p+=' </dl> ';
 } else if (itemsCount === 2) { 
__p+=' <dl class="CDB-Widget-textSmaller CDB-Widget-textSmaller--noEllip u-tSpace"> <dd class="CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark u-rSpace" title="'+
((__t=( items[1][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[1][1] ))==null?'':_.escape(__t))+
'</dd> <dt title="'+
((__t=( items[1][0] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[1][0] ))==null?'':_.escape(__t))+
'</dt> </dl> ';
 } 
__p+=' </div> ';
 } 
__p+=' </div> ';
 if (isClickable) { 
__p+=' </div></button> ';
 } else { 
__p+='  ';
 } 
__p+='';
}
return __p;
};

},{"underscore":24}],79:[function(require,module,exports){
var _ = cdb._;
var format = cdb.core.format;
var View = cdb.core.View;
var template = require('./item_template.tpl');

module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function() {
    this.viewModel = this.options.viewModel;
  },

  render: function() {
    var data = this.model.toJSON();
    var hasInteractivity = this._hasInteractivity(data);
    var items = this._sanitizeData(data);

    this.$el.html(
      template({
        items: items,
        isClickable: hasInteractivity,
        itemsCount: _.size(items)
      })
    );

    // If there is no cartodb_id defined, click event should
    // be disabled
    this[ hasInteractivity ? 'delegateEvents' : 'undelegateEvents' ]();
    return this;
  },

  // Remove cartodb_id, if exists
  // Replace titles if there are alternatives
  // Convert data object to array items
  _sanitizeData: function(data) {
    var hasInteractivity = this._hasInteractivity(data);
    var data = _.omit(data, function(value, key, object) {
      return key === 'cartodb_id';
    });

    var columnTitles = this.viewModel.get('columns_title');
    if (hasInteractivity && !_.isEmpty(columnTitles)) {
      columnTitles = _.rest(columnTitles, 1);
    }

    // Convert to pair items and check if there is a column title
    var arr = [];
    var i = 0;

    _.each(data, function(value, key) {
      var title = columnTitles && columnTitles[i] || key;
      arr.push([ title, format.formatValue(value) ]);
      ++i;
    });

    return arr;
  },

  _hasInteractivity: function(data) {
    return !_.isEmpty(
      _.filter(data, function(value, key){
        return key === 'cartodb_id'
      })
    )
  },

  _onItemClick: function() {
    this.trigger('itemClicked', this.model, this);
  }

});

},{"./item_template.tpl":78}],80:[function(require,module,exports){
var View = cdb.core.View;
var WidgetListItemView = require('./item_view');

module.exports = View.extend({

  className: 'CDB-Widget-list js-list',
  tagName: 'ul',

  events: {
    'scroll': '_checkScroll'
  },

  render: function() {
    this.clearSubViews();
    this._renderList();
    return this;
  },

  _renderList: function() {
    this.model.getData().each(this._addItem, this);
  },

  _addItem: function(mdl) {
    var v = new WidgetListItemView({
      model: mdl,
      viewModel: this.model
    });
    v.bind('itemClicked', function(){
      this.trigger('itemClicked', mdl, this);
    }, this);
    this.addView(v);
    this.$el.append(v.render().el);
  }

});

},{"./item_view":79}],81:[function(require,module,exports){
var Backbone = cdb.Backbone;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  options: {
    page: 0,
    per_page: 100
  },

  initialize: function(attrs, opts) {
    this._data = new Backbone.Collection(this.get('data'));
    WidgetModel.prototype.initialize.call(this, attrs, opts);
  },

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  parse: function(data) {
    var rows = data.rows;
    this._data.reset(rows);
    return {
      data: rows
    };
  },

  toJSON: function() {
    return {
      type: "list",
      options: {
        columns: this.get('columns')
      }
    };
  }
});

},{"../widget_model":106}],82:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;

module.exports = View.extend({

  className: 'CDB-Widget-nav CDB-Widget-contentSpaced',

  _TEMPLATE: ' ' +
    '<span></span>' +
    '<div class="CDB-Widget-navArrows CDB-Widget-contentSpaced">'+
      '<button class="CDB-Shape-arrow CDB-Shape-arrow--up js-up"></button>'+
      '<button class="CDB-Shape-arrow CDB-Shape-arrow--down js-down"></button>'+
    '</div>',

  events: {
    'click .js-up': '_scrollUp',
    'click .js-down': '_scrollDown'
  },

  initialize: function() {
    if (!this.options.$target) {
      throw new Error('target should be defined in order to be able to paginate');
    }
    this._$target = this.options.$target;
    this._scrollHeight = this._$target.get(0).scrollHeight - this._$target.outerHeight();
    this._initBinds();
  },

  render: function() {
    var template = _.template(this._TEMPLATE);
    this.$el.html(template());
    this._checkScroll();
    return this;
  },

  _initBinds: function() {
    var self = this;
    this._$target.bind('scroll', function() {
      self._checkScroll();
    });
  },

  _unbindScroll: function() {
    this._$target.unbind('scroll');
  },

  _checkScroll: function() {
    var currentScroll = this._$target.scrollTop();
    this.$('.js-up').toggleClass('is-disabled', currentScroll === 0);
    this.$('.js-down').toggleClass('is-disabled', currentScroll >= this._scrollHeight);
  },

  _getEdgeVisibleItems: function() {
    var areaHeight = this._$target.outerHeight();
    var firstEl = null;
    var lastEl = null;
    var items = this._$target.children('.CDB-Widget-listItem');

    items.each(function(index, value) {
      var top = $(this).position().top;
      var height = $(this).outerHeight();

      if (top > -1 && firstEl === null){ //first entirely visible element
        firstEl = this;
      } else if ((top + height) > areaHeight && lastEl === null){
        lastEl = items[index-1];//the last entirely visible was the element before
      }
    });

    return [firstEl,lastEl];
  },

  _scrollDown: function() {
    var lastVisibleItem = this._getEdgeVisibleItems()[1];
    var currentScroll = this._$target.scrollTop();
    var $next = $(lastVisibleItem).next();
    if ($next.length) {
      var top = $next.position().top;
      var height = $next.outerHeight();
      var scrollPos = top + height - this._$target.outerHeight() + currentScroll;
      if (scrollPos > 0) {
        this._$target.scrollTop(scrollPos);
      }
    }
  },

  _scrollUp: function() {
    var firstVisibleItem = this._getEdgeVisibleItems()[0];
    var currentScroll = this._$target.scrollTop();
    var $prev = $(firstVisibleItem).prev();
    if ($prev.length) {
      var top = $prev.position().top;
      var scrollPos = currentScroll + top;
      this._$target.scrollTop(scrollPos);
    }
  },

  clean: function() {
    this._unbindScroll();
    View.prototype.clean.call(this);
  }

});

},{}],83:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-list CDB-Widget-list--withBorders"> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> </ul>';
}
return __p;
};

},{"underscore":24}],84:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( itemsCount ))==null?'':_.escape(__t))+
' items</dt> </dl> </div> <div class="CDB-Widget-content js-content"></div>';
}
return __p;
};

},{"underscore":24}],85:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var log = cdb.log;
var View = cdb.core.View;
var d3 = cdb.d3;
var contentTemplate = require('./widget_content_template.tpl');
var placeholderTemplate = require('./widget_placeholder_template.tpl');

/**
 * Default widget content view:
 */
module.exports = View.extend({

  className: 'CDB-Widget-body',

  initialize: function() {
    this.filter = this.options.filter;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;
    this.$el.html(
      contentTemplate({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? data.length : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    }

    return this;
  },

  _initBinds: function() {
    this.model.bind('change:data', this.render, this);
  },

  _addPlaceholder: function() {
    if (placeholderTemplate) {
      this.$('.js-content').append(placeholderTemplate());
    } else {
      log.info('Placeholder template doesn\'t exist');
    }
  }
});

},{"./widget_content_template.tpl":84,"./widget_placeholder_template.tpl":89}],86:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button class="CDB-Widget-button CDB-Widget-errorButton js-refresh"> <span class="CDB-Widget-textSmall CDB-Widget-textSmall--bold">REFRESH</span> </button>';
}
return __p;
};

},{"underscore":24}],87:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var template = require('./widget_error_template.tpl');

/**
 *  Default widget error view:
 *
 *  It will listen or not to dataModel changes when
 *  first load is done.
 */
module.exports = View.extend({

  className: 'CDB-Widget-error is-hidden',

  events: {
    'click .js-refresh': '_onRefreshClick'
  },

  initialize: function() {
    this._initBinds();
  },

  render: function() {
    this.$el.html(template());
    return this;
  },

  _initBinds: function() {
    this.model.bind('error', this.show, this);
    this.model.bind('loading', this.hide, this);
  },

  _onRefreshClick: function() {
    this.model.refresh();
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  }

});

},{"./widget_error_template.tpl":86}],88:[function(require,module,exports){
var View = cdb.core.View;

/**
 *  Default widget loader view:
 *
 *  It will listen or not to dataModel changes when
 *  first load is done.
 */
module.exports = View.extend({

  className: 'CDB-Widget-loader',

  initialize: function() {
    this._initBinds();
  },

  _initBinds: function() {
    this.model.bind('loading', this.show, this);
    this.model.bind('sync error', this.hide, this);
  },

  show: function() {
    this.$el.addClass('is-visible');
  },

  hide: function() {
    var self = this;
    setTimeout(function() {
      self.$el.removeClass('is-visible');
    }, 500);
  }

});

},{}],89:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-list CDB-Widget-list--withBorders"> <li class="CDB-Widget-listItem CDB-Widget-listItem--withBorders CDB-Widget-listItem--fake"></li> </ul>';
}
return __p;
};

},{"underscore":24}],90:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var placeholderTemplate = require('./placeholder.tpl');
var HistogramView = require('./histogram-view');

/**
 * Widget content view for a time-series
 */
module.exports = View.extend({

  className: 'CDB-Widget-body CDB-Widget-body--timeSeries',

  initialize: function() {
    this.model.once('change:data', this._onFirstLoad, this);
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(''); // to remove placeholder if there is any

    if (this._isDataEmpty()) {
      this.$el.append(placeholderTemplate({
        hasTorqueLayer: false
      }));
    } else {
      this._appendView(new HistogramView(this.options));
    }

    return this;
  },

  _onFirstLoad: function() {
    this._storeBounds();
    this.model.once('change:data', this.render, this);
    this.model._fetch();
  },

  _storeBounds: function() {
    var data = this.model.getData();
    if (data && data.length > 0) {
      var start = data[0].start;
      var end = data[data.length - 1].end;
      this.model.set({ start: start, end: end, bins: data.length });
    }
  },

  _appendView: function(view) {
    this.addView(view);
    this.$el.append(view.render().el);
  },

  _isDataEmpty: function() {
    var data = this.model.getData();
    return _.isEmpty(data) || _.size(data) === 0;
  }
});

},{"./histogram-view":91,"./placeholder.tpl":92}],91:[function(require,module,exports){
var $ = cdb.$;
var View = cdb.core.View;
var HistogramChartView = require('../histogram/chart');

/**
 * Time-series histogram view.
 */
module.exports = View.extend({

  className: 'CDB-Widget-content CDB-Widget-content--timeSeries',

  defaults: {
    mobileThreshold: 960, // px; should match CSS media-query
    histogramChartHeight:
      48 + // inline bars height
      4 + // bottom margin
      16 + // labels
      4, // margins
    histogramChartMobileHeight:
      20 + // inline bars height (no bottom labels)
      4 // margins
  },

  initialize: function() {
    this.filter = this.options.filter;

    this.model.bind('change:data', this._onChangeData, this);
  },

  render: function() {
    this.clearSubViews();
    this._createHistogramView();
    return this;
  },

  _createHistogramView: function() {
    this._chartView = new HistogramChartView({
      type: 'time',
      animationSpeed: 100,
      margin: {
        top: 4,
        right: 4,
        bottom: 4,
        left: 4
      },
      hasHandles: true,
      animationBarDelay: function(d, i) {
        return (i * 3);
      },
      height: this.defaults.histogramChartHeight,
      data: this.model.getData()
    });
    this.addView(this._chartView);
    this.$el.append(this._chartView.render().el);
    this._chartView.show();

    this._chartView.bind('on_brush_end', this._onBrushEnd, this);
    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this.add_related_model(this._chartView.model);
  },

  _onChangeData: function() {
    if (this._chartView) {
      this._chartView.replaceData(this.model.getData());
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this.model.getData();
    this.filter.setRange(
      data[loBarIndex].start,
      data[hiBarIndex - 1].end
    );
  },

  _onChangeChartWidth: function() {
    var isMobileSize = $(window).width() < this.defaults.mobileThreshold;

    this._chartView.toggleLabels(!isMobileSize);

    var height = isMobileSize
      ? this.defaults.histogramChartMobileHeight
      : this.defaults.histogramChartHeight;
    this._chartView.model.set('height', height);
  }

});

},{"../histogram/chart":68}],92:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header CDB-Widget-header--timeSeries"> ';
 if (hasTorqueLayer) { 
__p+=' <div class="CDB-Widget-timeSeriesFakeControl"></div> <div class="CDB-Widget-timeSeriesTimeInfo CDB-Widget-timeSeriesTimeInfo--fake"></div> ';
 } 
__p+=' </div> <div class="CDB-Widget-content CDB-Widget-content--timeSeries"> <div class="CDB-Widget-timeSeriesFakeChart ';
 if (hasTorqueLayer) { 
__p+='CDB-Widget-timeSeriesFakeChart--torque';
 } 
__p+='"> ';
 for (var i = 0; i < 50; i++) { 
__p+=' <div class="CDB-Widget-timeSeriesFakeChartItem" style="height: '+
((__t=( Math.floor(Math.random() * 100) ))==null?'':_.escape(__t))+
'%"></div> ';
 } 
__p+=' </div> </div>';
}
return __p;
};

},{"underscore":24}],93:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var torqueTemplate = require('./torque-template.tpl');
var placeholderTemplate = require('./placeholder.tpl');
var TorqueControlsView = require('./torque-controls-view');
var TorqueTimeInfoView = require('./torque-time-info-view');
var TorqueHistogramView = require('./torque-histogram-view');

/**
 * Widget content view for a Torque time-series
 */
module.exports = View.extend({

  className: 'CDB-Widget-body CDB-Widget-body--timeSeries',

  initialize: function() {
    this.model.once('change:data', this.render, this);
  },

  render: function() {
    this.clearSubViews();

    if (this._isDataEmpty()) {
      this.$el.html(placeholderTemplate({
        hasTorqueLayer: true
      }));
    } else {
      this._renderContent();
    }

    return this;
  },

  _renderContent: function() {
    this.$el.html(torqueTemplate());
    this._appendView(
      new TorqueControlsView({ model: this.options.torqueLayerModel }),
      '.js-header'
    );
    this._appendView(
      new TorqueTimeInfoView({ model: this.options.torqueLayerModel }),
      '.js-header'
    );
    this._appendView(new TorqueHistogramView(this.options));
  },

  _appendView: function(view, selector) {
    this.addView(view);
    if (selector) {
      this.$(selector).append(view.el);
    } else {
      this.$el.append(view.el);
    }
    view.render();
  },

  _isDataEmpty: function() {
    var data = this.model.getData();
    return _.isEmpty(data) || _.size(data) === 0;
  }
});

},{"./placeholder.tpl":92,"./torque-controls-view":94,"./torque-histogram-view":96,"./torque-template.tpl":97,"./torque-time-info-view":98}],94:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./torque-controls.tpl');

/**
 * Torque animation controls, to manage run state
 */
module.exports = View.extend({

  tagName: 'button',
  className: 'CDB-Widget-controlButton',

  events: {
    'click': '_onClick'
  },

  initialize: function() {
    this.model.bind('change:isRunning', this.render, this);
  },

  render: function() {
    this.$el.html(
      template({
        iconClass: 'CDB-Widget-controlButton-icon CDB-Widget-controlButton-icon--' + (
          this.model.get('isRunning')
            ? 'pause'
            : 'play')
      })
    );

    return this;
  },

  _onClick: function() {
    if (this.model.get('isRunning')) {
      this.model.pause();
    } else {
      this.model.play();
    }
  }
});

},{"./torque-controls.tpl":95}],95:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-controlButton-content"> <i class="'+
((__t=( iconClass ))==null?'':_.escape(__t))+
'"></i> </div>';
}
return __p;
};

},{"underscore":24}],96:[function(require,module,exports){
var $ = cdb.$;
var View = cdb.core.View;
var HistogramChartView = require('../histogram/chart');
var TorqueTimeSliderView = require('./torque-time-slider-view');

/**
 * Torque time-series histogram view.
 * Extends the common histogram chart view with time-control
 * this.model is a histogram model
 */
module.exports = View.extend({

  className: 'CDB-Widget-content CDB-Widget-content--timeSeries',

  // TODO could be calculated from element styles instead of duplicated numbers here?
  defaults: {
    mobileThreshold: 960, // px; should match CSS media-query
    histogramChartHeight:
      48 + // inline bars height
      4 + // bottom margin
      16 + // bottom labels
      4, // margins
    histogramChartMobileHeight:
      20 + // inline bars height (no bottom labels)
      4 // margins
  },

  initialize: function() {
    if (!this.options.torqueLayerModel) throw new Error('torqeLayerModel is required');
    if (!this.options.rangeFilter) throw new Error('rangeFilter is required');

    this._rangeFilter = this.options.rangeFilter;
    this._torqueLayerModel = this.options.torqueLayerModel;

    this.model.bind('change:data', this._onChangeData, this);
  },

  render: function() {
    this.clearSubViews();
    this._createHistogramView();
    return this;
  },

  _createHistogramView: function() {
    this._chartView = new HistogramChartView({
      type: 'time',
      animationSpeed: 100,
      animationBarDelay: function(d, i) {
        return (i * 3);
      },
      margin: {
        top: 4,
        right: 4,
        bottom: 4,
        left: 4
      },
      hasHandles: true,
      height: this.defaults.histogramChartHeight,
      data: this.model.getData(),
      shadowData: this.model.getData()
    });

    this.addView(this._chartView);
    this.$el.append(this._chartView.render().el);
    this._chartView.show();

    this._chartView.bind('on_brush_end', this._onBrushEnd, this);
    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this.add_related_model(this._chartView.model);

    var timeSliderView = new TorqueTimeSliderView({
      model: this.model, // a histogram model
      chartView: this._chartView,
      torqueLayerModel: this._torqueLayerModel
    });
    this.addView(timeSliderView);
    timeSliderView.render();
  },

  _onChangeData: function() {
    if (this._chartView) {
      this._chartView.replaceData(this.model.getData());
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this.model.getData();
    this._rangeFilter.setRange(
      data[loBarIndex].start,
      data[hiBarIndex - 1].end
    );
    this._torqueLayerModel.setStepsRange(loBarIndex, hiBarIndex);
  },

  _onChangeChartWidth: function() {
    var isMobileSize = $(window).width() < this.defaults.mobileThreshold;

    this._chartView.toggleLabels(!isMobileSize);

    var height = isMobileSize
      ? this.defaults.histogramChartMobileHeight
      : this.defaults.histogramChartHeight;
    this._chartView.model.set('height', height);
  }

});

},{"../histogram/chart":68,"./torque-time-slider-view":100}],97:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header CDB-Widget-header--timeSeries js-header"></div>';
}
return __p;
};

},{"underscore":24}],98:[function(require,module,exports){
var _ = cdb._;
var d3 = cdb.d3;
var View = cdb.core.View;
var template = require('./torque-time-info.tpl');

/**
 * View rendering the current step time
 *
 * Model is expected to be a torque layer model
 */
module.exports = View.extend({

  className: 'CDB-Widget-timeSeriesTimeInfo',

  initialize: function() {
    this.model.bind('change:step', this.render, this);

    // for format rules see https://github.com/mbostock/d3/wiki/Time-Formatting
    this._timeFormatter = d3.time.format('%H:%M');
    this._dateFormatter = d3.time.format('%x');
  },

  render: function() {
    var date = this.model.get('time');

    this.$el.html(
      isNaN(date && date.getTime())
        ? ''
        : template({
            time: this._timeFormatter(date),
            date: this._dateFormatter(date)
          })
    );

    return this;
  }
});

},{"./torque-time-info.tpl":99}],99:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<p class="CDB-Widget-textBig"> '+
((__t=( time ))==null?'':_.escape(__t))+
' </p> <p class="CDB-Widget-textBig CDB-Widget-text--secondary"> '+
((__t=( date ))==null?'':_.escape(__t))+
' </p>';
}
return __p;
};

},{"underscore":24}],100:[function(require,module,exports){
var d3 = cdb.d3;
var Model = cdb.core.Model;
var View = cdb.core.View;

/**
 * Time-slider, expected to be used in a histogram view
 */
module.exports = View.extend({

  defaults: {
    width: 4,
    height: 8
  },

  initialize: function() {
    if (!this.options.model) throw new Error('model is required');
    if (!this.options.chartView) throw new Error('chartView is required');
    if (!this.options.torqueLayerModel) throw new Error('torqeLayerModel is required');

    this._chartView = this.options.chartView;
    this._torqueLayerModel = this.options.torqueLayerModel;
    this.viewModel = new Model();

    this._torqueLayerModel.bind('change:step', this._onChangeStep, this);
    this._torqueLayerModel.bind('change:steps', this._onChangeSteps, this);
    this._torqueLayerModel.bind('change:stepsRange', this._onStepsRange, this);
    this.add_related_model(this._torqueLayerModel);

    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this._chartView.model.bind('change:height', this._onChangeChartHeight, this);
    this.add_related_model(this._chartView.model);

    this._updateXScale();
  },

  render: function() {
    // Make the render call idempotent; only create time slider once
    if (!this.timeSlider) {
      var dragBehavior = d3.behavior.drag()
        .on('dragstart', this._onDragStart.bind(this))
        .on('drag', this._onDrag.bind(this))
        .on('dragend', this._onDragEnd.bind(this));

      this.timeSlider = this._chartView.canvas.append('rect')
        .attr('class', 'CDB-TimeSlider')
        .attr('width', this.defaults.width)
        .attr('height', this._calcHeight())
        .attr('rx', 3)
        .attr('ry', 3)
        .data([{ x: 0, y: 0 }])
        .attr('transform', this._translateXY)
        .call(dragBehavior);
    }

    return this;
  },

  clean: function() {
    if (this.timeSlider) {
      this.timeSlider.remove();
    }
    View.prototype.clean.call(this);
  },

  _onDragStart: function() {
    var isRunning = this._torqueLayerModel.get('isRunning');
    if (isRunning) {
      this._torqueLayerModel.pause();
    }
    this.viewModel.set({
      isDragging: true,
      wasRunning: isRunning
    });
  },

  _onDrag: function(d, i) {
    var nextX = d.x + d3.event.dx;
    if (this._isWithinRange(nextX)) {
      d.x = nextX;
      this.timeSlider.attr('transform', this._translateXY);

      var step = Math.round(this._xScale.invert(d.x));
      this._torqueLayerModel.setStep(step);
    }
  },

  _onDragEnd: function() {
    this.viewModel.set('isDragging', false);
    if (this.viewModel.get('wasRunning')) {
      this._torqueLayerModel.play();
    }
  },

  _translateXY: function(d) {
    return 'translate(' + [d.x, d.y] + ')';
  },

  _isWithinRange: function(x) {
    return x >= 0 && x <= this._width();
  },

  _onChangeStep: function() {
    // Time slider might not be created when this method is first called
    if (this.timeSlider && !this.viewModel.get('isDragging')) {
      var data = this.timeSlider.data();
      var newX = this._xScale(this._torqueLayerModel.get('step'));
      if (!isNaN(newX)) {
        data[0].x = newX;
        this.timeSlider
          .data(data)
          .transition()
          .ease('linear')
          .attr('transform', this._translateXY);
      }
    }
  },

  _onChangeSteps: function() {
    this._updateXScale();
  },

  _onStepsRange: function() {
    var r = this._torqueLayerModel.get('stepsRange');
    if (r.start === 0 && r.end === this.model.get('bins')) {
      this._chartView.removeSelection();
    } else {
      this._chartView.selectRange(r.start, r.end);
    }
  },

  _onChangeChartWidth: function() {
    this._updateXScale();
    this._onChangeStep();
  },

  _onChangeChartHeight: function() {
    this.timeSlider.attr('height', this._calcHeight());
  },

  _calcHeight: function() {
    return this._chartView.chartHeight() + this.defaults.height;
  },

  _updateXScale: function() {
    this._xScale = d3.scale.linear()
      .domain([0, this._torqueLayerModel.get('steps')])
      .range([0, this._width()]);
  },

  _width: function() {
    return this._chartView.model.get('width');
  }
});

},{}],101:[function(require,module,exports){
var _ = cdb._;

var WidgetModelFactory = function (types) {
  types = types || {};
  this.types = {};
  for (var type in types) {
    var createModel = types[type];
    this.addType(type, createModel);
  }
};

WidgetModelFactory.prototype.addType = function (type, createModel) {
  if (!_.isString(type)) new Error('type must be a string or a function');
  if (!_.isFunction(createModel)) new Error('createModel must be a function');
  this.types[type] = createModel;
};

WidgetModelFactory.prototype.createModel = function (layer, layerIndex, attrs) {
  if (!attrs.id) throw new Error('attrs.id is required');

  var createModel = this.types[attrs.type];
  if (createModel) {
    var opts = {
      layer: layer
    };
    return createModel(attrs, opts, layerIndex);
  } else {
    throw new Error('no model found for arguments ' + arguments);
  }
};

module.exports = WidgetModelFactory;

},{}],102:[function(require,module,exports){
var View = cdb.core.View;
var _ = cdb._;

/**
 * Standard widget tooltip view
 *
 */
module.exports = View.extend({

  className: 'CDB-Widget-tooltip',

  options: {
    attribute: 'data-tooltip',
    offsetX: 10,
    offsetY: -28
  },

  initialize: function(opts) {
    if (!opts.target) {
      throw new Error('target is not defined');
    }
    this._$target = this.options.target;
    this._initBinds();
  },

  render: function() {
    var value = this._$target.attr(this.options.attribute);
    this.$el.html(value);
    return this;
  },

  _initBinds: function() {
    this._$target.hover(
      _.bind(this.show, this),
      _.bind(this.hide, this)
    );
  },

  _setPosition: function() {
    var pos = this._$target.offset();
    var width = this.$el.outerWidth();

    this.$el.css({
      top: pos.top + this.options.offsetY,
      left: pos.left - (width/2) + this.options.offsetX
    });
  },

  show: function() {
    this.render();
    this._setPosition();
    View.prototype.show.call(this);
  },

  clean: function() {
    this._$target.off('mouseenter mouseleave');
    View.prototype.clean.call(this);
  }

});

},{}],103:[function(require,module,exports){
var _ = cdb._;
var WidgetView = require('./widget-view');

var WidgetViewFactory = function(defs) {
  this.defs = [];
  _.each(defs, function(def) {
    this.addType(def);
  }, this);
};

WidgetViewFactory.prototype.DEFAULT_CLASS_NAMES = 'CDB-Widget CDB-Widget--light';

WidgetViewFactory.prototype.addType = function(def) {
  if (!def.match) {
    if (def.type) {
      def.match = function(widget) {
        return widget.get('type') === this.type;
      };
    } else {
      new Error('def.type or def.match must be provided for createContentView to work');
    }
  }
  if (!_.isFunction(def.createContentView)) new Error('def.createContentView must be a function');
  this.defs.push(def);
};

/**
 * @returns {Object, undefined} Returns nothing if there is not matching view for the given model
 */
WidgetViewFactory.prototype.createWidgetView = function(widget) {
  var def = _.find(this.defs, function(def) {
    return def.match(widget);
  });

  if (def) {
    var attrs = {
      className: this.DEFAULT_CLASS_NAMES,
      model: widget,
      contentView: def.createContentView(widget)
    };

    return new WidgetView(
      _.isFunction(def.customizeWidgetAttrs)
        ? def.customizeWidgetAttrs(attrs)
        : attrs
    );
  }
};

module.exports = WidgetViewFactory;

},{"./widget-view":104}],104:[function(require,module,exports){
var View = cdb.core.View;
var WidgetLoaderView = require('./standard/widget_loader_view');
var WidgetErrorView = require('./standard/widget_error_view');

/**
 * Default widget view
 * The model is a expected to be widget model
 */
module.exports = View.extend({

  className: 'CDB-Widget CDB-Widget--light',

  options: {
    columns_title: [],
    sync: true
  },

  initialize: function() {
    this.model.layer.bind('change:visible', this._onChangeLayerVisible, this);
  },

  render: function() {
    this._loader = new WidgetLoaderView({
      model: this.model
    });
    this.$el.append(this._loader.render().el);
    this.addView(this._loader);

    this._error = new WidgetErrorView({
      model: this.model
    });
    this.$el.append(this._error.render().el);
    this.addView(this._error);

    var contentView = this.options.contentView;
    this.$el.append(contentView.render().el);
    this.addView(contentView);

    return this;
  },

  _onChangeLayerVisible: function(layer) {
    // !! to force a boolean value, so only a true value actually shows the view
    this.$el.toggle(!!layer.get('visible'));
  }
});

},{"./standard/widget_error_view":87,"./standard/widget_loader_view":88}],105:[function(require,module,exports){
var Model = cdb.core.Model;

/**
 *  View model, special for widgets with search and collapse
 *  functionalities
 *
 */

module.exports = Model.extend({

  defaults: {
    search: false
  },

  toggleSearch: function() {
    this.set('search', !this.get('search'));
  },

  enableSearch: function() {
    this.set('search', true);
  },

  disableSearch: function() {
    this.set('search', false);
  },

  isSearchEnabled: function() {
    return this.get('search');
  }

});

},{}],106:[function(require,module,exports){
var Model = cdb.core.Model;

/**
 * Default widget model
 */
module.exports = Model.extend({

  defaults: {
    url: '',
    data: [],
    columns: [],
    sync: true,
    bbox: true,
    collapsed: false
  },

  url: function() {
    return this.get('url') + '?bbox=' + this.get('boundingBox');
  },

  initialize: function(attrs, opts) {
    opts = opts || {};

    this.layer = opts.layer;
    this.filter = opts.filter; // optional/might be undefined

    this._initBinds();
  },

  _initBinds: function() {
    this.once('change:url', function() {
      var self = this;
      this._fetch(function() {
        self._onChangeBinds();
      });
    }, this);

    // Retrigger an event when the filter changes
    if (this.filter) {
      this.filter.bind('change', this._onFilterChanged, this);
    }
  },

  _onChangeBinds: function() {
    this.bind('change:url', function(){
      if (this.get('sync') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);
    this.bind('change:boundingBox', function() {
      if (this.get('bbox') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:collapsed', function(mdl, isCollapsed) {
      if (!isCollapsed) {
        if (mdl.changedAttributes(this._previousAttrs)) {
          this._fetch();
        }
      } else {
        this._previousAttrs = {
          url: this.get('url'),
          boundingBox: this.get('boundingBox')
        };
      }
    }, this);
  },

  _fetch: function(callback) {
    var self = this;
    this.fetch({
      success: callback,
      error: function() {
        self.trigger('error');
      }
    });
  },

  refresh: function() {
    this._fetch();
  },

  isCollapsed: function() {
    return this.get('collapsed');
  },

  toggleCollapsed: function() {
    this.set('collapsed', !this.get('collapsed'));
  },

  _onFilterChanged: function(filter) {
    this.trigger('change:filter', this, filter);
  },

  getData: function() {
    return this.get('data');
  },

  getPreviousData: function() {
    return this.previous('data');
  },

  fetch: function(opts) {
    this.trigger("loading", this);
    return Model.prototype.fetch.call(this,opts);
  },

  toJSON: function() {
    throw new Error('toJSON should be defined for each widget');
  }
});

},{}],107:[function(require,module,exports){
var Backbone = cdb.Backbone;
var _ = cdb._;

/**
 *  Collection that controls widget models per layer
 *
 */
module.exports = Backbone.Collection.extend({

  initialize: function() {
    this._initBinds();
  },

  _initBinds: function() {
    // If a category model applies the category colors, rest should remove/disable
    // the category colors applied before.
    this.bind('change:categoryColors', function(m, isColorCategorized) {
      if (isColorCategorized) {
        this.each(function(mdl) {
          if (mdl !== m && mdl.get('categoryColors')) {
            mdl.set('categoryColors', false);
          }
        })
      }
    }, this);

    // If a histogram model applies the histogram sizes, rest should remove/disable
    // the sizes applied before.
    this.bind('change:histogramSizes', function(m, isSizesApplied) {
      if (isSizesApplied) {
        this.each(function(mdl) {
          if (mdl !== m && mdl.get('histogramSizes')) {
            mdl.set('histogramSizes', false);
          }
        })
      }
    }, this);
  }

});

},{}],108:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var LZMA = cdb.LZMA;
var util = cdb.core.util;
var WindshaftDashboardInstance = require('./dashboard-instance');

var validatePresenceOfOptions = function(options, requiredOptions) {
  var missingOptions = _.filter(requiredOptions, function(option) {
    return !options[option];
  });
  if (missingOptions.length) {
    throw 'The following options are required: ' + missingOptions.join(', ');
  }
};

/**
 * Windshaft client. It provides a method to create instances of dashboards.
 * @param {object} options Options to set up the client
 */
WindshaftClient = function(options) {
  validatePresenceOfOptions(options, ['urlTemplate', 'userName', 'endpoint', 'statTag']);

  this.urlTemplate = options.urlTemplate;
  this.userName = options.userName;
  this.endpoint = options.endpoint;
  this.statTag = options.statTag;
  this.forceCors = options.forceCors || false;

  this.url = this.urlTemplate.replace('{user}', this.userName);
};

WindshaftClient.DEFAULT_COMPRESSION_LEVEL = 3;
WindshaftClient.MAX_GET_SIZE = 2033;

/**
 * Creates an instance of a map in Windshaft
 * @param {object} mapDefinition An object that responds to .toJSON with the definition of the map
 * @param  {function} callback A callback that will get the public or private map
 * @return {cdb.windshaft.DashboardInstance} The instance of the dashboard
 */
WindshaftClient.prototype.instantiateMap = function(options) {
  var mapDefinition = options.mapDefinition;
  var filters = options.filters;
  var successCallback = options.success;
  var errorCallback = options.error;
  var payload = JSON.stringify(mapDefinition);

  var options = {
    success: function(data) {
      if (data.errors) {
        errorCallback(data.errors[0]);
      } else {
        data.urlTemplate = this.urlTemplate;
        data.userName = this.userName;
        successCallback(new WindshaftDashboardInstance(data));
      }
    }.bind(this),
    error: function(xhr) {
      var err = { errors: ['Unknown error'] };
      try {
        err = JSON.parse(xhr.responseText);
      } catch(e) {}
      errorCallback(err.errors[0]);
    }
  };

  // TODO: Move this
  var params = [
    ["stat_tag", this.statTag].join("=")
  ];

  var filters = filters || {};
  if (Object.keys(filters).length) {
    params.push(["filters", encodeURIComponent(JSON.stringify(filters))].join('='));
  }

  if (this._usePOST(payload, params)) {
    this._post(payload, params, options);
  } else {
    this._get(payload, params, options);
  }
}

WindshaftClient.prototype._usePOST = function(payload, params) {
  if (util.isCORSSupported() && this.forceCors) {
    return true;
  }
  return payload.length >= this.constructor.MAX_GET_SIZE;
}

WindshaftClient.prototype._post = function(payload, params, options) {
  $.ajax({
    crossOrigin: true,
    method: 'POST',
    dataType: 'json',
    contentType: 'application/json',
    url: this._getURL(params),
    data: payload,
    success: options.success,
    error: options.error
  });
}

WindshaftClient.prototype._get = function(payload, params, options) {
  var compressFunction = this._getCompressor(payload);
  compressFunction(payload, this.constructor.DEFAULT_COMPRESSION_LEVEL, function(dataParameter) {
    params.push(dataParameter);
    $.ajax({
      url: this._getURL(params),
      method: 'GET',
      dataType: 'jsonp',
      jsonpCallback: this._jsonpCallbackName(payload),
      cache: true,
      success: options.success,
      error: options.error
    });
  }.bind(this));
}

WindshaftClient.prototype._getCompressor = function(payload) {
  if (payload.length < this.constructor.MAX_GET_SIZE) {
    return function(data, level, callback) {
      callback("config=" + encodeURIComponent(data));
    };
  }

  return function(data, level, callback) {
    data = JSON.stringify({ config: data });
    LZMA.compress(data, level, function(encoded) {
      callback("lzma=" + encodeURIComponent(util.array2hex(encoded)));
    });
  };
}


WindshaftClient.prototype._getURL = function(params) {
  return [this.url, this.endpoint].join('/') + '?' + params.join('&');
}

WindshaftClient.prototype._jsonpCallbackName = function(payload) {
  return '_cdbc_' + util.uniqueCallbackName(payload);
}

module.exports = WindshaftClient;

},{"./dashboard-instance":110}],109:[function(require,module,exports){
var config = {};
config.MAPS_API_BASE_URL = 'api/v1/map'

module.exports = config;

},{}],110:[function(require,module,exports){
var _ = cdb._;
var Model = cdb.core.Model;
var WindshaftConfig = require('./config');
var EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";

module.exports = Model.extend({

  TILE_EXTENSIONS_BY_LAYER_TYPE: {
    'mapnik': '.png',
    'torque': '.json.torque'
  },

  initialize: function() {

    // TODO: What params are really used?
    this.pngParams = ['map_key', 'api_key', 'cache_policy', 'updated_at'];
    this.gridParams = ['map_key', 'api_key', 'cache_policy', 'updated_at'];
  },

  isLoaded: function() {
    return !!this.get('layergroupid');
  },

  getBaseURL: function(subhost) {
    return [
      this._getHost(subhost),
      WindshaftConfig.MAPS_API_BASE_URL,
      this._getMapId(),
    ].join('/');
  },

  _getMapId: function() {
    return this.get('layergroupid');
  },

  _getHost: function(subhost) {
    var userName = this.get('userName');
    var protocol = this._useHTTPS() ? 'https' : 'http';
    var subhost = subhost ? subhost + '.' : '';
    var host = this.get('urlTemplate').replace('{user}', userName);
    var cdnHost = this.get('cdn_url') && this.get('cdn_url')[protocol];
    if (cdnHost) {
      host = [protocol, '://', subhost, cdnHost, '/', userName].join('');
    }

    return host;
  },

  _useHTTPS: function() {
    return this.get('urlTemplate').indexOf('https') === 0;
  },

  getTiles: function(layerType, params) {
    var grids = [];
    var tiles = [];

    var pngParams = this._encodeParams(params, this.pngParams);
    var gridParams = this._encodeParams(params, this.gridParams);
    var subdomains = ['0', '1', '2', '3'];

    if(this._useHTTPS()) {
      subdomains = [''];
    }

    layerType = layerType || 'mapnik';

    var layerIndexes = this._getLayerIndexesByType(layerType);
    if (layerIndexes.length) {
      var gridTemplate = '/{z}/{x}/{y}';

      for(var i = 0; i < subdomains.length; ++i) {
        var subdomain = subdomains[i];
        var tileURLTemplate = [
          this.getBaseURL(subdomain),
          '/',
          layerIndexes.join(','),
          '/{z}/{x}/{y}',
          this.TILE_EXTENSIONS_BY_LAYER_TYPE[layerType],
          (pngParams ? "?" + pngParams: '')
        ].join('');

        tiles.push(tileURLTemplate);

        // for mapnik layers add grid json too
        if (layerType === 'mapnik') {
          for(var layer = 0; layer < this.get('metadata').layers.length; ++layer) {
            var index = this._getLayerIndexByType(layer, "mapnik");
            if (index >= 0) {
              var gridURLTemplate = [
                this.getBaseURL(subdomain),
                "/",
                index,
                gridTemplate,
                ".grid.json",
                (gridParams ? "?" + gridParams: '')
              ].join("");
              grids[layer] = grids[layer] || [];
              grids[layer].push(gridURLTemplate);
            }
          }
        }
      }
    } else {
      // TODO: Clients of this method should decide what to render if no layers are present
      tiles = [EMPTY_GIF];
    }

    this.urls = {
      tiles: tiles,
      grids: grids
    };
    return this.urls;
  },

  getLayerMeta: function(layerIndex) {
    var layerMeta = {};
    var layers = this.get('metadata') && this.get('metadata').layers;
    if (layers && layers[layerIndex]) {
        layerMeta = layers[layerIndex].meta || {};
    }
    return layerMeta;
  },

  _encodeParams: function(params, included) {
    if(!params) return '';
    var url_params = [];
    included = included || _.keys(params);
    for(var i in included) {
      var k = included[i];
      var p = params[k];
      if(p) {
        if (_.isArray(p)) {
          for (var j = 0, len = p.length; j < len; j++) {
            url_params.push(k + "[]=" + encodeURIComponent(p[j]));
          }
        } else {
          var q = encodeURIComponent(p);
          q = q.replace(/%7Bx%7D/g,"{x}").replace(/%7By%7D/g,"{y}").replace(/%7Bz%7D/g,"{z}");
          url_params.push(k + "=" + q);
        }
      }
    }
    return url_params.join('&');
  },

  /**
   * Returns the index of a layer of a given type, as the tiler kwows it.
   *
   * @param {string|array} types - Type or types of layers
   */
  _getLayerIndexesByType: function(types) {
    var layers = this.get('metadata') && this.get('metadata').layers;

    if (!layers) {
      return;
    }
    var layerIndexes = [];
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var isValidType = false;
      if (types && types.length > 0) {
        isValidType = types.indexOf(layer.type) != -1;
      }
      if (isValidType) {
        layerIndexes.push(i);
      }
    }
    return layerIndexes;
  },

  /**
   * Returns the index of a layer of a given type, as the tiler kwows it.
   *
   * @param {integer} index - number of layer of the specified type
   * @param {string} layerType - type of the layers
   */
  _getLayerIndexByType: function(index, layerType) {
    var layers = this.get('metadata') && this.get('metadata').layers;

    if (!layers) {
      return index;
    }

    var tilerLayerIndex = {};
    var j = 0;
    for (var i = 0; i < layers.length; i++) {
      if (layers[i].type == layerType) {
        tilerLayerIndex[j] = i;
        j++;
      }
    }
    if (tilerLayerIndex[index] === undefined) {
      return -1;
    }
    return tilerLayerIndex[index];
  },

  getWidgetURL: function(options) {
    var widgetId = options.widgetId;
    var protocol = options.protocol;
    var url;
    var layers = this.get('metadata') && this.get('metadata').layers;

    _.each(layers, function(layer) {
      var widgets = layer.widgets;
      for (var id in widgets) {
        if (widgetId === id) {
          url = widgets[id].url[protocol];
          return;
        }
      }
    });

    return url;
  }
});

},{"./config":109}],111:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WindshaftFiltersCollection = require('./filters/collection');
var WindshaftFiltersBoundingBoxFilter = require('./filters/bounding_box');
var WindshaftDashboardInstance = require('./dashboard-instance');

var WindshaftDashboard = function(options) {
  BOUNDING_BOX_FILTER_WAIT = 500;

  this.layerGroup = options.layerGroup;
  this.layers = new Backbone.Collection(options.layers);
  this.widgets = options.widgets;
  this.map = options.map;
  this.client = options.client;
  this.statTag = options.statTag;
  this.configGenerator = options.configGenerator;

  this.instance = new WindshaftDashboardInstance();

  this.map.bind('change:center change:zoom', _.debounce(this._boundingBoxChanged, BOUNDING_BOX_FILTER_WAIT), this);

  this.layers.bind('change', this._layerChanged, this);
  this.widgets.bind('change:filter', this._filterChanged, this);

  this._createInstance();
};

WindshaftDashboard.prototype._createInstance = function(options) {
  var options = options || {};

  var dashboardConfig = this.configGenerator.generate({
    layers: this.layers.models,
    widgets: this.widgets
  });


  var filtersFromVisibleLayers = this.widgets.chain()
    .filter(function(w) { return w.layer.isVisible() })
    .map(function(w) { return w.filter })
    .compact() // not all widgets have filters
    .value();

  var filters = new WindshaftFiltersCollection(filtersFromVisibleLayers);

  this.client.instantiateMap({
    mapDefinition: dashboardConfig,
    filters: filters.toJSON(),
    success: function(dashboardInstance) {

      // Update the dashboard instance with the attributes of the new one
      this.instance.set(dashboardInstance.toJSON());

      // TODO: Set the URL of the attributes service once it's available
      this.layerGroup && this.layerGroup.set({
        baseURL: dashboardInstance.getBaseURL(),
        urls: dashboardInstance.getTiles('mapnik')
      });

      // update other kind of layers too
      this.layers.each(function(layer, layerIndex) {
        if (layer.get('type') === 'torque') {
          layer.set('meta', dashboardInstance.getLayerMeta(layerIndex));
          layer.set('urls', dashboardInstance.getTiles('torque'));
        }
      });

      this._updateWidgetURLs({
        layerId: options.layerId
      });

    }.bind(this),
    error: function(error) {
      console.log('Error creating dashboard instance: ' + error);
    }
  });

  return this.instance;
};

WindshaftDashboard.prototype._boundingBoxChanged = function() {
  if (this.instance.isLoaded()) {
    this._updateWidgetURLs();
  }
};

WindshaftDashboard.prototype._updateWidgetURLs = function(options) {
  options = options || {};
  var boundingBoxFilter = new WindshaftFiltersBoundingBoxFilter(this.map.getViewBounds());
  var boundingBox = boundingBoxFilter.toString();
  var layerId = options.layerId;

  this.widgets.each(function(widget) {
    var url = this.instance.getWidgetURL({
      widgetId: widget.get('id'),
      protocol: 'http'
    });

    var layerMeta = widget.layer.get('meta') || {};
    var extraAttrs = {};
    if (layerMeta.steps && layerMeta.column_type && _.isNumber(layerMeta.start) && _.isNumber(layerMeta.end)) {
      extraAttrs = {
        bins: layerMeta.steps,
        columnType: layerMeta.column_type,
        start: layerMeta.start  / 1000,
        end:  layerMeta.end / 1000
      };
    }

    widget.set(_.extend({
      'url': url,
      'boundingBox': boundingBox
    }, extraAttrs), {
      silent: layerId && layerId !== widget.layer.get('id')
    });
  }, this);
};

WindshaftDashboard.prototype._filterChanged = function(w) {
  this._createInstance({
    layerId: w.layer.get('id')
  });
};

WindshaftDashboard.prototype._layerChanged = function(layer) {
  var layerId = layer.get('id');
  this._createInstance({
    layerId: layerId
  });
};

module.exports = WindshaftDashboard;

},{"./dashboard-instance":110,"./filters/bounding_box":113,"./filters/collection":115}],112:[function(require,module,exports){
var Model = cdb.core.Model;

module.exports = Model.extend({

  isEmpty: function() {
    throw "Filters must implement the .isEmpty method";
  },

  toJSON: function() {
    throw "Filters must implement the .toJSON method";
  }
});

},{}],113:[function(require,module,exports){
var Model = cdb.core.Model;

module.exports = Model.extend({

  initialize: function(bounds) {
    this.setBounds(bounds);
  },

  setBounds: function(bounds) {
    this.set({
      west: bounds[0][1],
      south: bounds[0][0],
      east: bounds[1][1],
      north: bounds[1][0]
    });
  },

  toString: function() {
    return [
      this.get('west'),
      this.get('south'),
      this.get('east'),
      this.get('north')
    ].join(',');
  }
});

},{}],114:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WindshaftFilterBase = require('./base');

/**
 *  Filter used by the category widget
 *
 */
module.exports = WindshaftFilterBase.extend({

  defaults: {
    rejectAll: false
  },

  initialize: function() {
    this.rejectedCategories = new Backbone.Collection();
    this.acceptedCategories = new Backbone.Collection();
    this._initBinds();
  },

  _initBinds: function() {
    this.rejectedCategories.bind('add remove', function() {
      this.set('rejectAll', false);
    }, this);
    this.acceptedCategories.bind('add remove', function() {
      this.set('rejectAll', false);
    }, this);
  },

  isEmpty: function() {
    return this.rejectedCategories.size() === 0 && this.acceptedCategories.size() === 0 && !this.get('rejectAll');
  },

  accept: function(values, applyFilter) {
    values = !_.isArray(values) ? [values] : values;
    var acceptedCount = this.acceptedCategories.size();

    _.each(values, function(value) {
      var d = { name: value };
      var rejectedMdls = this.rejectedCategories.where(d);
      var acceptedMdls = this.acceptedCategories.where(d);
      if (rejectedMdls.length > 0) {
        this.rejectedCategories.remove(rejectedMdls);
      }
      if (!acceptedMdls.length) {
        this.acceptedCategories.add(d);
      }
    }, this);

    if (applyFilter !== false) {
      this.applyFilter();
    }
  },

  acceptAll: function() {
    this.set('rejectAll', false);
    this.cleanFilter();
  },

  isAccepted: function(name) {
    return this.acceptedCategories.where({ name: name }).length > 0;
  },

  getAccepted: function() {
    return this.acceptedCategories;
  },

  reject: function(values, applyFilter) {
    values = !_.isArray(values) ? [values] : values;

    _.each(values, function(value) {
      var d = { name: value };
      var acceptedMdls = this.acceptedCategories.where(d);
      var rejectedMdls = this.rejectedCategories.where(d);
      if (acceptedMdls.length > 0) {
        this.acceptedCategories.remove(acceptedMdls);
      } else {
        if (!rejectedMdls.length) {
          this.rejectedCategories.add(d);
        }
      }
    }, this);

    if (applyFilter !== false) {
      this.applyFilter();
    }
  },

  isRejected: function(name) {
    var rejectCount = this.rejectedCategories.size();
    var acceptCount = this.acceptedCategories.size();
    if (this.rejectedCategories.where({ name: name }).length > 0) {
      return true;
    } else if (acceptCount > 0 && this.acceptedCategories.where({ name: name }).length === 0) {
      return true;
    } else if (this.get('rejectAll')) {
      return true;
    } else {
      return false;
    }
  },

  getRejected: function() {
    return this.rejectedCategories;
  },

  rejectAll: function() {
    this.set('rejectAll', true);
    this.cleanFilter();
  },

  cleanFilter: function(triggerChange) {
    this.acceptedCategories.reset();
    this.rejectedCategories.reset();
    if (triggerChange !== false) {
      this.applyFilter();
    }
  },

  applyFilter: function() {
    this.trigger('change', this);
  },

  toJSON: function() {
    var filter = {};
    var rejectCount = this.rejectedCategories.size();
    var acceptCount = this.acceptedCategories.size();
    var acceptedCats = { accept: _.pluck(this.acceptedCategories.toJSON(), 'name') };
    var rejectedCats = { reject: _.pluck(this.rejectedCategories.toJSON(), 'name') };

    if (this.get('rejectAll')) {
      filter = { accept: [] };
    } else if (acceptCount > 0) {
      filter = acceptedCats;
    } else if (rejectCount > 0 && acceptCount === 0) {
      filter = rejectedCats;
    }

    var json = {};
    json[this.get('widgetId')] = filter;

    return json;
  }
});

},{"./base":112}],115:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;

module.exports = Backbone.Collection.extend({

  toJSON: function() {
    var json = {};
    var activeFilters = this.getActiveFilters();
    if (activeFilters.length) {
      json.layers = [];
      _.each(activeFilters, function(filter) {
        if (!filter.isEmpty()) {
          var index = filter.get('layerIndex');
          if (json.layers[index]) {
            _.extend(json.layers[index],filter.toJSON());
          } else {
            json.layers[index] = filter.toJSON();
          }
        }
      });
      // fill the holes
      for (var i = 0; i < json.layers.length; ++i) {
        json.layers[i] = json.layers[i] || {};
      }
    }

    return json;
  },

  getActiveFilters: function() {
    return this.filter(function(filter) {
      return !filter.isEmpty();
    });
  }
});

},{}],116:[function(require,module,exports){
var _ = cdb._;
var WindshaftFilterBase = require('./base');

module.exports = WindshaftFilterBase.extend({

  isEmpty: function() {
    return _.isUndefined(this.get('min')) && _.isUndefined(this.get('max'));
  },

  setRange: function(min, max) {
    this.set({
      min: min,
      max: max
    });
  },

  unsetRange: function() {
    this.setRange(undefined, undefined);
  },

  toJSON: function() {
    var json = {};
    json[this.get('widgetId')] = {
      min: this.get('min'),
      max: this.get('max'),
      column_type: this.get('columnType')
    };

    return json;
  }
});

},{"./base":112}],117:[function(require,module,exports){
var _ = cdb._;
var WindshaftPrivateDashboardConfig = {};

WindshaftPrivateDashboardConfig.generate = function(options) {
  var layers = options.layers;
  var config = {};

  _.each(layers, function(layer, index){
    config['layer' + index] = layer.isVisible() ? 1 : 0;
  });

  // TODO: We should add the params
  // TODO: We should add the auth_token
  return config;
};

module.exports = WindshaftPrivateDashboardConfig;

},{}],118:[function(require,module,exports){
var _ = cdb._;
var WindshaftPublicDashboardConfig = {};

WindshaftPublicDashboardConfig.generate = function(options) {
  var layers = options.layers;
  var widgets = options.widgets;
  var config = { layers: [] };
  _.each(layers, function(layer) {
    if (layer.isVisible()) {
      var layerConfig = {
        type: layer.get('type').toLowerCase(),
        options: {
          sql: layer.get('sql'),
          cartocss: layer.get('cartocss'),
          cartocss_version: layer.get('cartocss_version'),
          interactivity: layer.getInteractiveColumnNames()
        }
      };
      if (layer.getInfowindowFieldNames().length) {
        layerConfig.options.attributes = {
          id: "cartodb_id",
          columns: layer.getInfowindowFieldNames()
        };
      }

      layerConfig.options.widgets = {};
      var layerId = layer.get('id');
      widgets.each(function(widget) {
        if (layerId === widget.layer.get('id')) {
          layerConfig.options.widgets[widget.get('id')] = widget.toJSON();
        }
      });
      config.layers.push(layerConfig);
    }
  });

  return config;
};

module.exports = WindshaftPublicDashboardConfig;

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2NsYXNzLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9saWIvZG9tLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9saWIvZXZlbnQtbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2d1aWQuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9oZWxwZXIuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL21haW4uanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9kZWZhdWx0LXNldHRpbmcuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9jbGljay1yYWlsLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9kcmFnLXNjcm9sbGJhci5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIva2V5Ym9hcmQuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL21vdXNlLXdoZWVsLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9uYXRpdmUtc2Nyb2xsLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9zZWxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL3RvdWNoLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaW5pdGlhbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2luc3RhbmNlcy5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL3VwZGF0ZS1nZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL3VwZGF0ZS1zY3JvbGwuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi91cGRhdGUuanMiLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwic3JjL2NyZWF0ZS1kYXNoYm9hcmQuanMiLCJzcmMvZGFzaGJvYXJkLWJlbG93LW1hcC12aWV3LmpzIiwic3JjL2Rhc2hib2FyZC1pbmZvLXZpZXcuanMiLCJzcmMvZGFzaGJvYXJkLWluZm8tdmlldy50cGwiLCJzcmMvZGFzaGJvYXJkLXNpZGViYXItdmlldy5qcyIsInNyYy9kYXNoYm9hcmQtc2lkZWJhci50cGwiLCJzcmMvZGFzaGJvYXJkLXZpZXcuanMiLCJzcmMvZGFzaGJvYXJkLnRwbCIsInNyYy93aWRnZXRzL2FuaW1hdGVfdmFsdWVzLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvY29udGVudF90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9jb250ZW50X3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L2l0ZW0vaXRlbV9jbGlja2FibGVfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9pdGVtL2l0ZW1fdW5jbGlja2FibGVfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9pdGVtL2l0ZW1fdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2xpc3QvaXRlbS9zZWFyY2hfaXRlbV9jbGlja2FibGVfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9pdGVtL3NlYXJjaF9pdGVtX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L2l0ZW1zX3BsYWNlaG9sZGVyX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2xpc3QvaXRlbXNfdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2xpc3Qvc2VhcmNoX2l0ZW1zX25vX3Jlc3VsdHNfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9zZWFyY2hfaXRlbXNfdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L21vZGVsLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWxzL2NhdGVnb3JpZXNfY29sbGVjdGlvbi5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L21vZGVscy9jYXRlZ29yeV9jb2xvcnMuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9tb2RlbHMvY2F0ZWdvcnlfaXRlbV9tb2RlbC5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L21vZGVscy9jYXRlZ29yeV9tb2RlbF9yYW5nZS5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L21vZGVscy9sb2NrZWRfY2F0ZWdvcmllc19jb2xsZWN0aW9uLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWxzL3NlYXJjaF9tb2RlbC5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L29wdGlvbnMvb3B0aW9uc190ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9vcHRpb25zL29wdGlvbnNfdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L3BhZ2luYXRvci9wYWdpbmF0b3JfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvcGFnaW5hdG9yL3BhZ2luYXRvcl92aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvcGFnaW5hdG9yL3NlYXJjaF9wYWdpbmF0b3JfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvcGFnaW5hdG9yL3NlYXJjaF9wYWdpbmF0b3Jfdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L3N0YXRzL2NhdHNfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvc3RhdHMvc3RhdHNfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvc3RhdHMvc3RhdHNfdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L3RpdGxlL3NlYXJjaF90aXRsZV90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS90aXRsZS9zZWFyY2hfdGl0bGVfdmlldy5qcyIsInNyYy93aWRnZXRzL2Zvcm11bGEvYW5pbWF0aW9uX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2Zvcm11bGEvY29udGVudF92aWV3LmpzIiwic3JjL3dpZGdldHMvZm9ybXVsYS9tb2RlbC5qcyIsInNyYy93aWRnZXRzL2Zvcm11bGEvdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvaGlzdG9ncmFtL2FuaW1hdGlvbl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vY2hhcnQuanMiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vY29udGVudC12aWV3LmpzIiwic3JjL3dpZGdldHMvaGlzdG9ncmFtL2NvbnRlbnQudHBsIiwic3JjL3dpZGdldHMvaGlzdG9ncmFtL2hpc3RvZ3JhbV90aXRsZV90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vaGlzdG9ncmFtX3RpdGxlX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vbW9kZWwuanMiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vcGxhY2Vob2xkZXIudHBsIiwic3JjL3dpZGdldHMvbGlzdC9jb250ZW50X3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2xpc3QvY29udGVudF92aWV3LmpzIiwic3JjL3dpZGdldHMvbGlzdC9lZGdlc192aWV3LmpzIiwic3JjL3dpZGdldHMvbGlzdC9pdGVtX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2xpc3QvaXRlbV92aWV3LmpzIiwic3JjL3dpZGdldHMvbGlzdC9pdGVtc192aWV3LmpzIiwic3JjL3dpZGdldHMvbGlzdC9tb2RlbC5qcyIsInNyYy93aWRnZXRzL2xpc3QvcGFnaW5hdG9yX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L3BsYWNlaG9sZGVyX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9zdGFuZGFyZC93aWRnZXRfZXJyb3JfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvc3RhbmRhcmQvd2lkZ2V0X2Vycm9yX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9zdGFuZGFyZC93aWRnZXRfbG9hZGVyX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9zdGFuZGFyZC93aWRnZXRfcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvY29udGVudC12aWV3LmpzIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvaGlzdG9ncmFtLXZpZXcuanMiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy9wbGFjZWhvbGRlci50cGwiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtY29udGVudC12aWV3LmpzIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLWNvbnRyb2xzLXZpZXcuanMiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtY29udHJvbHMudHBsIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLWhpc3RvZ3JhbS12aWV3LmpzIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLXRlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS10aW1lLWluZm8tdmlldy5qcyIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS10aW1lLWluZm8udHBsIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLXRpbWUtc2xpZGVyLXZpZXcuanMiLCJzcmMvd2lkZ2V0cy93aWRnZXQtbW9kZWwtZmFjdG9yeS5qcyIsInNyYy93aWRnZXRzL3dpZGdldC10b29sdGlwLXZpZXcuanMiLCJzcmMvd2lkZ2V0cy93aWRnZXQtdmlldy1mYWN0b3J5LmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0LXZpZXcuanMiLCJzcmMvd2lkZ2V0cy93aWRnZXRfY29udGVudF9tb2RlbC5qcyIsInNyYy93aWRnZXRzL3dpZGdldF9tb2RlbC5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMtY29sbGVjdGlvbi5qcyIsInNyYy93aW5kc2hhZnQvY2xpZW50LmpzIiwic3JjL3dpbmRzaGFmdC9jb25maWcuanMiLCJzcmMvd2luZHNoYWZ0L2Rhc2hib2FyZC1pbnN0YW5jZS5qcyIsInNyYy93aW5kc2hhZnQvZGFzaGJvYXJkLmpzIiwic3JjL3dpbmRzaGFmdC9maWx0ZXJzL2Jhc2UuanMiLCJzcmMvd2luZHNoYWZ0L2ZpbHRlcnMvYm91bmRpbmdfYm94LmpzIiwic3JjL3dpbmRzaGFmdC9maWx0ZXJzL2NhdGVnb3J5LmpzIiwic3JjL3dpbmRzaGFmdC9maWx0ZXJzL2NvbGxlY3Rpb24uanMiLCJzcmMvd2luZHNoYWZ0L2ZpbHRlcnMvcmFuZ2UuanMiLCJzcmMvd2luZHNoYWZ0L3ByaXZhdGUtZGFzaGJvYXJkLWNvbmZpZy5qcyIsInNyYy93aW5kc2hhZnQvcHVibGljLWRhc2hib2FyZC1jb25maWcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW5HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25jQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlRGFzaGJvYXJkOiByZXF1aXJlKCcuL3NyYy9jcmVhdGUtZGFzaGJvYXJkJylcbn07XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTAuNlxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiB1dGlsc19ob29rc19faG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfdXRjX19jcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19pc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZDtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBtLl9pc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2NyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gdXRpbHNfaG9va3NfX2hvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2lzQU1vbWVudE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9zdHJpY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fdHptICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2lzVVRDICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9vZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fcGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9sb2NhbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpIGluIG1vbWVudFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoKSB7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZVxuICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gdW5kbyB0aGF0IGZvciBsYXp5IGxvYWRlZCBsb2NhbGVzXG4gICAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWVzLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0gfHwgbmV3IExvY2FsZSgpO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQodmFsdWVzKTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19nZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fc2V0IChtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIHZhciB1bml0O1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh1bml0IGluIHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQodW5pdCwgdW5pdHNbdW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbdW5pdHNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFF8WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbiAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxuICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbiAgICB2YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbiAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIHZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuICAgIHZhciByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChzdGgpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIzMjVcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGggPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdGgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIG1hdGNoV29yZCk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIGhlcmUhXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcblxuICAgIHZhciBmcm9tX3N0cmluZ19faXNvUmVnZXggPSAvXlxccyooPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86KFxcZFxcZC1cXGRcXGQpfChXXFxkXFxkJCl8KFdcXGRcXGQtXFxkKXwoXFxkXFxkXFxkKSkoKFR8ICkoXFxkXFxkKDpcXGRcXGQoOlxcZFxcZChcXC5cXGQrKT8pPyk/KT8oW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZHsyfS1cXGR7Mn0vXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkezJ9LVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGR7Mn0vXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIOm1tJywgLyhUfCApXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgLyhUfCApXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBmcm9tX3N0cmluZ19faXNvUmVnZXguZXhlYyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFs2XSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSAobWF0Y2hbNl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKG1hdGNoT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSAnWic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZS4gVGhpcyBpcyAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdXBjb21pbmcgbWFqb3IgJyArXG4gICAgICAgICdyZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQwNyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy9jYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MTM0OC9pbnN0YW50aWF0aW5nLWEtamF2YXNjcmlwdC1vYmplY3QtYnktY2FsbGluZy1wcm90b3R5cGUtY29uc3RydWN0b3ItYXBwbHlcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAgICAgLy90aGUgZGF0ZSBjb25zdHJ1Y3RvciBkb2Vzbid0IGFjY2VwdCB5ZWFycyA8IDE5NzBcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIGZhbHNlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIGZpcnN0RGF5T2ZXZWVrICAgICAgIDAgPSBzdW4sIDYgPSBzYXRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZGF5IG9mIHRoZSB3ZWVrIHRoYXQgc3RhcnRzIHRoZSB3ZWVrXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgKHVzdWFsbHkgc3VuZGF5IG9yIG1vbmRheSlcbiAgICAvLyBmaXJzdERheU9mV2Vla09mWWVhciAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IHdlZWsgaXMgdGhlIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICBvZiB0aGlzIGRheSBvZiB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIChlZy4gSVNPIHdlZWtzIHVzZSB0aHVyc2RheSAoNCkpXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGZpcnN0RGF5T2ZXZWVrLCBmaXJzdERheU9mV2Vla09mWWVhcikge1xuICAgICAgICB2YXIgZW5kID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBmaXJzdERheU9mV2VlayxcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gbW9tLmRheSgpLFxuICAgICAgICAgICAgYWRqdXN0ZWRNb21lbnQ7XG5cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrID4gZW5kKSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgLT0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPCBlbmQgLSA3KSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdGVkTW9tZW50ID0gbG9jYWxfX2NyZWF0ZUxvY2FsKG1vbSkuYWRkKGRheXNUb0RheU9mV2VlaywgJ2QnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IE1hdGguY2VpbChhZGp1c3RlZE1vbWVudC5kYXlPZlllYXIoKSAvIDcpLFxuICAgICAgICAgICAgeWVhcjogYWRqdXN0ZWRNb21lbnQueWVhcigpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyLCBmaXJzdERheU9mV2Vlaykge1xuICAgICAgICB2YXIgd2VlazFKYW4gPSA2ICsgZmlyc3REYXlPZldlZWsgLSBmaXJzdERheU9mV2Vla09mWWVhciwgamFuWCA9IGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgMSArIHdlZWsxSmFuKSwgZCA9IGphblguZ2V0VVRDRGF5KCksIGRheU9mWWVhcjtcbiAgICAgICAgaWYgKGQgPCBmaXJzdERheU9mV2Vlaykge1xuICAgICAgICAgICAgZCArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgd2Vla2RheSA9IHdlZWtkYXkgIT0gbnVsbCA/IDEgKiB3ZWVrZGF5IDogZmlyc3REYXlPZldlZWs7XG5cbiAgICAgICAgZGF5T2ZZZWFyID0gMSArIHdlZWsxSmFuICsgNyAqICh3ZWVrIC0gMSkgLSBkICsgd2Vla2RheTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogZGF5T2ZZZWFyID4gMCA/IHllYXIgOiB5ZWFyIC0gMSxcbiAgICAgICAgICAgIGRheU9mWWVhcjogZGF5T2ZZZWFyID4gMCA/ICBkYXlPZlllYXIgOiBkYXlzSW5ZZWFyKHllYXIgLSAxKSArIGRheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93LmdldFVUQ0Z1bGxZZWFyKCksIG5vdy5nZXRVVENNb250aCgpLCBub3cuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXA7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICsrd2VlaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3ksIGRvdyk7XG5cbiAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK2lucHV0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxfX2NyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgfVxuICAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAzNmU1OyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hPZmZzZXQpIHx8IFtdKTtcbiAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpKSAtICgrcmVzKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKCtyZXMuX2QgKyBkaWZmKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KG9mZnNldEZyb21TdHJpbmcodGhpcy5faSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpbnB1dCA9IGlucHV0ID8gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faXNEU1RTaGlmdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKGMuX2EpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2lzVVRDO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMDtcbiAgICB9XG5cbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvKFxcLSk/KD86KFxcZCopXFwuKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKylcXC4/KFxcZHszfSk/KT8vO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgdmFyIGNyZWF0ZV9faXNvUmVnZXggPSAvXigtKT9QKD86KD86KFswLTksLl0qKVkpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopRCk/KD86VCg/OihbMC05LC5dKilIKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKVMpPyk/fChbMC05LC5dKilXKSQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlX19jcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtcyA6IHRvSW50KG1hdGNoW01JTExJU0VDT05EXSkgKiBzaWduXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gY3JlYXRlX19pc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgbG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBkdXJhdGlvbi5fZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyA9IGR1cmF0aW9uLl9tb250aHM7XG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZSgrbW9tLl9kICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBnZXRfc2V0X19zZXQobW9tLCAnRGF0ZScsIGdldF9zZXRfX2dldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0X3NldF9fZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGRfc3VidHJhY3RfX2FkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgIHZhciBhZGRfc3VidHJhY3RfX3N1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X2NhbGVuZGFyX19jYWxlbmRhciAodGltZSwgZm9ybWF0cykge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgbG9jYWxfX2NyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmYoc29kLCAnZGF5cycsIHRydWUpLFxuICAgICAgICAgICAgZm9ybWF0ID0gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGZvcm1hdHMgJiYgZm9ybWF0c1tmb3JtYXRdIHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh0eXBlb2YgdW5pdHMgIT09ICd1bmRlZmluZWQnID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA+ICtpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBpc01vbWVudChpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dE1zIDwgK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPCAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5lbmRPZih1bml0cykgPCBpbnB1dE1zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgJiYgdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzID09PSAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gKyh0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSArKHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKSxcbiAgICAgICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQsXG4gICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3llYXInIHx8IHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgICAgIG91dHB1dCA9IHVuaXRzID09PSAnc2Vjb25kJyA/IGRlbHRhIC8gMWUzIDogLy8gMTAwMFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnbWludXRlJyA/IGRlbHRhIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdob3VyJyA/IGRlbHRhIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdkYXknID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDg2NGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gNjA0OGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCk7XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmcgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcbiAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyB8fCB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b190eXBlX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuICt0aGlzLl9kIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCt0aGlzIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCA/IG5ldyBEYXRlKCt0aGlzKSA6IHRoaXMuX2Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfdmFsaWRfX2lzVmFsaWQgKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRfX2lzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKFt5ZWFyLCAxMSwgMzEgKyBkb3cgLSBkb3ldKSwgZG93LCBkb3kpLndlZWs7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciB5ZWFyID0gd2Vla09mWWVhcih0aGlzLCB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSkueWVhcjtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciB5ZWFyID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS55ZWFyO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSB5ZWFyKSwgJ3knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAwLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBsb2NhbGUuX29yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBtYXRjaFdvcmQpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZykge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lKSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSB0aGlzLl93ZWVrZGF5c1BhcnNlIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gbG9jYWxfX2NyZWF0ZUxvY2FsKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHRoaXMuZGF5KCkgfHwgNyA6IHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gaW5wdXQgOiBpbnB1dCAtIDcpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZV9fcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX2FkZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICA9IG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jbG9uZSAgICAgICAgPSBjbG9uZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRpZmYgICAgICAgICA9IGRpZmY7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5lbmRPZiAgICAgICAgPSBlbmRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZvcm1hdCAgICAgICA9IGZvcm1hdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb20gICAgICAgICA9IGZyb207XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tTm93ICAgICAgPSBmcm9tTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG8gICAgICAgICAgID0gdG87XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b05vdyAgICAgICAgPSB0b05vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmludmFsaWRBdCAgICA9IGludmFsaWRBdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQWZ0ZXIgICAgICA9IGlzQWZ0ZXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JlZm9yZSAgICAgPSBpc0JlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmV0d2VlbiAgICA9IGlzQmV0d2VlbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZSAgICAgICA9IGlzU2FtZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVmFsaWQgICAgICA9IG1vbWVudF92YWxpZF9faXNWYWxpZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxhbmcgICAgICAgICA9IGxhbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgPSBsb2NhbGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgPSBsb2NhbGVEYXRhO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWF4ICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWluICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2luZ0ZsYWdzID0gcGFyc2luZ0ZsYWdzO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgID0gZ2V0U2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3RhcnRPZiAgICAgID0gc3RhcnRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICA9IGFkZF9zdWJ0cmFjdF9fc3VidHJhY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0FycmF5ICAgICAgPSB0b0FycmF5O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9PYmplY3QgICAgID0gdG9PYmplY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0RhdGUgICAgICAgPSB0b0RhdGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICA9IG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgID0gdG9TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51bml4ICAgICAgICAgPSB1bml4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgID0gdG9fdHlwZV9fdmFsdWVPZjtcblxuICAgIC8vIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbiAgICAvLyBXZWVrIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4gICAgLy8gUXVhcnRlclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4gICAgLy8gTW9udGhcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4gICAgLy8gV2Vla1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2VlayAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4gICAgLy8gRGF5XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheSAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbiAgICAvLyBIb3VyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbiAgICAvLyBNaW51dGVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuICAgIC8vIFNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4gICAgLy8gTWlsbGlzZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuICAgIC8vIE9mZnNldFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1RTaGlmdGVkICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAvLyBUaW1lem9uZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTc3OScsIGdldFNldFpvbmUpO1xuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG87XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV07XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0T3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgIGZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlX19yZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAodHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfc2V0X19zZXQgKGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfb3JkaW5hbFBhcnNlTGVuaWVudC5cbiAgICAgICAgdGhpcy5fb3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAodGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSArICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVfX3Byb3RvID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8uX2NhbGVuZGFyICAgICAgID0gZGVmYXVsdENhbGVuZGFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgID0gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9sb25nRGF0ZUZvcm1hdCA9IGRlZmF1bHRMb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX2ludmFsaWREYXRlICAgID0gZGVmYXVsdEludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbCAgICAgICAgPSBkZWZhdWx0T3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbFBhcnNlICAgPSBkZWZhdWx0T3JkaW5hbFBhcnNlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3JlbGF0aXZlVGltZSAgID0gZGVmYXVsdFJlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlX19yZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgID0gbG9jYWxlX3NldF9fc2V0O1xuXG4gICAgLy8gTW9udGhcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzICAgICAgPSBkZWZhdWx0TG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnQgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRoc1Nob3J0ID0gZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUGFyc2UgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuXG4gICAgLy8gV2Vla1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2VlayA9IGRlZmF1bHRMb2NhbGVXZWVrO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICAvLyBEYXkgb2YgV2Vla1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXMgICAgICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzTWluICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzU2hvcnQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICAvLyBIb3Vyc1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG90eXBlX19wcm90by5fbWVyaWRpZW1QYXJzZSA9IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGxpc3RzX19nZXQgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3QgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBjb3VudCwgc2V0dGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGxpc3RzX19nZXQoZm9ybWF0LCBpLCBmaWVsZCwgc2V0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICdtb250aHMnLCAxMiwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnLCAxMiwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5cyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0JywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNNaW4gKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUpO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2Fic19fYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FzX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2dldF9fZ2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHMgKyAncyddKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzOiA0NSwgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG06IDQ1LCAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGg6IDIyLCAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQ6IDI2LCAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNOiAxMSAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA9PT0gMSAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPT09IDEgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgID09PSAxICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA9PT0gMSAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPT09IDEgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgaXNvX3N0cmluZ19fYWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBpc29fc3RyaW5nX190b0lTT1N0cmluZygpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIHZhciBzZWNvbmRzID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFicyAgICAgICAgICAgID0gZHVyYXRpb25fYWJzX19hYnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXMgICAgICAgICAgICAgPSBhcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgPSBkdXJhdGlvbl9hc19fdmFsdWVPZjtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgPSBkdXJhdGlvbl9nZXRfX2dldDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnZlcnNpb24gPSAnMi4xMC42JztcblxuICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQztcbiAgICB1dGlsc19ob29rc19faG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVVbml4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRocztcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSB2YWxpZF9fY3JlYXRlSW52YWxpZDtcbiAgICB1dGlsc19ob29rc19faG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlSW5ab25lO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRoc1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzTWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG5cbiAgICB2YXIgX21vbWVudCA9IHV0aWxzX2hvb2tzX19ob29rcztcblxuICAgIHJldHVybiBfbW9tZW50O1xuXG59KSk7IiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL2pzL21haW4nKTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2xkQWRkKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICB2YXIgY2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA8IDApIHtcbiAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgfVxuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBvbGRSZW1vdmUoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgdmFyIGlkeCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICBpZiAoaWR4ID49IDApIHtcbiAgICBjbGFzc2VzLnNwbGljZShpZHgsIDEpO1xuICB9XG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG59XG5cbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBvbGRBZGQoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIG9sZFJlbW92ZShlbGVtZW50LCBjbGFzc05hbWUpO1xuICB9XG59O1xuXG5leHBvcnRzLmxpc3QgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVsZW1lbnQuY2xhc3NMaXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgfVxufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHt9O1xuXG5ET00uZSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5ET00uYXBwZW5kVG8gPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuXG5mdW5jdGlvbiBjc3NHZXQoZWxlbWVudCwgc3R5bGVOYW1lKSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtzdHlsZU5hbWVdO1xufVxuXG5mdW5jdGlvbiBjc3NTZXQoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBzdHlsZVZhbHVlID0gc3R5bGVWYWx1ZS50b1N0cmluZygpICsgJ3B4JztcbiAgfVxuICBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3NzTXVsdGlTZXQoZWxlbWVudCwgb2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWwgPSB2YWwudG9TdHJpbmcoKSArICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IHZhbDtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuRE9NLmNzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCwgc3R5bGVWYWx1ZSkge1xuICBpZiAodHlwZW9mIHN0eWxlTmFtZU9yT2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIC8vIG11bHRpcGxlIHNldCB3aXRoIG9iamVjdFxuICAgIHJldHVybiBjc3NNdWx0aVNldChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGNzc0dldChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjc3NTZXQoZWxlbWVudCwgc3R5bGVOYW1lT3JPYmplY3QsIHN0eWxlVmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuRE9NLm1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgcXVlcnkpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50Lm1hdGNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhxdWVyeSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50Lm1hdGNoZXNTZWxlY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXNTZWxlY3RvcihxdWVyeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yKHF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xuICAgIH1cbiAgfVxufTtcblxuRE9NLnJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5yZW1vdmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG5ET00ucXVlcnlDaGlsZHJlbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIERPTS5tYXRjaGVzKGNoaWxkLCBzZWxlY3Rvcik7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET007XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmV2ZW50cyA9IHt9O1xufTtcblxuRXZlbnRFbGVtZW50LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICBpZiAodHlwZW9mIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICB9XG4gIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVsZW1lbnQucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIGlzSGFuZGxlclByb3ZpZGVkID0gKHR5cGVvZiBoYW5kbGVyICE9PSAndW5kZWZpbmVkJyk7XG4gIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmZpbHRlcihmdW5jdGlvbiAoaGRscikge1xuICAgIGlmIChpc0hhbmRsZXJQcm92aWRlZCAmJiBoZGxyICE9PSBoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoZGxyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCB0aGlzKTtcbn07XG5cbkV2ZW50RWxlbWVudC5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMuZXZlbnRzKSB7XG4gICAgdGhpcy51bmJpbmQobmFtZSk7XG4gIH1cbn07XG5cbnZhciBFdmVudE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5ldmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgZWUgPSB0aGlzLmV2ZW50RWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gZXZlbnRFbGVtZW50LmVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gIH0pWzBdO1xuICBpZiAodHlwZW9mIGVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGVlID0gbmV3IEV2ZW50RWxlbWVudChlbGVtZW50KTtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHMucHVzaChlZSk7XG4gIH1cbiAgcmV0dXJuIGVlO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICB0aGlzLmV2ZW50RWxlbWVudChlbGVtZW50KS5iaW5kKGV2ZW50TmFtZSwgaGFuZGxlcik7XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCkudW5iaW5kKGV2ZW50TmFtZSwgaGFuZGxlcik7XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHNbaV0udW5iaW5kQWxsKCk7XG4gIH1cbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciBvbmNlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZWUudW5iaW5kKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIpO1xuICAgIGhhbmRsZXIoZSk7XG4gIH07XG4gIGVlLmJpbmQoZXZlbnROYW1lLCBvbmNlSGFuZGxlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TWFuYWdlcjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzNCgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArXG4gICAgICAgICAgIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH07XG59KSgpO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xzID0gcmVxdWlyZSgnLi9jbGFzcycpXG4gICwgZCA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbmV4cG9ydHMudG9JbnQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gcGFyc2VJbnQoeCwgMTApIHx8IDA7XG59O1xuXG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLmNsb25lKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgc291cmNlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKG9yaWdpbmFsKTtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIHJlc3VsdFtrZXldID0gdGhpcy5jbG9uZShzb3VyY2Vba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydHMuaXNFZGl0YWJsZSA9IGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZC5tYXRjaGVzKGVsLCBcImlucHV0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8XG4gICAgICAgICBkLm1hdGNoZXMoZWwsIFwic2VsZWN0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8XG4gICAgICAgICBkLm1hdGNoZXMoZWwsIFwidGV4dGFyZWEsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHxcbiAgICAgICAgIGQubWF0Y2hlcyhlbCwgXCJidXR0b24sW2NvbnRlbnRlZGl0YWJsZV1cIik7XG59O1xuXG5leHBvcnRzLnJlbW92ZVBzQ2xhc3NlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBjbHNMaXN0ID0gY2xzLmxpc3QoZWxlbWVudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2xzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjbGFzc05hbWUgPSBjbHNMaXN0W2ldO1xuICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZigncHMtJykgPT09IDApIHtcbiAgICAgIGNscy5yZW1vdmUoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMub3V0ZXJXaWR0aCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiB0aGlzLnRvSW50KGQuY3NzKGVsZW1lbnQsICd3aWR0aCcpKSArXG4gICAgICAgICB0aGlzLnRvSW50KGQuY3NzKGVsZW1lbnQsICdwYWRkaW5nTGVmdCcpKSArXG4gICAgICAgICB0aGlzLnRvSW50KGQuY3NzKGVsZW1lbnQsICdwYWRkaW5nUmlnaHQnKSkgK1xuICAgICAgICAgdGhpcy50b0ludChkLmNzcyhlbGVtZW50LCAnYm9yZGVyTGVmdFdpZHRoJykpICtcbiAgICAgICAgIHRoaXMudG9JbnQoZC5jc3MoZWxlbWVudCwgJ2JvcmRlclJpZ2h0V2lkdGgnKSk7XG59O1xuXG5leHBvcnRzLnN0YXJ0U2Nyb2xsaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF4aXMpIHtcbiAgY2xzLmFkZChlbGVtZW50LCAncHMtaW4tc2Nyb2xsaW5nJyk7XG4gIGlmICh0eXBlb2YgYXhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjbHMuYWRkKGVsZW1lbnQsICdwcy0nICsgYXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgY2xzLmFkZChlbGVtZW50LCAncHMteCcpO1xuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLXknKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zdG9wU2Nyb2xsaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF4aXMpIHtcbiAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMtaW4tc2Nyb2xsaW5nJyk7XG4gIGlmICh0eXBlb2YgYXhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy0nICsgYXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMteCcpO1xuICAgIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLXknKTtcbiAgfVxufTtcblxuZXhwb3J0cy5lbnYgPSB7XG4gIGlzV2ViS2l0OiAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICBzdXBwb3J0c1RvdWNoOiAoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCksXG4gIHN1cHBvcnRzSWVQb2ludGVyOiB3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgIT09IG51bGxcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZXN0cm95ID0gcmVxdWlyZSgnLi9wbHVnaW4vZGVzdHJveScpXG4gICwgaW5pdGlhbGl6ZSA9IHJlcXVpcmUoJy4vcGx1Z2luL2luaXRpYWxpemUnKVxuICAsIHVwZGF0ZSA9IHJlcXVpcmUoJy4vcGx1Z2luL3VwZGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZSxcbiAgdXBkYXRlOiB1cGRhdGUsXG4gIGRlc3Ryb3k6IGRlc3Ryb3lcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXhTY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIG1pblNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgc2Nyb2xsWE1hcmdpbk9mZnNldDogMCxcbiAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcbiAgc3RvcFByb3BhZ2F0aW9uT25DbGljazogdHJ1ZSxcbiAgc3VwcHJlc3NTY3JvbGxYOiBmYWxzZSxcbiAgc3VwcHJlc3NTY3JvbGxZOiBmYWxzZSxcbiAgc3dpcGVQcm9wYWdhdGlvbjogdHJ1ZSxcbiAgdXNlQm90aFdoZWVsQXhlczogZmFsc2UsXG4gIHVzZUtleWJvYXJkOiB0cnVlLFxuICB1c2VTZWxlY3Rpb25TY3JvbGw6IGZhbHNlLFxuICB3aGVlbFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgd2hlZWxTcGVlZDogMVxufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGQgPSByZXF1aXJlKCcuLi9saWIvZG9tJylcbiAgLCBoID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG5cbiAgaWYgKCFpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaS5ldmVudC51bmJpbmRBbGwoKTtcbiAgZC5yZW1vdmUoaS5zY3JvbGxiYXJYKTtcbiAgZC5yZW1vdmUoaS5zY3JvbGxiYXJZKTtcbiAgZC5yZW1vdmUoaS5zY3JvbGxiYXJYUmFpbCk7XG4gIGQucmVtb3ZlKGkuc2Nyb2xsYmFyWVJhaWwpO1xuICBoLnJlbW92ZVBzQ2xhc3NlcyhlbGVtZW50KTtcblxuICBpbnN0YW5jZXMucmVtb3ZlKGVsZW1lbnQpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5JylcbiAgLCB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XG5cbmZ1bmN0aW9uIGJpbmRDbGlja1JhaWxIYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgZnVuY3Rpb24gcGFnZU9mZnNldChlbCkge1xuICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICB2YXIgc3RvcFByb3BhZ2F0aW9uID0gd2luZG93LkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24uYmluZDtcblxuICBpZiAoaS5zZXR0aW5ncy5zdG9wUHJvcGFnYXRpb25PbkNsaWNrKSB7XG4gICAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWSwgJ2NsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcbiAgfVxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZUmFpbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoID0gaC50b0ludChpLnNjcm9sbGJhcllIZWlnaHQgLyAyKTtcbiAgICB2YXIgcG9zaXRpb25Ub3AgPSBpLnJhaWxZUmF0aW8gKiAoZS5wYWdlWSAtIHdpbmRvdy5zY3JvbGxZIC0gcGFnZU9mZnNldChpLnNjcm9sbGJhcllSYWlsKS50b3AgLSBoYWxmT2ZTY3JvbGxiYXJMZW5ndGgpO1xuICAgIHZhciBtYXhQb3NpdGlvblRvcCA9IGkucmFpbFlSYXRpbyAqIChpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KTtcbiAgICB2YXIgcG9zaXRpb25SYXRpbyA9IHBvc2l0aW9uVG9wIC8gbWF4UG9zaXRpb25Ub3A7XG5cbiAgICBpZiAocG9zaXRpb25SYXRpbyA8IDApIHtcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAwO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25SYXRpbyA+IDEpIHtcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAxO1xuICAgIH1cblxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgKGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSAqIHBvc2l0aW9uUmF0aW8pO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG5cbiAgaWYgKGkuc2V0dGluZ3Muc3RvcFByb3BhZ2F0aW9uT25DbGljaykge1xuICAgIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclgsICdjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XG4gIH1cbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWFJhaWwsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGhhbGZPZlNjcm9sbGJhckxlbmd0aCA9IGgudG9JbnQoaS5zY3JvbGxiYXJYV2lkdGggLyAyKTtcbiAgICB2YXIgcG9zaXRpb25MZWZ0ID0gaS5yYWlsWFJhdGlvICogKGUucGFnZVggLSB3aW5kb3cuc2Nyb2xsWCAtIHBhZ2VPZmZzZXQoaS5zY3JvbGxiYXJYUmFpbCkubGVmdCAtIGhhbGZPZlNjcm9sbGJhckxlbmd0aCk7XG4gICAgdmFyIG1heFBvc2l0aW9uTGVmdCA9IGkucmFpbFhSYXRpbyAqIChpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aCk7XG4gICAgdmFyIHBvc2l0aW9uUmF0aW8gPSBwb3NpdGlvbkxlZnQgLyBtYXhQb3NpdGlvbkxlZnQ7XG5cbiAgICBpZiAocG9zaXRpb25SYXRpbyA8IDApIHtcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAwO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25SYXRpbyA+IDEpIHtcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAxO1xuICAgIH1cblxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsICgoaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSAqIHBvc2l0aW9uUmF0aW8pIC0gaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQpO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kQ2xpY2tSYWlsSGFuZGxlcihlbGVtZW50LCBpKTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkID0gcmVxdWlyZSgnLi4vLi4vbGliL2RvbScpXG4gICwgaCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKVxuICAsIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcblxuZnVuY3Rpb24gYmluZE1vdXNlU2Nyb2xsWEhhbmRsZXIoZWxlbWVudCwgaSkge1xuICB2YXIgY3VycmVudExlZnQgPSBudWxsO1xuICB2YXIgY3VycmVudFBhZ2VYID0gbnVsbDtcblxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxMZWZ0KGRlbHRhWCkge1xuICAgIHZhciBuZXdMZWZ0ID0gY3VycmVudExlZnQgKyAoZGVsdGFYICogaS5yYWlsWFJhdGlvKTtcbiAgICB2YXIgbWF4TGVmdCA9IGkuc2Nyb2xsYmFyWFJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIChpLnJhaWxYUmF0aW8gKiAoaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpKTtcblxuICAgIGlmIChuZXdMZWZ0IDwgMCkge1xuICAgICAgaS5zY3JvbGxiYXJYTGVmdCA9IDA7XG4gICAgfSBlbHNlIGlmIChuZXdMZWZ0ID4gbWF4TGVmdCkge1xuICAgICAgaS5zY3JvbGxiYXJYTGVmdCA9IG1heExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkuc2Nyb2xsYmFyWExlZnQgPSBuZXdMZWZ0O1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxMZWZ0ID0gaC50b0ludChpLnNjcm9sbGJhclhMZWZ0ICogKGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkgLyAoaS5jb250YWluZXJXaWR0aCAtIChpLnJhaWxYUmF0aW8gKiBpLnNjcm9sbGJhclhXaWR0aCkpKSAtIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50O1xuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIHNjcm9sbExlZnQpO1xuICB9XG5cbiAgdmFyIG1vdXNlTW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHVwZGF0ZVNjcm9sbExlZnQoZS5wYWdlWCAtIGN1cnJlbnRQYWdlWCk7XG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgdmFyIG1vdXNlVXBIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGguc3RvcFNjcm9sbGluZyhlbGVtZW50LCAneCcpO1xuICAgIGkuZXZlbnQudW5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICB9O1xuXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclgsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGN1cnJlbnRQYWdlWCA9IGUucGFnZVg7XG4gICAgY3VycmVudExlZnQgPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWCwgJ2xlZnQnKSkgKiBpLnJhaWxYUmF0aW87XG4gICAgaC5zdGFydFNjcm9sbGluZyhlbGVtZW50LCAneCcpO1xuXG4gICAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIGkuZXZlbnQub25jZShpLm93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBiaW5kTW91c2VTY3JvbGxZSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIHZhciBjdXJyZW50VG9wID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRQYWdlWSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsVG9wKGRlbHRhWSkge1xuICAgIHZhciBuZXdUb3AgPSBjdXJyZW50VG9wICsgKGRlbHRhWSAqIGkucmFpbFlSYXRpbyk7XG4gICAgdmFyIG1heFRvcCA9IGkuc2Nyb2xsYmFyWVJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgKGkucmFpbFlSYXRpbyAqIChpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSk7XG5cbiAgICBpZiAobmV3VG9wIDwgMCkge1xuICAgICAgaS5zY3JvbGxiYXJZVG9wID0gMDtcbiAgICB9IGVsc2UgaWYgKG5ld1RvcCA+IG1heFRvcCkge1xuICAgICAgaS5zY3JvbGxiYXJZVG9wID0gbWF4VG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBpLnNjcm9sbGJhcllUb3AgPSBuZXdUb3A7XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbFRvcCA9IGgudG9JbnQoaS5zY3JvbGxiYXJZVG9wICogKGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSAvIChpLmNvbnRhaW5lckhlaWdodCAtIChpLnJhaWxZUmF0aW8gKiBpLnNjcm9sbGJhcllIZWlnaHQpKSk7XG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBzY3JvbGxUb3ApO1xuICB9XG5cbiAgdmFyIG1vdXNlTW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHVwZGF0ZVNjcm9sbFRvcChlLnBhZ2VZIC0gY3VycmVudFBhZ2VZKTtcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaC5zdG9wU2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XG4gICAgaS5ldmVudC51bmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG4gIH07XG5cbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWSwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgY3VycmVudFBhZ2VZID0gZS5wYWdlWTtcbiAgICBjdXJyZW50VG9wID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclksICd0b3AnKSkgKiBpLnJhaWxZUmF0aW87XG4gICAgaC5zdGFydFNjcm9sbGluZyhlbGVtZW50LCAneScpO1xuXG4gICAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIGkuZXZlbnQub25jZShpLm93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZE1vdXNlU2Nyb2xsWEhhbmRsZXIoZWxlbWVudCwgaSk7XG4gIGJpbmRNb3VzZVNjcm9sbFlIYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5JylcbiAgLCB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XG5cbmZ1bmN0aW9uIGJpbmRLZXlib2FyZEhhbmRsZXIoZWxlbWVudCwgaSkge1xuICB2YXIgaG92ZXJlZCA9IGZhbHNlO1xuICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgaG92ZXJlZCA9IHRydWU7XG4gIH0pO1xuICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgaG92ZXJlZCA9IGZhbHNlO1xuICB9KTtcblxuICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xuICBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICBpZiAoZGVsdGFYID09PSAwKSB7XG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKHNjcm9sbFRvcCA9PT0gMCAmJiBkZWx0YVkgPiAwKSB8fCAoc2Nyb2xsVG9wID49IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0ICYmIGRlbHRhWSA8IDApKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGlmIChkZWx0YVkgPT09IDApIHtcbiAgICAgIGlmICghaS5zY3JvbGxiYXJYQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgoc2Nyb2xsTGVmdCA9PT0gMCAmJiBkZWx0YVggPCAwKSB8fCAoc2Nyb2xsTGVmdCA+PSBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGggJiYgZGVsdGFYID4gMCkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCAmJiBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFob3ZlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IGkub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChhY3RpdmVFbGVtZW50KSB7XG4gICAgICAvLyBnbyBkZWVwZXIgaWYgZWxlbWVudCBpcyBhIHdlYmNvbXBvbmVudFxuICAgICAgd2hpbGUgKGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoaC5pc0VkaXRhYmxlKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVsdGFYID0gMDtcbiAgICB2YXIgZGVsdGFZID0gMDtcblxuICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgIGNhc2UgMzc6IC8vIGxlZnRcbiAgICAgIGRlbHRhWCA9IC0zMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzg6IC8vIHVwXG4gICAgICBkZWx0YVkgPSAzMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzk6IC8vIHJpZ2h0XG4gICAgICBkZWx0YVggPSAzMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDA6IC8vIGRvd25cbiAgICAgIGRlbHRhWSA9IC0zMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzM6IC8vIHBhZ2UgdXBcbiAgICAgIGRlbHRhWSA9IDkwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzMjogLy8gc3BhY2UgYmFyXG4gICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICBkZWx0YVkgPSA5MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhWSA9IC05MDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzQ6IC8vIHBhZ2UgZG93blxuICAgICAgZGVsdGFZID0gLTkwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzNTogLy8gZW5kXG4gICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgIGRlbHRhWSA9IC1pLmNvbnRlbnRIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YVkgPSAtaS5jb250YWluZXJIZWlnaHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM2OiAvLyBob21lXG4gICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgIGRlbHRhWSA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGFZID0gaS5jb250YWluZXJIZWlnaHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgLSBkZWx0YVkpO1xuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCArIGRlbHRhWCk7XG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG5cbiAgICBzaG91bGRQcmV2ZW50ID0gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpO1xuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIGJpbmRLZXlib2FyZEhhbmRsZXIoZWxlbWVudCwgaSk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKVxuICAsIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcblxuZnVuY3Rpb24gYmluZE1vdXNlV2hlZWxIYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgdmFyIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICBpZiAoZGVsdGFYID09PSAwKSB7XG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKHNjcm9sbFRvcCA9PT0gMCAmJiBkZWx0YVkgPiAwKSB8fCAoc2Nyb2xsVG9wID49IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0ICYmIGRlbHRhWSA8IDApKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGlmIChkZWx0YVkgPT09IDApIHtcbiAgICAgIGlmICghaS5zY3JvbGxiYXJYQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgoc2Nyb2xsTGVmdCA9PT0gMCAmJiBkZWx0YVggPCAwKSB8fCAoc2Nyb2xsTGVmdCA+PSBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGggJiYgZGVsdGFYID4gMCkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVsdGFGcm9tRXZlbnQoZSkge1xuICAgIHZhciBkZWx0YVggPSBlLmRlbHRhWDtcbiAgICB2YXIgZGVsdGFZID0gLTEgKiBlLmRlbHRhWTtcblxuICAgIGlmICh0eXBlb2YgZGVsdGFYID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBkZWx0YVkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIC8vIE9TIFggU2FmYXJpXG4gICAgICBkZWx0YVggPSAtMSAqIGUud2hlZWxEZWx0YVggLyA2O1xuICAgICAgZGVsdGFZID0gZS53aGVlbERlbHRhWSAvIDY7XG4gICAgfVxuXG4gICAgaWYgKGUuZGVsdGFNb2RlICYmIGUuZGVsdGFNb2RlID09PSAxKSB7XG4gICAgICAvLyBGaXJlZm94IGluIGRlbHRhTW9kZSAxOiBMaW5lIHNjcm9sbGluZ1xuICAgICAgZGVsdGFYICo9IDEwO1xuICAgICAgZGVsdGFZICo9IDEwO1xuICAgIH1cblxuICAgIGlmIChkZWx0YVggIT09IGRlbHRhWCAmJiBkZWx0YVkgIT09IGRlbHRhWS8qIE5hTiBjaGVja3MgKi8pIHtcbiAgICAgIC8vIElFIGluIHNvbWUgbW91c2UgZHJpdmVyc1xuICAgICAgZGVsdGFYID0gMDtcbiAgICAgIGRlbHRhWSA9IGUud2hlZWxEZWx0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2RlbHRhWCwgZGVsdGFZXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEJlQ29uc3VtZWRCeVRleHRhcmVhKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIGhvdmVyZWRUZXh0YXJlYSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dGFyZWE6aG92ZXInKTtcbiAgICBpZiAoaG92ZXJlZFRleHRhcmVhKSB7XG4gICAgICB2YXIgbWF4U2Nyb2xsVG9wID0gaG92ZXJlZFRleHRhcmVhLnNjcm9sbEhlaWdodCAtIGhvdmVyZWRUZXh0YXJlYS5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAobWF4U2Nyb2xsVG9wID4gMCkge1xuICAgICAgICBpZiAoIShob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsVG9wID09PSAwICYmIGRlbHRhWSA+IDApICYmXG4gICAgICAgICAgICAhKGhvdmVyZWRUZXh0YXJlYS5zY3JvbGxUb3AgPT09IG1heFNjcm9sbFRvcCAmJiBkZWx0YVkgPCAwKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbWF4U2Nyb2xsTGVmdCA9IGhvdmVyZWRUZXh0YXJlYS5zY3JvbGxMZWZ0IC0gaG92ZXJlZFRleHRhcmVhLmNsaWVudFdpZHRoO1xuICAgICAgaWYgKG1heFNjcm9sbExlZnQgPiAwKSB7XG4gICAgICAgIGlmICghKGhvdmVyZWRUZXh0YXJlYS5zY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApICYmXG4gICAgICAgICAgICAhKGhvdmVyZWRUZXh0YXJlYS5zY3JvbGxMZWZ0ID09PSBtYXhTY3JvbGxMZWZ0ICYmIGRlbHRhWCA+IDApKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V3aGVlbEhhbmRsZXIoZSkge1xuICAgIC8vIEZJWE1FOiB0aGlzIGlzIGEgcXVpY2sgZml4IGZvciB0aGUgc2VsZWN0IHByb2JsZW0gaW4gRkYgYW5kIElFLlxuICAgIC8vIElmIHRoZXJlIGNvbWVzIGFuIGVmZmVjdGl2ZSB3YXkgdG8gZGVhbCB3aXRoIHRoZSBwcm9ibGVtLFxuICAgIC8vIHRoaXMgbGluZXMgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgaWYgKCFoLmVudi5pc1dlYktpdCAmJiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdDpmb2N1cycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhID0gZ2V0RGVsdGFGcm9tRXZlbnQoZSk7XG5cbiAgICB2YXIgZGVsdGFYID0gZGVsdGFbMF07XG4gICAgdmFyIGRlbHRhWSA9IGRlbHRhWzFdO1xuXG4gICAgaWYgKHNob3VsZEJlQ29uc3VtZWRCeVRleHRhcmVhKGRlbHRhWCwgZGVsdGFZKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcbiAgICBpZiAoIWkuc2V0dGluZ3MudXNlQm90aFdoZWVsQXhlcykge1xuICAgICAgLy8gZGVsdGFYIHdpbGwgb25seSBiZSB1c2VkIGZvciBob3Jpem9udGFsIHNjcm9sbGluZyBhbmQgZGVsdGFZIHdpbGxcbiAgICAgIC8vIG9ubHkgYmUgdXNlZCBmb3IgdmVydGljYWwgc2Nyb2xsaW5nIC0gdGhpcyBpcyB0aGUgZGVmYXVsdFxuICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCAtIChkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcbiAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCArIChkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcbiAgICB9IGVsc2UgaWYgKGkuc2Nyb2xsYmFyWUFjdGl2ZSAmJiAhaS5zY3JvbGxiYXJYQWN0aXZlKSB7XG4gICAgICAvLyBvbmx5IHZlcnRpY2FsIHNjcm9sbGJhciBpcyBhY3RpdmUgYW5kIHVzZUJvdGhXaGVlbEF4ZXMgb3B0aW9uIGlzXG4gICAgICAvLyBhY3RpdmUsIHNvIGxldCdzIHNjcm9sbCB2ZXJ0aWNhbCBiYXIgdXNpbmcgYm90aCBtb3VzZSB3aGVlbCBheGVzXG4gICAgICBpZiAoZGVsdGFZKSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgLSAoZGVsdGFZICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wICsgKGRlbHRhWCAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xuICAgICAgfVxuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpLnNjcm9sbGJhclhBY3RpdmUgJiYgIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xuICAgICAgLy8gdXNlQm90aFdoZWVsQXhlcyBhbmQgb25seSBob3Jpem9udGFsIGJhciBpcyBhY3RpdmUsIHNvIHVzZSBib3RoXG4gICAgICAvLyB3aGVlbCBheGVzIGZvciBob3Jpem9udGFsIGJhclxuICAgICAgaWYgKGRlbHRhWCkge1xuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgKyAoZGVsdGFYICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgLSAoZGVsdGFZICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XG4gICAgICB9XG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcblxuICAgIHNob3VsZFByZXZlbnQgPSAoc2hvdWxkUHJldmVudCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkpO1xuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93Lm9ud2hlZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3doZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cub25tb3VzZXdoZWVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kTW91c2VXaGVlbEhhbmRsZXIoZWxlbWVudCwgaSk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xuXG5mdW5jdGlvbiBiaW5kTmF0aXZlU2Nyb2xsSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIGJpbmROYXRpdmVTY3JvbGxIYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5JylcbiAgLCB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XG5cbmZ1bmN0aW9uIGJpbmRTZWxlY3Rpb25IYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgZnVuY3Rpb24gZ2V0UmFuZ2VOb2RlKCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gd2luZG93LmdldFNlbGVjdGlvbigpIDpcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0U2VsZWN0aW9uID8gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkgOiAnJztcbiAgICBpZiAoc2VsZWN0aW9uLnRvU3RyaW5nKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzY3JvbGxpbmdMb29wID0gbnVsbDtcbiAgdmFyIHNjcm9sbERpZmYgPSB7dG9wOiAwLCBsZWZ0OiAwfTtcbiAgZnVuY3Rpb24gc3RhcnRTY3JvbGxpbmcoKSB7XG4gICAgaWYgKCFzY3JvbGxpbmdMb29wKSB7XG4gICAgICBzY3JvbGxpbmdMb29wID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWluc3RhbmNlcy5nZXQoZWxlbWVudCkpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHNjcm9sbGluZ0xvb3ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgKyBzY3JvbGxEaWZmLnRvcCk7XG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCArIHNjcm9sbERpZmYubGVmdCk7XG4gICAgICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuICAgICAgfSwgNTApOyAvLyBldmVyeSAuMSBzZWNcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RvcFNjcm9sbGluZygpIHtcbiAgICBpZiAoc2Nyb2xsaW5nTG9vcCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChzY3JvbGxpbmdMb29wKTtcbiAgICAgIHNjcm9sbGluZ0xvb3AgPSBudWxsO1xuICAgIH1cbiAgICBoLnN0b3BTY3JvbGxpbmcoZWxlbWVudCk7XG4gIH1cblxuICB2YXIgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICBpLmV2ZW50LmJpbmQoaS5vd25lckRvY3VtZW50LCAnc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKGdldFJhbmdlTm9kZSgpKSkge1xuICAgICAgaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHN0b3BTY3JvbGxpbmcoKTtcbiAgICB9XG4gIH0pO1xuICBpLmV2ZW50LmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgc3RvcFNjcm9sbGluZygpO1xuICAgIH1cbiAgfSk7XG5cbiAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0ge3g6IGUucGFnZVgsIHk6IGUucGFnZVl9O1xuICAgICAgdmFyIGNvbnRhaW5lckdlb21ldHJ5ID0ge1xuICAgICAgICBsZWZ0OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgICAgIHJpZ2h0OiBlbGVtZW50Lm9mZnNldExlZnQgKyBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICB0b3A6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgICAgICBib3R0b206IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIGlmIChtb3VzZVBvc2l0aW9uLnggPCBjb250YWluZXJHZW9tZXRyeS5sZWZ0ICsgMykge1xuICAgICAgICBzY3JvbGxEaWZmLmxlZnQgPSAtNTtcbiAgICAgICAgaC5zdGFydFNjcm9sbGluZyhlbGVtZW50LCAneCcpO1xuICAgICAgfSBlbHNlIGlmIChtb3VzZVBvc2l0aW9uLnggPiBjb250YWluZXJHZW9tZXRyeS5yaWdodCAtIDMpIHtcbiAgICAgICAgc2Nyb2xsRGlmZi5sZWZ0ID0gNTtcbiAgICAgICAgaC5zdGFydFNjcm9sbGluZyhlbGVtZW50LCAneCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsRGlmZi5sZWZ0ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vdXNlUG9zaXRpb24ueSA8IGNvbnRhaW5lckdlb21ldHJ5LnRvcCArIDMpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lckdlb21ldHJ5LnRvcCArIDMgLSBtb3VzZVBvc2l0aW9uLnkgPCA1KSB7XG4gICAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSAtNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IC0yMDtcbiAgICAgICAgfVxuICAgICAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XG4gICAgICB9IGVsc2UgaWYgKG1vdXNlUG9zaXRpb24ueSA+IGNvbnRhaW5lckdlb21ldHJ5LmJvdHRvbSAtIDMpIHtcbiAgICAgICAgaWYgKG1vdXNlUG9zaXRpb24ueSAtIGNvbnRhaW5lckdlb21ldHJ5LmJvdHRvbSArIDMgPCA1KSB7XG4gICAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSA1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbERpZmYudG9wID0gMjA7XG4gICAgICAgIH1cbiAgICAgICAgaC5zdGFydFNjcm9sbGluZyhlbGVtZW50LCAneScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Nyb2xsRGlmZi50b3AgPT09IDAgJiYgc2Nyb2xsRGlmZi5sZWZ0ID09PSAwKSB7XG4gICAgICAgIHN0b3BTY3JvbGxpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIGJpbmRTZWxlY3Rpb25IYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKVxuICAsIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcblxuZnVuY3Rpb24gYmluZFRvdWNoSGFuZGxlcihlbGVtZW50LCBpLCBzdXBwb3J0c1RvdWNoLCBzdXBwb3J0c0llUG9pbnRlcikge1xuICBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICB2YXIgbWFnbml0dWRlWCA9IE1hdGguYWJzKGRlbHRhWCk7XG4gICAgdmFyIG1hZ25pdHVkZVkgPSBNYXRoLmFicyhkZWx0YVkpO1xuXG4gICAgaWYgKG1hZ25pdHVkZVkgPiBtYWduaXR1ZGVYKSB7XG4gICAgICAvLyB1c2VyIGlzIHBlcmhhcHMgdHJ5aW5nIHRvIHN3aXBlIHVwL2Rvd24gdGhlIHBhZ2VcblxuICAgICAgaWYgKCgoZGVsdGFZIDwgMCkgJiYgKHNjcm9sbFRvcCA9PT0gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpKSB8fFxuICAgICAgICAgICgoZGVsdGFZID4gMCkgJiYgKHNjcm9sbFRvcCA9PT0gMCkpKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy5zd2lwZVByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWFnbml0dWRlWCA+IG1hZ25pdHVkZVkpIHtcbiAgICAgIC8vIHVzZXIgaXMgcGVyaGFwcyB0cnlpbmcgdG8gc3dpcGUgbGVmdC9yaWdodCBhY3Jvc3MgdGhlIHBhZ2VcblxuICAgICAgaWYgKCgoZGVsdGFYIDwgMCkgJiYgKHNjcm9sbExlZnQgPT09IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkpIHx8XG4gICAgICAgICAgKChkZWx0YVggPiAwKSAmJiAoc2Nyb2xsTGVmdCA9PT0gMCkpKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy5zd2lwZVByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUb3VjaE1vdmUoZGlmZmVyZW5jZVgsIGRpZmZlcmVuY2VZKSB7XG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCAtIGRpZmZlcmVuY2VZKTtcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgLSBkaWZmZXJlbmNlWCk7XG5cbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBzdGFydE9mZnNldCA9IHt9O1xuICB2YXIgc3RhcnRUaW1lID0gMDtcbiAgdmFyIHNwZWVkID0ge307XG4gIHZhciBlYXNpbmdMb29wID0gbnVsbDtcbiAgdmFyIGluR2xvYmFsVG91Y2ggPSBmYWxzZTtcbiAgdmFyIGluTG9jYWxUb3VjaCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGdsb2JhbFRvdWNoU3RhcnQoKSB7XG4gICAgaW5HbG9iYWxUb3VjaCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZ2xvYmFsVG91Y2hFbmQoKSB7XG4gICAgaW5HbG9iYWxUb3VjaCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2goZSkge1xuICAgIGlmIChlLnRhcmdldFRvdWNoZXMpIHtcbiAgICAgIHJldHVybiBlLnRhcmdldFRvdWNoZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1heWJlIElFIHBvaW50ZXJcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzaG91bGRIYW5kbGUoZSkge1xuICAgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChlLnBvaW50ZXJUeXBlICYmIGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiB0b3VjaFN0YXJ0KGUpIHtcbiAgICBpZiAoc2hvdWxkSGFuZGxlKGUpKSB7XG4gICAgICBpbkxvY2FsVG91Y2ggPSB0cnVlO1xuXG4gICAgICB2YXIgdG91Y2ggPSBnZXRUb3VjaChlKTtcblxuICAgICAgc3RhcnRPZmZzZXQucGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICAgIHN0YXJ0T2Zmc2V0LnBhZ2VZID0gdG91Y2gucGFnZVk7XG5cbiAgICAgIHN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAgIGlmIChlYXNpbmdMb29wICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICB9XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvdWNoTW92ZShlKSB7XG4gICAgaWYgKCFpbkdsb2JhbFRvdWNoICYmIGluTG9jYWxUb3VjaCAmJiBzaG91bGRIYW5kbGUoZSkpIHtcbiAgICAgIHZhciB0b3VjaCA9IGdldFRvdWNoKGUpO1xuXG4gICAgICB2YXIgY3VycmVudE9mZnNldCA9IHtwYWdlWDogdG91Y2gucGFnZVgsIHBhZ2VZOiB0b3VjaC5wYWdlWX07XG5cbiAgICAgIHZhciBkaWZmZXJlbmNlWCA9IGN1cnJlbnRPZmZzZXQucGFnZVggLSBzdGFydE9mZnNldC5wYWdlWDtcbiAgICAgIHZhciBkaWZmZXJlbmNlWSA9IGN1cnJlbnRPZmZzZXQucGFnZVkgLSBzdGFydE9mZnNldC5wYWdlWTtcblxuICAgICAgYXBwbHlUb3VjaE1vdmUoZGlmZmVyZW5jZVgsIGRpZmZlcmVuY2VZKTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gY3VycmVudE9mZnNldDtcblxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgdmFyIHRpbWVHYXAgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIGlmICh0aW1lR2FwID4gMCkge1xuICAgICAgICBzcGVlZC54ID0gZGlmZmVyZW5jZVggLyB0aW1lR2FwO1xuICAgICAgICBzcGVlZC55ID0gZGlmZmVyZW5jZVkgLyB0aW1lR2FwO1xuICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFByZXZlbnREZWZhdWx0KGRpZmZlcmVuY2VYLCBkaWZmZXJlbmNlWSkpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaEVuZCgpIHtcbiAgICBpZiAoIWluR2xvYmFsVG91Y2ggJiYgaW5Mb2NhbFRvdWNoKSB7XG4gICAgICBpbkxvY2FsVG91Y2ggPSBmYWxzZTtcblxuICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgIGVhc2luZ0xvb3AgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VzLmdldChlbGVtZW50KSkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkLngpIDwgMC4wMSAmJiBNYXRoLmFicyhzcGVlZC55KSA8IDAuMDEpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGVhc2luZ0xvb3ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5VG91Y2hNb3ZlKHNwZWVkLnggKiAzMCwgc3BlZWQueSAqIDMwKTtcblxuICAgICAgICBzcGVlZC54ICo9IDAuODtcbiAgICAgICAgc3BlZWQueSAqPSAwLjg7XG4gICAgICB9LCAxMCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnRzVG91Y2gpIHtcbiAgICBpLmV2ZW50LmJpbmQod2luZG93LCAndG91Y2hzdGFydCcsIGdsb2JhbFRvdWNoU3RhcnQpO1xuICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGdsb2JhbFRvdWNoRW5kKTtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB0b3VjaFN0YXJ0KTtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNobW92ZScsIHRvdWNoTW92ZSk7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaGVuZCcsIHRvdWNoRW5kKTtcbiAgfVxuXG4gIGlmIChzdXBwb3J0c0llUG9pbnRlcikge1xuICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAncG9pbnRlcmRvd24nLCBnbG9iYWxUb3VjaFN0YXJ0KTtcbiAgICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICdwb2ludGVydXAnLCBnbG9iYWxUb3VjaEVuZCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3BvaW50ZXJkb3duJywgdG91Y2hTdGFydCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3BvaW50ZXJtb3ZlJywgdG91Y2hNb3ZlKTtcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAncG9pbnRlcnVwJywgdG91Y2hFbmQpO1xuICAgIH0gZWxzZSBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAnTVNQb2ludGVyRG93bicsIGdsb2JhbFRvdWNoU3RhcnQpO1xuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ01TUG9pbnRlclVwJywgZ2xvYmFsVG91Y2hFbmQpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJEb3duJywgdG91Y2hTdGFydCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlck1vdmUnLCB0b3VjaE1vdmUpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJVcCcsIHRvdWNoRW5kKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3VwcG9ydHNUb3VjaCwgc3VwcG9ydHNJZVBvaW50ZXIpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kVG91Y2hIYW5kbGVyKGVsZW1lbnQsIGksIHN1cHBvcnRzVG91Y2gsIHN1cHBvcnRzSWVQb2ludGVyKTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbHMgPSByZXF1aXJlKCcuLi9saWIvY2xhc3MnKVxuICAsIGggPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuL3VwZGF0ZS1nZW9tZXRyeScpO1xuXG4vLyBIYW5kbGVyc1xudmFyIGNsaWNrUmFpbEhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXIvY2xpY2stcmFpbCcpXG4gICwgZHJhZ1Njcm9sbGJhckhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXIvZHJhZy1zY3JvbGxiYXInKVxuICAsIGtleWJvYXJkSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9rZXlib2FyZCcpXG4gICwgbW91c2VXaGVlbEhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXIvbW91c2Utd2hlZWwnKVxuICAsIG5hdGl2ZVNjcm9sbEhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXIvbmF0aXZlLXNjcm9sbCcpXG4gICwgc2VsZWN0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9zZWxlY3Rpb24nKVxuICAsIHRvdWNoSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci90b3VjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50LCB1c2VyU2V0dGluZ3MpIHtcbiAgdXNlclNldHRpbmdzID0gdHlwZW9mIHVzZXJTZXR0aW5ncyA9PT0gJ29iamVjdCcgPyB1c2VyU2V0dGluZ3MgOiB7fTtcblxuICBjbHMuYWRkKGVsZW1lbnQsICdwcy1jb250YWluZXInKTtcblxuICAvLyBDcmVhdGUgYSBwbHVnaW4gaW5zdGFuY2UuXG4gIHZhciBpID0gaW5zdGFuY2VzLmFkZChlbGVtZW50KTtcblxuICBpLnNldHRpbmdzID0gaC5leHRlbmQoaS5zZXR0aW5ncywgdXNlclNldHRpbmdzKTtcblxuICBjbGlja1JhaWxIYW5kbGVyKGVsZW1lbnQpO1xuICBkcmFnU2Nyb2xsYmFySGFuZGxlcihlbGVtZW50KTtcbiAgbW91c2VXaGVlbEhhbmRsZXIoZWxlbWVudCk7XG4gIG5hdGl2ZVNjcm9sbEhhbmRsZXIoZWxlbWVudCk7XG5cbiAgaWYgKGkuc2V0dGluZ3MudXNlU2VsZWN0aW9uU2Nyb2xsKSB7XG4gICAgc2VsZWN0aW9uSGFuZGxlcihlbGVtZW50KTtcbiAgfVxuXG4gIGlmIChoLmVudi5zdXBwb3J0c1RvdWNoIHx8IGguZW52LnN1cHBvcnRzSWVQb2ludGVyKSB7XG4gICAgdG91Y2hIYW5kbGVyKGVsZW1lbnQsIGguZW52LnN1cHBvcnRzVG91Y2gsIGguZW52LnN1cHBvcnRzSWVQb2ludGVyKTtcbiAgfVxuICBpZiAoaS5zZXR0aW5ncy51c2VLZXlib2FyZCkge1xuICAgIGtleWJvYXJkSGFuZGxlcihlbGVtZW50KTtcbiAgfVxuXG4gIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGQgPSByZXF1aXJlKCcuLi9saWIvZG9tJylcbiAgLCBkZWZhdWx0U2V0dGluZ3MgPSByZXF1aXJlKCcuL2RlZmF1bHQtc2V0dGluZycpXG4gICwgRXZlbnRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbGliL2V2ZW50LW1hbmFnZXInKVxuICAsIGd1aWQgPSByZXF1aXJlKCcuLi9saWIvZ3VpZCcpXG4gICwgaCA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKTtcblxudmFyIGluc3RhbmNlcyA9IHt9O1xuXG5mdW5jdGlvbiBJbnN0YW5jZShlbGVtZW50KSB7XG4gIHZhciBpID0gdGhpcztcblxuICBpLnNldHRpbmdzID0gaC5jbG9uZShkZWZhdWx0U2V0dGluZ3MpO1xuICBpLmNvbnRhaW5lcldpZHRoID0gbnVsbDtcbiAgaS5jb250YWluZXJIZWlnaHQgPSBudWxsO1xuICBpLmNvbnRlbnRXaWR0aCA9IG51bGw7XG4gIGkuY29udGVudEhlaWdodCA9IG51bGw7XG5cbiAgaS5pc1J0bCA9IGQuY3NzKGVsZW1lbnQsICdkaXJlY3Rpb24nKSA9PT0gXCJydGxcIjtcbiAgaS5pc05lZ2F0aXZlU2Nyb2xsID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZ2luYWxTY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IC0xO1xuICAgIHJlc3VsdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCA8IDA7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gb3JpZ2luYWxTY3JvbGxMZWZ0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pKCk7XG4gIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gaS5pc05lZ2F0aXZlU2Nyb2xsID8gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGggOiAwO1xuICBpLmV2ZW50ID0gbmV3IEV2ZW50TWFuYWdlcigpO1xuICBpLm93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cbiAgaS5zY3JvbGxiYXJYUmFpbCA9IGQuYXBwZW5kVG8oZC5lKCdkaXYnLCAncHMtc2Nyb2xsYmFyLXgtcmFpbCcpLCBlbGVtZW50KTtcbiAgaS5zY3JvbGxiYXJYID0gZC5hcHBlbmRUbyhkLmUoJ2RpdicsICdwcy1zY3JvbGxiYXIteCcpLCBpLnNjcm9sbGJhclhSYWlsKTtcbiAgaS5zY3JvbGxiYXJYQWN0aXZlID0gbnVsbDtcbiAgaS5zY3JvbGxiYXJYV2lkdGggPSBudWxsO1xuICBpLnNjcm9sbGJhclhMZWZ0ID0gbnVsbDtcbiAgaS5zY3JvbGxiYXJYQm90dG9tID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnYm90dG9tJykpO1xuICBpLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID0gaS5zY3JvbGxiYXJYQm90dG9tID09PSBpLnNjcm9sbGJhclhCb3R0b207IC8vICFpc05hTlxuICBpLnNjcm9sbGJhclhUb3AgPSBpLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID8gbnVsbCA6IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ3RvcCcpKTtcbiAgaS5yYWlsQm9yZGVyWFdpZHRoID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnYm9yZGVyTGVmdFdpZHRoJykpICsgaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnYm9yZGVyUmlnaHRXaWR0aCcpKTtcbiAgLy8gU2V0IHJhaWwgdG8gZGlzcGxheTpibG9jayB0byBjYWxjdWxhdGUgbWFyZ2luc1xuICBkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnZGlzcGxheScsICdibG9jaycpO1xuICBpLnJhaWxYTWFyZ2luV2lkdGggPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5MZWZ0JykpICsgaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luUmlnaHQnKSk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJycpO1xuICBpLnJhaWxYV2lkdGggPSBudWxsO1xuICBpLnJhaWxYUmF0aW8gPSBudWxsO1xuXG4gIGkuc2Nyb2xsYmFyWVJhaWwgPSBkLmFwcGVuZFRvKGQuZSgnZGl2JywgJ3BzLXNjcm9sbGJhci15LXJhaWwnKSwgZWxlbWVudCk7XG4gIGkuc2Nyb2xsYmFyWSA9IGQuYXBwZW5kVG8oZC5lKCdkaXYnLCAncHMtc2Nyb2xsYmFyLXknKSwgaS5zY3JvbGxiYXJZUmFpbCk7XG4gIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IG51bGw7XG4gIGkuc2Nyb2xsYmFyWUhlaWdodCA9IG51bGw7XG4gIGkuc2Nyb2xsYmFyWVRvcCA9IG51bGw7XG4gIGkuc2Nyb2xsYmFyWVJpZ2h0ID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAncmlnaHQnKSk7XG4gIGkuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9IGkuc2Nyb2xsYmFyWVJpZ2h0ID09PSBpLnNjcm9sbGJhcllSaWdodDsgLy8gIWlzTmFOXG4gIGkuc2Nyb2xsYmFyWUxlZnQgPSBpLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPyBudWxsIDogaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbGVmdCcpKTtcbiAgaS5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA9IGkuaXNSdGwgPyBoLm91dGVyV2lkdGgoaS5zY3JvbGxiYXJZKSA6IG51bGw7XG4gIGkucmFpbEJvcmRlcllXaWR0aCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2JvcmRlclRvcFdpZHRoJykpICsgaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnYm9yZGVyQm90dG9tV2lkdGgnKSk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gIGkucmFpbFlNYXJnaW5IZWlnaHQgPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdtYXJnaW5Ub3AnKSkgKyBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdtYXJnaW5Cb3R0b20nKSk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJycpO1xuICBpLnJhaWxZSGVpZ2h0ID0gbnVsbDtcbiAgaS5yYWlsWVJhdGlvID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SWQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQuZGF0YXNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcHMtaWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC5kYXRhc2V0LnBzSWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0SWQoZWxlbWVudCwgaWQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRhdGFzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcHMtaWQnLCBpZCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5kYXRhc2V0LnBzSWQgPSBpZDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVJZChlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5kYXRhc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXBzLWlkJyk7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC5wc0lkO1xuICB9XG59XG5cbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIG5ld0lkID0gZ3VpZCgpO1xuICBzZXRJZChlbGVtZW50LCBuZXdJZCk7XG4gIGluc3RhbmNlc1tuZXdJZF0gPSBuZXcgSW5zdGFuY2UoZWxlbWVudCk7XG4gIHJldHVybiBpbnN0YW5jZXNbbmV3SWRdO1xufTtcblxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBkZWxldGUgaW5zdGFuY2VzW2dldElkKGVsZW1lbnQpXTtcbiAgcmVtb3ZlSWQoZWxlbWVudCk7XG59O1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBpbnN0YW5jZXNbZ2V0SWQoZWxlbWVudCldO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNscyA9IHJlcXVpcmUoJy4uL2xpYi9jbGFzcycpXG4gICwgZCA9IHJlcXVpcmUoJy4uL2xpYi9kb20nKVxuICAsIGggPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpXG4gICwgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi91cGRhdGUtc2Nyb2xsJyk7XG5cbmZ1bmN0aW9uIGdldFRodW1iU2l6ZShpLCB0aHVtYlNpemUpIHtcbiAgaWYgKGkuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKSB7XG4gICAgdGh1bWJTaXplID0gTWF0aC5tYXgodGh1bWJTaXplLCBpLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCk7XG4gIH1cbiAgaWYgKGkuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoKSB7XG4gICAgdGh1bWJTaXplID0gTWF0aC5taW4odGh1bWJTaXplLCBpLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHRodW1iU2l6ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3NzKGVsZW1lbnQsIGkpIHtcbiAgdmFyIHhSYWlsT2Zmc2V0ID0ge3dpZHRoOiBpLnJhaWxYV2lkdGh9O1xuICBpZiAoaS5pc1J0bCkge1xuICAgIHhSYWlsT2Zmc2V0LmxlZnQgPSBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCArIGkuY29udGFpbmVyV2lkdGggLSBpLmNvbnRlbnRXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICB4UmFpbE9mZnNldC5sZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICB9XG4gIGlmIChpLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tKSB7XG4gICAgeFJhaWxPZmZzZXQuYm90dG9tID0gaS5zY3JvbGxiYXJYQm90dG9tIC0gZWxlbWVudC5zY3JvbGxUb3A7XG4gIH0gZWxzZSB7XG4gICAgeFJhaWxPZmZzZXQudG9wID0gaS5zY3JvbGxiYXJYVG9wICsgZWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cbiAgZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgeFJhaWxPZmZzZXQpO1xuXG4gIHZhciB5UmFpbE9mZnNldCA9IHt0b3A6IGVsZW1lbnQuc2Nyb2xsVG9wLCBoZWlnaHQ6IGkucmFpbFlIZWlnaHR9O1xuICBpZiAoaS5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0KSB7XG4gICAgaWYgKGkuaXNSdGwpIHtcbiAgICAgIHlSYWlsT2Zmc2V0LnJpZ2h0ID0gaS5jb250ZW50V2lkdGggLSAoaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBlbGVtZW50LnNjcm9sbExlZnQpIC0gaS5zY3JvbGxiYXJZUmlnaHQgLSBpLnNjcm9sbGJhcllPdXRlcldpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB5UmFpbE9mZnNldC5yaWdodCA9IGkuc2Nyb2xsYmFyWVJpZ2h0IC0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaS5pc1J0bCkge1xuICAgICAgeVJhaWxPZmZzZXQubGVmdCA9IGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgZWxlbWVudC5zY3JvbGxMZWZ0ICsgaS5jb250YWluZXJXaWR0aCAqIDIgLSBpLmNvbnRlbnRXaWR0aCAtIGkuc2Nyb2xsYmFyWUxlZnQgLSBpLnNjcm9sbGJhcllPdXRlcldpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB5UmFpbE9mZnNldC5sZWZ0ID0gaS5zY3JvbGxiYXJZTGVmdCArIGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICB9XG4gIH1cbiAgZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgeVJhaWxPZmZzZXQpO1xuXG4gIGQuY3NzKGkuc2Nyb2xsYmFyWCwge2xlZnQ6IGkuc2Nyb2xsYmFyWExlZnQsIHdpZHRoOiBpLnNjcm9sbGJhclhXaWR0aCAtIGkucmFpbEJvcmRlclhXaWR0aH0pO1xuICBkLmNzcyhpLnNjcm9sbGJhclksIHt0b3A6IGkuc2Nyb2xsYmFyWVRvcCwgaGVpZ2h0OiBpLnNjcm9sbGJhcllIZWlnaHQgLSBpLnJhaWxCb3JkZXJZV2lkdGh9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG5cbiAgaS5jb250YWluZXJXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIGkuY29udGFpbmVySGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIGkuY29udGVudFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgaS5jb250ZW50SGVpZ2h0ID0gZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG5cbiAgdmFyIGV4aXN0aW5nUmFpbHM7XG4gIGlmICghZWxlbWVudC5jb250YWlucyhpLnNjcm9sbGJhclhSYWlsKSkge1xuICAgIGV4aXN0aW5nUmFpbHMgPSBkLnF1ZXJ5Q2hpbGRyZW4oZWxlbWVudCwgJy5wcy1zY3JvbGxiYXIteC1yYWlsJyk7XG4gICAgaWYgKGV4aXN0aW5nUmFpbHMubGVuZ3RoID4gMCkge1xuICAgICAgZXhpc3RpbmdSYWlscy5mb3JFYWNoKGZ1bmN0aW9uIChyYWlsKSB7XG4gICAgICAgIGQucmVtb3ZlKHJhaWwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGQuYXBwZW5kVG8oaS5zY3JvbGxiYXJYUmFpbCwgZWxlbWVudCk7XG4gIH1cbiAgaWYgKCFlbGVtZW50LmNvbnRhaW5zKGkuc2Nyb2xsYmFyWVJhaWwpKSB7XG4gICAgZXhpc3RpbmdSYWlscyA9IGQucXVlcnlDaGlsZHJlbihlbGVtZW50LCAnLnBzLXNjcm9sbGJhci15LXJhaWwnKTtcbiAgICBpZiAoZXhpc3RpbmdSYWlscy5sZW5ndGggPiAwKSB7XG4gICAgICBleGlzdGluZ1JhaWxzLmZvckVhY2goZnVuY3Rpb24gKHJhaWwpIHtcbiAgICAgICAgZC5yZW1vdmUocmFpbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZC5hcHBlbmRUbyhpLnNjcm9sbGJhcllSYWlsLCBlbGVtZW50KTtcbiAgfVxuXG4gIGlmICghaS5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFggJiYgaS5jb250YWluZXJXaWR0aCArIGkuc2V0dGluZ3Muc2Nyb2xsWE1hcmdpbk9mZnNldCA8IGkuY29udGVudFdpZHRoKSB7XG4gICAgaS5zY3JvbGxiYXJYQWN0aXZlID0gdHJ1ZTtcbiAgICBpLnJhaWxYV2lkdGggPSBpLmNvbnRhaW5lcldpZHRoIC0gaS5yYWlsWE1hcmdpbldpZHRoO1xuICAgIGkucmFpbFhSYXRpbyA9IGkuY29udGFpbmVyV2lkdGggLyBpLnJhaWxYV2lkdGg7XG4gICAgaS5zY3JvbGxiYXJYV2lkdGggPSBnZXRUaHVtYlNpemUoaSwgaC50b0ludChpLnJhaWxYV2lkdGggKiBpLmNvbnRhaW5lcldpZHRoIC8gaS5jb250ZW50V2lkdGgpKTtcbiAgICBpLnNjcm9sbGJhclhMZWZ0ID0gaC50b0ludCgoaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBlbGVtZW50LnNjcm9sbExlZnQpICogKGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKSAvIChpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpKTtcbiAgfSBlbHNlIHtcbiAgICBpLnNjcm9sbGJhclhBY3RpdmUgPSBmYWxzZTtcbiAgICBpLnNjcm9sbGJhclhXaWR0aCA9IDA7XG4gICAgaS5zY3JvbGxiYXJYTGVmdCA9IDA7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gMDtcbiAgfVxuXG4gIGlmICghaS5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgaS5jb250YWluZXJIZWlnaHQgKyBpLnNldHRpbmdzLnNjcm9sbFlNYXJnaW5PZmZzZXQgPCBpLmNvbnRlbnRIZWlnaHQpIHtcbiAgICBpLnNjcm9sbGJhcllBY3RpdmUgPSB0cnVlO1xuICAgIGkucmFpbFlIZWlnaHQgPSBpLmNvbnRhaW5lckhlaWdodCAtIGkucmFpbFlNYXJnaW5IZWlnaHQ7XG4gICAgaS5yYWlsWVJhdGlvID0gaS5jb250YWluZXJIZWlnaHQgLyBpLnJhaWxZSGVpZ2h0O1xuICAgIGkuc2Nyb2xsYmFyWUhlaWdodCA9IGdldFRodW1iU2l6ZShpLCBoLnRvSW50KGkucmFpbFlIZWlnaHQgKiBpLmNvbnRhaW5lckhlaWdodCAvIGkuY29udGVudEhlaWdodCkpO1xuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IGgudG9JbnQoZWxlbWVudC5zY3JvbGxUb3AgKiAoaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCkgLyAoaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpKTtcbiAgfSBlbHNlIHtcbiAgICBpLnNjcm9sbGJhcllBY3RpdmUgPSBmYWxzZTtcbiAgICBpLnNjcm9sbGJhcllIZWlnaHQgPSAwO1xuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IDA7XG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCAwKTtcbiAgfVxuXG4gIGlmIChpLnNjcm9sbGJhclhMZWZ0ID49IGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKSB7XG4gICAgaS5zY3JvbGxiYXJYTGVmdCA9IGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoO1xuICB9XG4gIGlmIChpLnNjcm9sbGJhcllUb3AgPj0gaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCkge1xuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQ7XG4gIH1cblxuICB1cGRhdGVDc3MoZWxlbWVudCwgaSk7XG5cbiAgY2xzW2kuc2Nyb2xsYmFyWEFjdGl2ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGVsZW1lbnQsICdwcy1hY3RpdmUteCcpO1xuICBjbHNbaS5zY3JvbGxiYXJZQWN0aXZlID8gJ2FkZCcgOiAncmVtb3ZlJ10oZWxlbWVudCwgJ3BzLWFjdGl2ZS15Jyk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKTtcblxudmFyIHVwRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIGRvd25FdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgbGVmdEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCByaWdodEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCB5RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIHhFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgeFN0YXJ0RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIHhFbmRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgeVN0YXJ0RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIHlFbmRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgbGFzdFRvcFxuICAsIGxhc3RMZWZ0O1xuXG51cEV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLXVwJywgdHJ1ZSwgdHJ1ZSk7XG5kb3duRXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwtZG93bicsIHRydWUsIHRydWUpO1xubGVmdEV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLWxlZnQnLCB0cnVlLCB0cnVlKTtcbnJpZ2h0RXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwtcmlnaHQnLCB0cnVlLCB0cnVlKTtcbnlFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC15JywgdHJ1ZSwgdHJ1ZSk7XG54RXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwteCcsIHRydWUsIHRydWUpO1xueFN0YXJ0RXZlbnQuaW5pdEV2ZW50KCdwcy14LXJlYWNoLXN0YXJ0JywgdHJ1ZSwgdHJ1ZSk7XG54RW5kRXZlbnQuaW5pdEV2ZW50KCdwcy14LXJlYWNoLWVuZCcsIHRydWUsIHRydWUpO1xueVN0YXJ0RXZlbnQuaW5pdEV2ZW50KCdwcy15LXJlYWNoLXN0YXJ0JywgdHJ1ZSwgdHJ1ZSk7XG55RW5kRXZlbnQuaW5pdEV2ZW50KCdwcy15LXJlYWNoLWVuZCcsIHRydWUsIHRydWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50LCBheGlzLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYW4gZWxlbWVudCB0byB0aGUgdXBkYXRlLXNjcm9sbCBmdW5jdGlvbic7XG4gIH1cblxuICBpZiAodHlwZW9mIGF4aXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYW4gYXhpcyB0byB0aGUgdXBkYXRlLXNjcm9sbCBmdW5jdGlvbic7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93ICdZb3UgbXVzdCBwcm92aWRlIGEgdmFsdWUgdG8gdGhlIHVwZGF0ZS1zY3JvbGwgZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKGF4aXMgPT09ICd0b3AnICYmIHZhbHVlIDw9IDApIHtcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHlTdGFydEV2ZW50KTtcbiAgICByZXR1cm47IC8vIGRvbid0IGFsbG93IG5lZ2F0aXZlIHNjcm9sbFxuICB9XG5cbiAgaWYgKGF4aXMgPT09ICdsZWZ0JyAmJiB2YWx1ZSA8PSAwKSB7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gMDtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoeFN0YXJ0RXZlbnQpO1xuICAgIHJldHVybjsgLy8gZG9uJ3QgYWxsb3cgbmVnYXRpdmUgc2Nyb2xsXG4gIH1cblxuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG5cbiAgaWYgKGF4aXMgPT09ICd0b3AnICYmIHZhbHVlID4gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpIHtcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0O1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh5RW5kRXZlbnQpO1xuICAgIHJldHVybjsgLy8gZG9uJ3QgYWxsb3cgc2Nyb2xsIHBhc3QgY29udGFpbmVyXG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ2xlZnQnICYmIHZhbHVlID4gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSB7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh4RW5kRXZlbnQpO1xuICAgIHJldHVybjsgLy8gZG9uJ3QgYWxsb3cgc2Nyb2xsIHBhc3QgY29udGFpbmVyXG4gIH1cblxuICBpZiAoIWxhc3RUb3ApIHtcbiAgICBsYXN0VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICBpZiAoIWxhc3RMZWZ0KSB7XG4gICAgbGFzdExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ3RvcCcgJiYgdmFsdWUgPCBsYXN0VG9wKSB7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHVwRXZlbnQpO1xuICB9XG5cbiAgaWYgKGF4aXMgPT09ICd0b3AnICYmIHZhbHVlID4gbGFzdFRvcCkge1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChkb3duRXZlbnQpO1xuICB9XG5cbiAgaWYgKGF4aXMgPT09ICdsZWZ0JyAmJiB2YWx1ZSA8IGxhc3RMZWZ0KSB7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGxlZnRFdmVudCk7XG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ2xlZnQnICYmIHZhbHVlID4gbGFzdExlZnQpIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQocmlnaHRFdmVudCk7XG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ3RvcCcpIHtcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGxhc3RUb3AgPSB2YWx1ZTtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoeUV2ZW50KTtcbiAgfVxuXG4gIGlmIChheGlzID09PSAnbGVmdCcpIHtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBsYXN0TGVmdCA9IHZhbHVlO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh4RXZlbnQpO1xuICB9XG5cbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkID0gcmVxdWlyZSgnLi4vbGliL2RvbScpXG4gICwgaCA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4vdXBkYXRlLWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuXG4gIGlmICghaSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlY2FsY3VhdGUgbmVnYXRpdmUgc2Nyb2xsTGVmdCBhZGp1c3RtZW50XG4gIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gaS5pc05lZ2F0aXZlU2Nyb2xsID8gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGggOiAwO1xuXG4gIC8vIFJlY2FsY3VsYXRlIHJhaWwgbWFyZ2luc1xuICBkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnZGlzcGxheScsICdibG9jaycpO1xuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICdibG9jaycpO1xuICBpLnJhaWxYTWFyZ2luV2lkdGggPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5MZWZ0JykpICsgaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luUmlnaHQnKSk7XG4gIGkucmFpbFlNYXJnaW5IZWlnaHQgPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdtYXJnaW5Ub3AnKSkgKyBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdtYXJnaW5Cb3R0b20nKSk7XG5cbiAgLy8gSGlkZSBzY3JvbGxiYXJzIG5vdCB0byBhZmZlY3Qgc2Nyb2xsV2lkdGggYW5kIHNjcm9sbEhlaWdodFxuICBkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnZGlzcGxheScsICdub25lJyk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJ25vbmUnKTtcblxuICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcblxuICBkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnZGlzcGxheScsICcnKTtcbiAgZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnJyk7XG59O1xuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjNcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMyc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgcHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gcHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgRGFzaGJvYXJkVmlldyA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLXZpZXcnKTtcbnZhciBXaWRnZXRzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vd2lkZ2V0cy93aWRnZXRzLWNvbGxlY3Rpb24nKTtcbnZhciBXaWRnZXRNb2RlbEZhY3RvcnkgPSByZXF1aXJlKCcuL3dpZGdldHMvd2lkZ2V0LW1vZGVsLWZhY3RvcnknKTtcbnZhciBMaXN0TW9kZWwgPSByZXF1aXJlKCcuL3dpZGdldHMvbGlzdC9tb2RlbCcpO1xudmFyIEhpc3RvZ3JhbU1vZGVsID0gcmVxdWlyZSgnLi93aWRnZXRzL2hpc3RvZ3JhbS9tb2RlbCcpO1xudmFyIENhdGVnb3J5TW9kZWwgPSByZXF1aXJlKCcuL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWwnKTtcbnZhciBGb3JtdWxhTW9kZWwgPSByZXF1aXJlKCcuL3dpZGdldHMvZm9ybXVsYS9tb2RlbCcpO1xudmFyIFJhbmdlRmlsdGVyID0gcmVxdWlyZSgnLi93aW5kc2hhZnQvZmlsdGVycy9yYW5nZScpO1xudmFyIENhdGVnb3J5RmlsdGVyID0gcmVxdWlyZSgnLi93aW5kc2hhZnQvZmlsdGVycy9jYXRlZ29yeScpO1xudmFyIFdpbmRzaGFmdENvbmZpZyA9IHJlcXVpcmUoJy4vd2luZHNoYWZ0L2NvbmZpZycpO1xudmFyIFdpbmRzaGFmdENsaWVudCA9IHJlcXVpcmUoJy4vd2luZHNoYWZ0L2NsaWVudCcpO1xudmFyIFdpbmRzaGFmdERhc2hib2FyZCA9IHJlcXVpcmUoJy4vd2luZHNoYWZ0L2Rhc2hib2FyZCcpO1xudmFyIFdpbmRzaGFmdFByaXZhdGVEYXNoYm9hcmRDb25maWcgPSByZXF1aXJlKCcuL3dpbmRzaGFmdC9wcml2YXRlLWRhc2hib2FyZC1jb25maWcnKTtcbnZhciBXaW5kc2hhZnRQdWJsaWNEYXNoYm9hcmRDb25maWcgPSByZXF1aXJlKCcuL3dpbmRzaGFmdC9wdWJsaWMtZGFzaGJvYXJkLWNvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBkaUpTT04sIHZpc09wdHMpIHtcbiAgdmFyIHdpZGdldE1vZGVsRmFjdG9yeSA9IG5ldyBXaWRnZXRNb2RlbEZhY3Rvcnkoe1xuICAgIGxpc3Q6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gbmV3IExpc3RNb2RlbChhdHRycywgb3B0cyk7XG4gICAgfSxcbiAgICBmb3JtdWxhOiBmdW5jdGlvbihhdHRycywgb3B0cykge1xuICAgICAgcmV0dXJuIG5ldyBGb3JtdWxhTW9kZWwoYXR0cnMsIG9wdHMpO1xuICAgIH0sXG4gICAgaGlzdG9ncmFtOiBmdW5jdGlvbihhdHRycywgb3B0cywgbGF5ZXJJbmRleCkge1xuICAgICAgb3B0cy5maWx0ZXIgPSBuZXcgUmFuZ2VGaWx0ZXIoe1xuICAgICAgICB3aWRnZXRJZDogYXR0cnMuaWQsXG4gICAgICAgIGxheWVySW5kZXg6IGxheWVySW5kZXhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBIaXN0b2dyYW1Nb2RlbChhdHRycywgb3B0cyk7XG4gICAgfSxcbiAgICAndGltZS1zZXJpZXMnOiBmdW5jdGlvbihhdHRycywgb3B0cywgbGF5ZXJJbmRleCkge1xuICAgICAgLy8gY2hhbmdlIHR5cGUgYmVjYXVzZSB0aW1lLXNlcmllcyBiZWNhdXNlIGl0J3MgcmVhbGx5IGEgaGlzdG9ncmFtIChmb3IgdGhlIHRpbGVyIGF0IGxlYXN0KVxuICAgICAgYXR0cnMudHlwZSA9ICdoaXN0b2dyYW0nO1xuICAgICAgb3B0cy5maWx0ZXIgPSBuZXcgUmFuZ2VGaWx0ZXIoe1xuICAgICAgICB3aWRnZXRJZDogYXR0cnMuaWQsXG4gICAgICAgIGxheWVySW5kZXg6IGxheWVySW5kZXhcbiAgICAgIH0pO1xuICAgICAgdmFyIG1vZGVsID0gbmV3IEhpc3RvZ3JhbU1vZGVsKGF0dHJzLCBvcHRzKTtcblxuICAgICAgLy8gc2luY2Ugd2UgY2hhbmdlZCB0aGUgdHlwZSBvZiB3ZSBuZWVkIHNvbWUgd2F5IHRvIGlkZW50aWZ5IHRoYXQgaXQncyBpbnRlbmRlZCBmb3IgYSB0aW1lLXNlcmllcyB2aWV3IGxhdGVyXG4gICAgICBtb2RlbC5pc0ZvclRpbWVTZXJpZXMgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcbiAgICBhZ2dyZWdhdGlvbjogZnVuY3Rpb24oYXR0cnMsIG9wdHMsIGxheWVySW5kZXgpIHtcbiAgICAgIG9wdHMuZmlsdGVyID0gbmV3IENhdGVnb3J5RmlsdGVyKHtcbiAgICAgICAgd2lkZ2V0SWQ6IGF0dHJzLmlkLFxuICAgICAgICBsYXllckluZGV4OiBsYXllckluZGV4XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlNb2RlbChhdHRycywgb3B0cyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPIGtlZXAgdGhpcyBjb2xsZWN0aW9uIGluIHN5bmMgd2l0aCBsYXllcnMgaW5kaXZpZHVhbCB3aWRnZXRzIGNvbGxlY3Rpb25zXG4gIHZhciB3aWRnZXRzID0gbmV3IFdpZGdldHNDb2xsZWN0aW9uKCk7XG5cbiAgdmFyIGRhc2hib2FyZEluZm9Nb2RlbCA9IG5ldyBNb2RlbCh7XG4gICAgdGl0bGU6IGRpSlNPTi50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogZGlKU09OLmRlc2NyaXB0aW9uLFxuICAgIHVwZGF0ZWRBdDogZGlKU09OLnVwZGF0ZWRfYXQsXG4gICAgdXNlck5hbWU6IGRpSlNPTi51c2VyLmZ1bGxuYW1lLFxuICAgIHVzZXJBdmF0YXJVUkw6IGRpSlNPTi51c2VyLmF2YXRhcl91cmxcbiAgfSk7XG4gIHZhciBkYXNoYm9hcmRWaWV3ID0gbmV3IERhc2hib2FyZFZpZXcoe1xuICAgIGVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcbiAgICB3aWRnZXRzOiB3aWRnZXRzLFxuICAgIGRhc2hib2FyZEluZm9Nb2RlbDogZGFzaGJvYXJkSW5mb01vZGVsXG4gIH0pO1xuXG4gIHZhciB2aXMgPSBjZGIuY3JlYXRlVmlzKGRhc2hib2FyZFZpZXcuJCgnI21hcCcpLCBkaUpTT04udml6SlNPTiwgdmlzT3B0cyk7XG5cbiAgdmFyIGNhcnRvREJMYXllckdyb3VwO1xuICB2YXIgaW50ZXJhY3RpdmVMYXllcnMgPSBbXTtcbiAgdmlzLm1hcC5sYXllcnMuZWFjaChmdW5jdGlvbihsYXllcikge1xuICAgIHZhciBsYXllclR5cGUgPSBsYXllci5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgaXNMYXllckdyb3VwID0gbGF5ZXJUeXBlID09PSAnbGF5ZXJncm91cCc7XG5cbiAgICBpZiAoaXNMYXllckdyb3VwKSB7XG4gICAgICBjYXJ0b0RCTGF5ZXJHcm91cCA9IGxheWVyO1xuICAgIH1cblxuICAgIGlmIChpc0xheWVyR3JvdXAgfHwgbGF5ZXJUeXBlID09PSAnbmFtZWRtYXAnKSB7XG4gICAgICBsYXllci5sYXllcnMuZWFjaChmdW5jdGlvbihzdWJMYXllcikge1xuICAgICAgICBpbnRlcmFjdGl2ZUxheWVycy5wdXNoKHN1YkxheWVyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgaWYgKGxheWVyVHlwZSA9PT0gJ3RvcnF1ZScpIHtcbiAgICAgICAgaW50ZXJhY3RpdmVMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IG1vdmUgdGhpcyBsb2dpYyBzb21ld2hlcmUgZWxzZVxuICB2YXIgd2lkZ2V0TW9kZWxzID0gW107XG4gIGZvciAodmFyIGlkIGluIGRpSlNPTi53aWRnZXRzKSB7XG4gICAgdmFyIGQgPSBkaUpTT04ud2lkZ2V0c1tpZF07XG4gICAgdmFyIGxheWVyID0gXy5maW5kKGludGVyYWN0aXZlTGF5ZXJzLCBmdW5jdGlvbihsKSB7XG4gICAgICByZXR1cm4gZC5sYXllcklkID09PSBsLmdldCgnaWQnKTtcbiAgICB9KTtcbiAgICB2YXIgbGF5ZXJJbmRleCA9IGludGVyYWN0aXZlTGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe1xuICAgICAgICBpZDogaWRcbiAgICAgIH0sIGQpO1xuICAgICAgdmFyIHdpZGdldE1vZGVsID0gd2lkZ2V0TW9kZWxGYWN0b3J5LmNyZWF0ZU1vZGVsKGxheWVyLCBsYXllckluZGV4LCBhdHRycyk7XG4gICAgICB3aWRnZXRNb2RlbHMucHVzaCh3aWRnZXRNb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE8gbGF5ZXJzIGluIGEgbmFtZWRtYXAgZG9lc24ndCBoYXZlIGxheWVySWQsIG5lZWQgc29tZSBvdGhlciB3YXkgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyBsYXllciBmb3IgYSBnaXZlbiB3aWRnZXRcbiAgICAgIHRocm93IEVycm9yKCdubyBsYXllciBmb3VuZCBmb3IgZGVmaW5lZCB3aWRnZXQnKTtcbiAgICB9XG4gIH1cbiAgLy8gXy5lYWNoKGludGVyYWN0aXZlTGF5ZXJzLCBmdW5jdGlvbihsYXllciwgbGF5ZXJJbmRleCkge1xuICAvLyAgIHZhciB3aWRnZXRzQXR0cnMgPSBsYXllci5nZXQoJ3dpZGdldHMnKSB8fCB7fTtcbiAgLy8gICBmb3IgKHZhciBpZCBpbiB3aWRnZXRzQXR0cnMpIHtcbiAgLy8gICAgIHZhciBhdHRycyA9IF8uZXh0ZW5kKHtcbiAgLy8gICAgICAgaWQ6IGlkXG4gIC8vICAgICB9LCB3aWRnZXRzQXR0cnNbaWRdKTtcbiAgLy8gICAgIHZhciB3aWRnZXRNb2RlbCA9IHdpZGdldE1vZGVsRmFjdG9yeS5jcmVhdGVNb2RlbChsYXllciwgbGF5ZXJJbmRleCwgYXR0cnMpO1xuICAvLyAgICAgd2lkZ2V0TW9kZWxzLnB1c2god2lkZ2V0TW9kZWwpO1xuICAvLyAgIH1cbiAgLy8gfSk7XG5cbiAgd2lkZ2V0cy5yZXNldCh3aWRnZXRNb2RlbHMpO1xuXG4gIGRhc2hib2FyZFZpZXcucmVuZGVyKCk7XG5cbiAgLy8gVE9ETzogUGVyaGFwcyB0aGlzIFwiZW5kcG9pbnRcIiBjb3VsZCBiZSBwYXJ0IG9mIHRoZSBcImRhdGFzb3VyY2VcIj9cbiAgdmFyIGVuZHBvaW50ID0gV2luZHNoYWZ0Q29uZmlnLk1BUFNfQVBJX0JBU0VfVVJMO1xuICB2YXIgY29uZmlnR2VuZXJhdG9yID0gV2luZHNoYWZ0UHVibGljRGFzaGJvYXJkQ29uZmlnO1xuICB2YXIgZGF0YXNvdXJjZSA9IGRpSlNPTi5kYXRhc291cmNlO1xuICAvLyBUT0RPOiBXZSBjYW4gdXNlIHNvbWV0aGluZyBlbHNlIHRvIGRpZmZlcmVudGlhdGUgdHlwZXMgb2YgXCJkYXRhc291cmNlXCJzXG4gIGlmIChkYXRhc291cmNlLnRlbXBsYXRlX25hbWUpIHtcbiAgICBlbmRwb2ludCA9IFtXaW5kc2hhZnRDb25maWcuTUFQU19BUElfQkFTRV9VUkwsICduYW1lZCcsIGRhdGFzb3VyY2UudGVtcGxhdGVfbmFtZV0uam9pbignLycpO1xuICAgIGNvbmZpZ0dlbmVyYXRvciA9IFdpbmRzaGFmdFByaXZhdGVEYXNoYm9hcmRDb25maWc7XG4gIH1cblxuICB2YXIgd2luZHNoYWZ0Q2xpZW50ID0gbmV3IFdpbmRzaGFmdENsaWVudCh7XG4gICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxuICAgIHVybFRlbXBsYXRlOiBkYXRhc291cmNlLm1hcHNfYXBpX3RlbXBsYXRlLFxuICAgIHVzZXJOYW1lOiBkYXRhc291cmNlLnVzZXJfbmFtZSxcbiAgICBzdGF0VGFnOiBkYXRhc291cmNlLnN0YXRfdGFnLFxuICAgIGZvcmNlQ29yczogZGF0YXNvdXJjZS5mb3JjZV9jb3JzXG4gIH0pO1xuXG4gIHZhciBkYXNoYm9hcmQgPSBuZXcgV2luZHNoYWZ0RGFzaGJvYXJkKHtcbiAgICBjbGllbnQ6IHdpbmRzaGFmdENsaWVudCxcbiAgICBjb25maWdHZW5lcmF0b3I6IGNvbmZpZ0dlbmVyYXRvcixcbiAgICBzdGF0VGFnOiBkYXRhc291cmNlLnN0YXRfdGFnLFxuICAgIC8vVE9ETzogYXNzdW1pbmcgaGVyZSBhbGwgdml6Lmpzb24gaGFzIGEgbGF5ZXJncm91cCBhbmQgdGhhdCBtYXkgbm90IGJlIHRydWVcbiAgICBsYXllckdyb3VwOiBjYXJ0b0RCTGF5ZXJHcm91cCxcbiAgICBsYXllcnM6IGludGVyYWN0aXZlTGF5ZXJzLFxuICAgIHdpZGdldHM6IHdpZGdldHMsXG4gICAgbWFwOiB2aXMubWFwXG4gIH0pO1xuXG4gIC8vIFRPRE86IHJldGhpbmsgdGhpc1xuICBpZiAod2lkZ2V0cy5zaXplKCkgPiAwKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHZpcy5tYXBWaWV3LmludmFsaWRhdGVTaXplKCk7XG4gICAgfSwgMCk7XG4gIH1cblxuICByZXR1cm4gZGFzaGJvYXJkVmlldztcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIFdpZGdldFZpZXdGYWN0b3J5ID0gcmVxdWlyZSgnLi93aWRnZXRzL3dpZGdldC12aWV3LWZhY3RvcnknKTtcbnZhciBUaW1lU2VyaWVzQ29udGVudFZpZXcgPSByZXF1aXJlKCcuL3dpZGdldHMvdGltZS1zZXJpZXMvY29udGVudC12aWV3Jyk7XG52YXIgVG9ycXVlVGltZVNlcmllc0NvbnRlbnRWaWV3ID0gcmVxdWlyZSgnLi93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS1jb250ZW50LXZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLURhc2hib2FyZC1iZWxvd01hcCcsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuX3dpZGdldFZpZXdGYWN0b3J5ID0gbmV3IFdpZGdldFZpZXdGYWN0b3J5KFtcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAvLyBpc0ZvclRpbWVTZXJpZXMgaXMgc2V0IHRvIHRydWUgdG8gZGlzdGluZ3Vpc2ggZnJvbSBkZWZhdWx0IHR5cGUgJ2hpc3RvZ3JhbSdcbiAgICAgICAgICAvLyBUaGlzIG1hdGNoIG5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlIHRoZSBkZWZhdWx0IHRpbWUtc2VyaWVzIHdpZGdldCdzIG1hdGNoIGJlbG93IHRvIGhhdmUgcHJlc2VkZW5jZVxuICAgICAgICAgIHJldHVybiBtLmlzRm9yVGltZVNlcmllcyAmJiBtLmxheWVyLmdldCgndHlwZScpID09PSAndG9ycXVlJztcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlQ29udGVudFZpZXc6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRvcnF1ZVRpbWVTZXJpZXNDb250ZW50Vmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbSxcbiAgICAgICAgICAgIHJhbmdlRmlsdGVyOiBtLmZpbHRlcixcbiAgICAgICAgICAgIHRvcnF1ZUxheWVyTW9kZWw6IG0ubGF5ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9taXplV2lkZ2V0QXR0cnM6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgICAgYXR0cnMuY2xhc3NOYW1lICs9ICcgQ0RCLVdpZGdldC0tdGltZVNlcmllcyc7XG4gICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgLy8gaXNGb3JUaW1lU2VyaWVzIGlzIHNldCB0byB0cnVlIHRvIGRpc3Rpbmd1aXNoIGZyb20gZGVmYXVsdCB0eXBlICdoaXN0b2dyYW0nXG4gICAgICAgICAgcmV0dXJuIG0uaXNGb3JUaW1lU2VyaWVzO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVDb250ZW50VmlldzogZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVGltZVNlcmllc0NvbnRlbnRWaWV3KHtcbiAgICAgICAgICAgIG1vZGVsOiBtLFxuICAgICAgICAgICAgZmlsdGVyOiBtLmZpbHRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjdXN0b21pemVXaWRnZXRBdHRyczogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgICBhdHRycy5jbGFzc05hbWUgKz0gJyBDREItV2lkZ2V0LS10aW1lU2VyaWVzJztcbiAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdKTtcblxuICAgIHRoaXMuX3dpZGdldHMgPSBvcHRpb25zLndpZGdldHM7XG4gICAgdGhpcy5fd2lkZ2V0cy5iaW5kKCdhZGQnLCB0aGlzLl9tYXliZVJlbmRlcldpZGdldFZpZXcsIHRoaXMpO1xuICAgIHRoaXMuX3dpZGdldHMuYmluZCgncmVzZXQnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLl93aWRnZXRzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgdGhpcy5fd2lkZ2V0cy5lYWNoKHRoaXMuX21heWJlUmVuZGVyV2lkZ2V0VmlldywgdGhpcyk7XG4gICAgdGhpcy4kZWwudG9nZ2xlKCFfLmlzRW1wdHkodGhpcy5fc3Vidmlld3MpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfbWF5YmVSZW5kZXJXaWRnZXRWaWV3OiBmdW5jdGlvbih3aWRnZXRNb2RlbCkge1xuICAgIHZhciB2aWV3ID0gdGhpcy5fd2lkZ2V0Vmlld0ZhY3RvcnkuY3JlYXRlV2lkZ2V0Vmlldyh3aWRnZXRNb2RlbCk7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHRoaXMuYWRkVmlldyh2aWV3KTtcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcbiAgICB9XG4gIH1cblxufSk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2Rhc2hib2FyZC1pbmZvLXZpZXcudHBsJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbnZhciBEYXNoYm9hcmRJbmZvVmlldyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItRGFzaGJvYXJkLWluZm8nLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtdG9nZ2xlLXZpZXctbGluayc6IFwiX3RvZ2dsZVZpZXdcIlxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgdGl0bGU6IHRoaXMubW9kZWwuZ2V0KCd0aXRsZScpLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5tb2RlbC5nZXQoJ2Rlc2NyaXB0aW9uJyksXG4gICAgICAgIHVwZGF0ZWRBdDogbW9tZW50KHRoaXMubW9kZWwuZ2V0KCd1cGRhdGVkQXQnKSkuZnJvbU5vdygpLFxuICAgICAgICB1c2VyTmFtZTogdGhpcy5tb2RlbC5nZXQoJ3VzZXJOYW1lJyksXG4gICAgICAgIHVzZXJBdmF0YXJVUkw6IHRoaXMubW9kZWwuZ2V0KCd1c2VyQXZhdGFyVVJMJylcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF90b2dnbGVWaWV3OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC50b2dnbGVDbGFzcygnaXMtYWN0aXZlJyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhc2hib2FyZEluZm9WaWV3O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLURhc2hib2FyZC1pbmZvSGVhZGVyXCI+IDxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9Mb2dvXCI+IDxpIGNsYXNzPVwiQ0RCLUljb24gQ0RCLUljb24tY2FydG9mYW50ZVwiPjwvaT4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9BY3Rpb25zXCI+IDxidXR0b24gY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9BY3Rpb25zTGluayBqcy10b2dnbGUtdmlldy1saW5rXCI+PC9idXR0b24+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLURhc2hib2FyZC1pbmZvVGV4dHNcIj4gPHAgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9VcGRhdGVcIj5VUERBVEVEICcrXG4oKF9fdD0oIHVwZGF0ZWRBdCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+IDxoMSBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb1RpdGxlXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMT4gPGgyIGNsYXNzPVwiQ0RCLURhc2hib2FyZC1pbmZvRGVzY3JpcHRpb25cIj4nK1xuKChfX3Q9KCBkZXNjcmlwdGlvbiApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2gyPiA8L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9Gb290ZXJcIj4gPHVsPiAgPGxpIGNsYXNzPVwiQ0RCLURhc2hib2FyZC1pbmZvRm9vdGVySXRlbVwiPiA8ZGl2IGNsYXNzPVwiQ0RCLURhc2hib2FyZC1pbmZvTWVkaWEgQ0RCLURhc2hib2FyZC1pbmZvQXZhdGFyXCI+IDxpbWcgc3JjPVwiJytcbigoX190PSggdXNlckF2YXRhclVSTCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIiBhbHQ9XCJhdmF0YXJcIiBjbGFzcz1cImlubGluZS1ibG9ja1wiPiA8L2Rpdj4gPHAgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9Gb290ZXJUeHRcIj4nK1xuKChfX3Q9KCB1c2VyTmFtZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+IDwvbGk+IDwvdWw+IDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgJCA9IGNkYi4kO1xudmFyIFBzID0gcmVxdWlyZSgncGVyZmVjdC1zY3JvbGxiYXInKTtcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIENhdGVnb3J5Q29udGVudFZpZXcgPSByZXF1aXJlKCcuL3dpZGdldHMvY2F0ZWdvcnkvY29udGVudF92aWV3Jyk7XG52YXIgRm9ybXVsYUNvbnRlbnRWaWV3ID0gcmVxdWlyZSgnLi93aWRnZXRzL2Zvcm11bGEvY29udGVudF92aWV3Jyk7XG52YXIgSGlzdG9ncmFtQ29udGVudFZpZXcgPSByZXF1aXJlKCcuL3dpZGdldHMvaGlzdG9ncmFtL2NvbnRlbnQtdmlldycpO1xudmFyIExpc3RDb250ZW50VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9saXN0L2NvbnRlbnRfdmlldycpO1xudmFyIFdpZGdldFZpZXdGYWN0b3J5ID0gcmVxdWlyZSgnLi93aWRnZXRzL3dpZGdldC12aWV3LWZhY3RvcnknKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLXNpZGViYXIudHBsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtY2FudmFzJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fd2lkZ2V0Vmlld0ZhY3RvcnkgPSBuZXcgV2lkZ2V0Vmlld0ZhY3RvcnkoW1xuICAgICAge1xuICAgICAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgICAgIGNyZWF0ZUNvbnRlbnRWaWV3OiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGb3JtdWxhQ29udGVudFZpZXcoe1xuICAgICAgICAgICAgbW9kZWw6IG1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgIGNyZWF0ZUNvbnRlbnRWaWV3OiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMaXN0Q29udGVudFZpZXcoe1xuICAgICAgICAgICAgbW9kZWw6IG1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBtLmdldCgndHlwZScpID09PSAnaGlzdG9ncmFtJyAmJiBtLmxheWVyLmdldCgndHlwZScpICE9PSAndG9ycXVlJztcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlQ29udGVudFZpZXc6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvZ3JhbUNvbnRlbnRWaWV3KHtcbiAgICAgICAgICAgIGRhdGFNb2RlbDogbSxcbiAgICAgICAgICAgIHZpZXdNb2RlbDogbmV3IE1vZGVsKCksXG4gICAgICAgICAgICBmaWx0ZXI6IG0uZmlsdGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0aW9uJyxcbiAgICAgICAgY3JlYXRlQ29udGVudFZpZXc6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENhdGVnb3J5Q29udGVudFZpZXcoe1xuICAgICAgICAgICAgbW9kZWw6IG0sXG4gICAgICAgICAgICBmaWx0ZXI6IG0uZmlsdGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdKTtcblxuICAgIHRoaXMuX3dpZGdldHMgPSBvcHRpb25zLndpZGdldHM7XG5cbiAgICB0aGlzLl93aWRnZXRzLmJpbmQoJ2FkZCcsIHRoaXMuX21heWJlUmVuZGVyV2lkZ2V0VmlldywgdGhpcyk7XG4gICAgdGhpcy5fd2lkZ2V0cy5iaW5kKCdyZXNldCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLl93aWRnZXRzLmJpbmQoJ2NoYW5nZTpjb2xsYXBzZWQnLCB0aGlzLl9vbldpZGdldENvbGxhcHNlZCwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLl93aWRnZXRzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFuU2Nyb2xsRXZlbnQoKTtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcblxuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoKSk7XG4gICAgdGhpcy5fd2lkZ2V0cy5lYWNoKHRoaXMuX21heWJlUmVuZGVyV2lkZ2V0VmlldywgdGhpcyk7XG4gICAgdGhpcy4kZWwudG9nZ2xlKCFfLmlzRW1wdHkodGhpcy5fc3Vidmlld3MpKTtcblxuICAgIHRoaXMuX3JlbmRlclNjcm9sbCgpO1xuICAgIHRoaXMuX3JlbmRlclNoYWRvd3MoKTtcbiAgICB0aGlzLl9iaW5kU2Nyb2xsKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfJGNvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICQodGhpcy5fY29udGFpbmVyKCkpO1xuICB9LFxuXG4gIF9jb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5qcy1jb250YWluZXInKTtcbiAgfSxcblxuICBfbWF5YmVSZW5kZXJXaWRnZXRWaWV3OiBmdW5jdGlvbih3aWRnZXRNb2RlbCkge1xuICAgIHZhciB2aWV3ID0gdGhpcy5fd2lkZ2V0Vmlld0ZhY3RvcnkuY3JlYXRlV2lkZ2V0Vmlldyh3aWRnZXRNb2RlbCk7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHRoaXMuYWRkVmlldyh2aWV3KTtcbiAgICAgIHRoaXMuXyRjb250YWluZXIoKS5hcHBlbmQodmlldy5yZW5kZXIoKS5lbCk7XG4gICAgfVxuICB9LFxuXG4gIF9iaW5kU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl8kY29udGFpbmVyKClcbiAgICAgIC5vbigncHMteS1yZWFjaC1zdGFydCcsIF8uYmluZCh0aGlzLl9vblNjcm9sbFRvcCwgdGhpcykpXG4gICAgICAub24oJ3BzLXktcmVhY2gtZW5kJywgXy5iaW5kKHRoaXMuX29uU2Nyb2xsQm90dG9tLCB0aGlzKSlcbiAgICAgIC5vbigncHMtc2Nyb2xsLXknLCBfLmJpbmQodGhpcy5fb25TY3JvbGwsIHRoaXMpKTtcbiAgfSxcblxuICBfcmVuZGVyU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICBQcy5pbml0aWFsaXplKHRoaXMuX2NvbnRhaW5lcigpLCB7XG4gICAgICB3aGVlbFNwZWVkOiAyLFxuICAgICAgd2hlZWxQcm9wYWdhdGlvbjogdHJ1ZSxcbiAgICAgIG1pblNjcm9sbGJhckxlbmd0aDogMjBcbiAgICB9KTtcbiAgfSxcblxuICBfb25XaWRnZXRDb2xsYXBzZWQ6IGZ1bmN0aW9uKCkge1xuICAgIFBzLnVwZGF0ZSh0aGlzLl9jb250YWluZXIoKSk7XG4gIH0sXG5cbiAgX3JlbmRlclNoYWRvd3M6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLiRzaGFkb3dUb3AgPSAkKCc8ZGl2PicpLmFkZENsYXNzKFwiQ0RCLVdpZGdldC1jYW52YXNTaGFkb3cgQ0RCLVdpZGdldC1jYW52YXNTaGFkb3ctLXRvcFwiKTtcbiAgICB0aGlzLiRzaGFkb3dCb3R0b20gPSAkKCc8ZGl2PicpLmFkZENsYXNzKFwiQ0RCLVdpZGdldC1jYW52YXNTaGFkb3cgQ0RCLVdpZGdldC1jYW52YXNTaGFkb3ctLWJvdHRvbSBpcy12aXNpYmxlXCIpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLiRzaGFkb3dUb3ApO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLiRzaGFkb3dCb3R0b20pO1xuICB9LFxuXG4gIF9vblNjcm9sbFRvcDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kc2hhZG93VG9wLnJlbW92ZUNsYXNzKCdpcy12aXNpYmxlJyk7XG4gIH0sXG5cbiAgX29uU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgJGVsID0gdGhpcy5fJGNvbnRhaW5lcigpO1xuICAgIHZhciBjdXJyZW50UG9zID0gJGVsLnNjcm9sbFRvcCgpO1xuICAgIHZhciBtYXggPSAkZWwuZ2V0KDApLnNjcm9sbEhlaWdodDtcbiAgICB2YXIgaGVpZ2h0ID0gJGVsLm91dGVySGVpZ2h0KCk7XG4gICAgdmFyIG1heFBvcyA9IG1heCAtIGhlaWdodDtcbiAgICB0aGlzLiRzaGFkb3dUb3AudG9nZ2xlQ2xhc3MoJ2lzLXZpc2libGUnLCBjdXJyZW50UG9zID4gMCk7XG4gICAgdGhpcy4kc2hhZG93Qm90dG9tLnRvZ2dsZUNsYXNzKCdpcy12aXNpYmxlJywgY3VycmVudFBvcyA8IG1heFBvcyk7XG4gIH0sXG5cbiAgX29uU2Nyb2xsQm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRzaGFkb3dCb3R0b20ucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgfSxcblxuICBfY2xlYW5TY3JvbGxFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuXyRjb250YWluZXIoKSkge1xuICAgICAgdGhpcy5fJGNvbnRhaW5lcigpLm9mZigncHMtc2Nyb2xsLXknKTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFuU2Nyb2xsRXZlbnQoKTtcbiAgICBWaWV3LnByb3RvdHlwZS5jbGVhbi5jYWxsKHRoaXMpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jYW52YXNJbm5lciBqcy1jb250YWluZXJcIj48L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2Rhc2hib2FyZC50cGwnKTtcbnZhciBEYXNoYm9hcmRCZWxvd01hcFZpZXcgPSByZXF1aXJlKCcuL2Rhc2hib2FyZC1iZWxvdy1tYXAtdmlldycpO1xudmFyIERhc2hib2FyZEluZm9WaWV3ID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQtaW5mby12aWV3Jyk7XG52YXIgRGFzaGJvYXJkU2lkZWJhclZpZXcgPSByZXF1aXJlKCcuL2Rhc2hib2FyZC1zaWRlYmFyLXZpZXcnKTtcblxuLyoqXG4gKiBEYXNoYm9hcmQgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgbWFwIGNhbnZhcywgd2hpY2ggY29udGFpbnMgd2lkZ2V0IHZpZXdzIGZvciB0aGUgbWFwIGNvbnRkeHRcbiAqIFdpZGdldHMgbWF5IGJlIHJlbmRlcmVkIGluIHR3byBhcmVhcywgaW4gdGhlIFwic2lkZWJhclwiIG9yIFwiYmVsb3ctbWFwXCIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1EYXNoYm9hcmQtY2FudmFzJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fd2lkZ2V0cyA9IG9wdGlvbnMud2lkZ2V0cztcbiAgICB0aGlzLl9kYXNoYm9hcmRJbmZvTW9kZWwgPSBvcHRpb25zLmRhc2hib2FyZEluZm9Nb2RlbDtcblxuICAgIC8vIFRPRE8gcGFyZW50IGNvbnRleHQgcmVxdWlyZXMgc29tZSBtYXJrdXAgdG8gYmUgcHJlc2VudCBhbHJlYWR5LCBidXQgTk9UIHRoZSBvdGhlciB2aWV3c1xuICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuXG4gICAgdmFyIHZpZXc7XG4gICAgdmlldyA9IG5ldyBEYXNoYm9hcmRJbmZvVmlldyh7XG4gICAgICBtb2RlbDogdGhpcy5fZGFzaGJvYXJkSW5mb01vZGVsXG4gICAgfSk7XG4gICAgdGhpcy5hZGRWaWV3KHZpZXcpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcblxuICAgIHZpZXcgPSBuZXcgRGFzaGJvYXJkQmVsb3dNYXBWaWV3KHtcbiAgICAgIHdpZGdldHM6IHRoaXMuX3dpZGdldHNcbiAgICB9KTtcbiAgICB0aGlzLmFkZFZpZXcodmlldyk7XG4gICAgdGhpcy4kKCcuanMtbWFwLXdyYXBwZXInKS5hcHBlbmQodmlldy5yZW5kZXIoKS5lbCk7XG5cbiAgICB2aWV3ID0gbmV3IERhc2hib2FyZFNpZGViYXJWaWV3KHtcbiAgICAgIHdpZGdldHM6IHRoaXMuX3dpZGdldHNcbiAgICB9KTtcbiAgICB0aGlzLmFkZFZpZXcodmlldyk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHZpZXcucmVuZGVyKCkuZWwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLURhc2hib2FyZC1tYXBXcmFwcGVyIENEQi1EYXNoYm9hcmQtbWFwV3JhcHBlci0tbWFyZ2luIGpzLW1hcC13cmFwcGVyXCI+IDxkaXYgY2xhc3M9XCJDREItTWFwLWNhbnZhc1wiPiA8ZGl2IGNsYXNzPVwiQ0RCLU1hcFwiIGlkPVwibWFwXCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIF8gPSBjZGIuXztcbnZhciBkMyA9IGNkYi5kMztcbnZhciBsb2cgPSBjZGIubG9nO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xuXG4vKipcbiAqIEFuaW1hdGUgYmV0d2VlbiB0d28gdmFsdWVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGFuaW1hdGVGcm9tVmFsdWVzOiBmdW5jdGlvbihmcm9tLCB0bywgY2xhc3NOYW1lLCB0ZW1wbGF0ZSwgb3B0cykge1xuICAgIHZhciAkZWwgPSB0aGlzLiQoY2xhc3NOYW1lKTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIGZvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IGQzLmZvcm1hdCgnMCwwMDAnKTtcbiAgICB2YXIgdGVtcGxhdGVEYXRhID0gb3B0aW9ucy50ZW1wbGF0ZURhdGEgfHwge307XG4gICAgdmFyIGRlYm91bmNlV2FpdCA9IG9wdGlvbnMuZGVib3VuY2VXYWl0IHx8IDUwMDtcblxuICAgIHZhciBzdGVwVmFsdWUgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgdmFsdWUgPSAoXy5pc05hTihpKSB8fCBpID09PSB1bmRlZmluZWQpID8gKG9wdGlvbnMuZGVmYXVsdFZhbHVlIHx8IDApIDogZm9ybWF0dGVyKGkpO1xuICAgICAgdmFyIGRhdGEgPSBfLmV4dGVuZCh7IHZhbHVlOiB2YWx1ZSB9LCB0ZW1wbGF0ZURhdGEpO1xuICAgICAgJGVsLnRleHQodGVtcGxhdGUoZGF0YSkpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb25TcGVlZCA9PT0gMCkge1xuICAgICAgc3RlcFZhbHVlKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGVwVmFsdWUoZnJvbSk7XG5cbiAgICB2YXIgYW5pbWF0ZSA9IF8uZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAkZWwucHJvcCgnY291bnRlcicsIGZyb20pLnN0b3AoKS5hbmltYXRlKHsgY291bnRlcjogdG8gfSwge1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25TcGVlZCB8fCA1MDAsXG4gICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmdNZXRob2QgfHwgJ3N3aW5nJyxcbiAgICAgICAgc3RlcDogc3RlcFZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBkZWJvdW5jZVdhaXQpO1xuXG4gICAgYW5pbWF0ZSgpO1xuICB9LFxuXG4gIGFuaW1hdGVGcm9tQ3VycmVudFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgY2xhc3NOYW1lLCB0ZW1wbGF0ZSwgb3B0cykge1xuICAgIHZhciAkZWwgPSB0aGlzLiQoY2xhc3NOYW1lKTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZGVib3VuY2VXYWl0ID0gb3B0aW9ucy5kZWJvdW5jZVdhaXQgfHwgNTAwO1xuXG4gICAgdmFyIHRvICAgPSB2YWx1ZTtcbiAgICB2YXIgZnJvbSA9ICt0aGlzLiQoY2xhc3NOYW1lKS50ZXh0KCk7XG5cbiAgICB2YXIgZm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgZDMuZm9ybWF0KCcwLDAwMCcpO1xuICAgIHZhciB0ZW1wbGF0ZURhdGEgPSBvcHRpb25zLnRlbXBsYXRlRGF0YSB8fCB7fTtcblxuICAgIHZhciBzdGVwVmFsdWUgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgdmFsdWUgPSAoXy5pc05hTihpKSB8fCBpID09PSB1bmRlZmluZWQpID8gKG9wdGlvbnMuZGVmYXVsdFZhbHVlIHx8IDApIDogZm9ybWF0dGVyKGkpO1xuICAgICAgdmFyIGRhdGEgPSBfLmV4dGVuZCh7IHZhbHVlOiB2YWx1ZSB9LCB0ZW1wbGF0ZURhdGEpO1xuICAgICAgJGVsLnRleHQodGVtcGxhdGUoZGF0YSkpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb25TcGVlZCA9PT0gMCkge1xuICAgICAgc3RlcFZhbHVlKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGVwVmFsdWUoZnJvbSk7XG5cbiAgICB2YXIgYW5pbWF0ZSA9IF8uZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAkZWwucHJvcCgnY291bnRlcicsIGZyb20pLnN0b3AoKS5hbmltYXRlKHsgY291bnRlcjogdG8gfSwge1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25TcGVlZCB8fCA1MDAsXG4gICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmdNZXRob2QgfHwgJ3N3aW5nJyxcbiAgICAgICAgc3RlcDogc3RlcFZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBkZWJvdW5jZVdhaXQpO1xuXG4gICAgYW5pbWF0ZSgpO1xuICB9LFxuXG4gIGFuaW1hdGVWYWx1ZTogZnVuY3Rpb24obW9kZWwsIHdoYXQsIGNsYXNzTmFtZSwgdGVtcGxhdGUsIG9wdHMpIHtcbiAgICB2YXIgJGVsID0gdGhpcy4kKGNsYXNzTmFtZSk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIGRlYm91bmNlV2FpdCA9IG9wdGlvbnMuZGVib3VuY2VXYWl0IHx8IDUwMDtcblxuICAgIHZhciB0byAgID0gbW9kZWwuZ2V0KHdoYXQpO1xuICAgIHZhciBmcm9tID0gbW9kZWwucHJldmlvdXMod2hhdCkgfHwgMDtcblxuICAgIHZhciBmb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBkMy5mb3JtYXQoJzAsMDAwJyk7XG4gICAgdmFyIHRlbXBsYXRlRGF0YSA9IG9wdGlvbnMudGVtcGxhdGVEYXRhIHx8IHt9O1xuXG4gICAgdmFyIHN0ZXBWYWx1ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YWx1ZSA9IChfLmlzTmFOKGkpIHx8IGkgPT09IHVuZGVmaW5lZCkgPyAob3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgMCkgOiBmb3JtYXR0ZXIoaSk7XG4gICAgICB2YXIgZGF0YSA9IF8uZXh0ZW5kKHsgdmFsdWU6IHZhbHVlIH0sIHRlbXBsYXRlRGF0YSk7XG4gICAgICAkZWwudGV4dCh0ZW1wbGF0ZShkYXRhKSk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvblNwZWVkID09PSAwKSB7XG4gICAgICBzdGVwVmFsdWUodG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0ZXBWYWx1ZShmcm9tKTtcblxuICAgIHZhciBhbmltYXRlID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICRlbC5wcm9wKCdjb3VudGVyJywgZnJvbSkuc3RvcCgpLmFuaW1hdGUoeyBjb3VudGVyOiB0byB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvblNwZWVkIHx8IDUwMCxcbiAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZ01ldGhvZCB8fCAnc3dpbmcnLFxuICAgICAgICBzdGVwOiBzdGVwVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIGRlYm91bmNlV2FpdCk7XG5cbiAgICBhbmltYXRlKCk7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXIganMtaGVhZGVyXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnQgQ0RCLVdpZGdldC1jb250ZW50LS1ub1NpZGVzTWFyZ2luXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RXcmFwcGVyIGpzLWNvbnRlbnRcIj48L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWZvb3RlciBqcy1mb290ZXJcIj48L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFdpZGdldENvbnRlbnQgPSByZXF1aXJlKCcuLi9zdGFuZGFyZC93aWRnZXRfY29udGVudF92aWV3Jyk7XG52YXIgU2VhcmNoVGl0bGVWaWV3ID0gcmVxdWlyZSgnLi90aXRsZS9zZWFyY2hfdGl0bGVfdmlldycpO1xudmFyIENhdGVnb3J5T3B0aW9uc1ZpZXcgPSByZXF1aXJlKCcuL29wdGlvbnMvb3B0aW9uc192aWV3Jyk7XG52YXIgQ2F0ZWdvcnlJdGVtc1ZpZXcgPSByZXF1aXJlKCcuL2xpc3QvaXRlbXNfdmlldycpO1xudmFyIFdpZGdldFZpZXdNb2RlbCA9IHJlcXVpcmUoJy4uL3dpZGdldF9jb250ZW50X21vZGVsJyk7XG52YXIgQ2F0ZWdvcnlTdGF0c1ZpZXcgPSByZXF1aXJlKCcuL3N0YXRzL3N0YXRzX3ZpZXcnKTtcbnZhciBDYXRlZ29yeVBhZ2luYXRvclZpZXcgPSByZXF1aXJlKCcuL3BhZ2luYXRvci9wYWdpbmF0b3JfdmlldycpO1xudmFyIFNlYXJjaENhdGVnb3J5SXRlbXNWaWV3ID0gcmVxdWlyZSgnLi9saXN0L3NlYXJjaF9pdGVtc192aWV3Jyk7XG52YXIgU2VhcmNoQ2F0ZWdvcnlQYWdpbmF0b3JWaWV3ID0gcmVxdWlyZSgnLi9wYWdpbmF0b3Ivc2VhcmNoX3BhZ2luYXRvcl92aWV3Jyk7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2NvbnRlbnRfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogQ29udGVudCB2aWV3IGZvciBjYXRlZ29yeSB3aWRnZXRcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRDb250ZW50LmV4dGVuZCh7XG5cbiAgX0lURU1TX1BFUl9QQUdFOiA2LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBXaWRnZXRWaWV3TW9kZWwoKTtcbiAgICBXaWRnZXRDb250ZW50LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoKSk7XG4gICAgdGhpcy5faW5pdFZpZXdzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6Y29sbGFwc2VkJywgZnVuY3Rpb24obWRsLCBpc0NvbGxhcHNlZCkge1xuICAgICAgdGhpcy4kZWwudG9nZ2xlQ2xhc3MoJ2lzLWNvbGxhcHNlZCcsICEhaXNDb2xsYXBzZWQpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIF9pbml0Vmlld3M6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWFyY2hUaXRsZSA9IG5ldyBTZWFyY2hUaXRsZVZpZXcoe1xuICAgICAgdmlld01vZGVsOiB0aGlzLnZpZXdNb2RlbCxcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5tb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuJCgnLmpzLWhlYWRlcicpLmFwcGVuZChzZWFyY2hUaXRsZS5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHNlYXJjaFRpdGxlKTtcblxuICAgIHZhciBzdGF0cyA9IG5ldyBDYXRlZ29yeVN0YXRzVmlldyh7XG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtaGVhZGVyJykuYXBwZW5kKHN0YXRzLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc3RhdHMpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBuZXcgQ2F0ZWdvcnlPcHRpb25zVmlldyh7XG4gICAgICBkYXRhTW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtY29udGVudCcpLmh0bWwob3B0aW9ucy5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KG9wdGlvbnMpO1xuXG4gICAgdmFyIGRhdGFMaXN0ID0gbmV3IENhdGVnb3J5SXRlbXNWaWV3KHtcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWwsXG4gICAgICBkYXRhTW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICBpdGVtc1BlclBhZ2U6IHRoaXMuX0lURU1TX1BFUl9QQUdFXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtY29udGVudCcpLmFwcGVuZChkYXRhTGlzdC5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KGRhdGFMaXN0KTtcblxuICAgIHZhciBwYWdpbmF0aW9uID0gbmV3IENhdGVnb3J5UGFnaW5hdG9yVmlldyh7XG4gICAgICAkdGFyZ2V0OiBkYXRhTGlzdC4kZWwsXG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgaXRlbXNQZXJQYWdlOiB0aGlzLl9JVEVNU19QRVJfUEFHRVxuICAgIH0pO1xuICAgIHRoaXMuJCgnLmpzLWZvb3RlcicpLmFwcGVuZChwYWdpbmF0aW9uLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcocGFnaW5hdGlvbik7XG5cbiAgICB2YXIgc2VhcmNoTGlzdCA9IG5ldyBTZWFyY2hDYXRlZ29yeUl0ZW1zVmlldyh7XG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgaXRlbXNQZXJQYWdlOiB0aGlzLl9JVEVNU19QRVJfUEFHRSxcbiAgICAgIHBhZ2luYXRvcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuJCgnLmpzLWNvbnRlbnQnKS5hcHBlbmQoc2VhcmNoTGlzdC5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHNlYXJjaExpc3QpO1xuXG4gICAgdmFyIHNlYXJjaFBhZ2luYXRpb24gPSBuZXcgU2VhcmNoQ2F0ZWdvcnlQYWdpbmF0b3JWaWV3KHtcbiAgICAgICR0YXJnZXQ6IHNlYXJjaExpc3QuJGVsLFxuICAgICAgdmlld01vZGVsOiB0aGlzLnZpZXdNb2RlbCxcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIGl0ZW1zUGVyUGFnZTogdGhpcy5fSVRFTVNfUEVSX1BBR0UsXG4gICAgICBwYWdpbmF0b3I6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLiQoJy5qcy1mb290ZXInKS5hcHBlbmQoc2VhcmNoUGFnaW5hdGlvbi5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHNlYXJjaFBhZ2luYXRpb24pO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1Jbm5lciBDREItV2lkZ2V0LWxpc3RCdXR0b24ganMtYnV0dG9uICcrXG4oKF9fdD0oIGlzRGlzYWJsZWQgPyAnaXMtZGlzYWJsZWQnIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCBDREItV2lkZ2V0LXRleHRTbWFsbC0tYm9sZCBDREItV2lkZ2V0LXRleHRTbWFsbC0tdXBwZXJcIiB0aXRsZT1cIicrXG4oKF9fdD0oIG5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggbmFtZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlclwiIHRpdGxlPVwiJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggcHJlZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIGZvcm1hdHRlZFZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHN1ZmZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1wcm9ncmVzc0JhclwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1wcm9ncmVzc1N0YXRlICcrXG4oKF9fdD0oIGlzQWdncmVnYXRlZCA/ICdDREItV2lkZ2V0LXByb2dyZXNzU3RhdGUtLXBhdHRlcm4nIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCIgc3R5bGU9XCJ3aWR0aDogJytcbigoX190PSggcGVyY2VudGFnZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbiclOyBiYWNrZ3JvdW5kLWNvbG9yOiAnK1xuKChfX3Q9KCBjdXN0b21Db2xvciA/IGNvbG9yIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9kaXY+IDwvZGl2PiA8L2J1dHRvbj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtSW5uZXIgJytcbigoX190PSggaXNEaXNhYmxlZCA/ICdpcy1kaXNhYmxlZCcgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsIENEQi1XaWRnZXQtdGV4dFNtYWxsLS1ib2xkIENEQi1XaWRnZXQtdGV4dFNtYWxsLS11cHBlclwiIHRpdGxlPVwiJytcbigoX190PSggbmFtZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBuYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyXCIgdGl0bGU9XCInK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBwcmVmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggZm9ybWF0dGVkVmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggc3VmZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXByb2dyZXNzQmFyXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXByb2dyZXNzU3RhdGUgQ0RCLVdpZGdldC1wcm9ncmVzc1N0YXRlLS1wYXR0ZXJuICcrXG4oKF9fdD0oIGlzQWdncmVnYXRlZCA/ICdDREItV2lkZ2V0LXByb2dyZXNzU3RhdGUtLWluYWN0aXZlJyA6ICcnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiIHN0eWxlPVwid2lkdGg6ICcrXG4oKF9fdD0oIHBlcmNlbnRhZ2UgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJTsgYmFja2dyb3VuZC1jb2xvcjogJytcbigoX190PSggY3VzdG9tQ29sb3IgPyBjb2xvciA6ICcnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPjwvZGl2PiA8L2Rpdj4gPC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBmb3JtYXR0ZXIgPSBjZGIuY29yZS5mb3JtYXQ7XG52YXIgY2xpY2thYmxlVGVtcGxhdGUgPSByZXF1aXJlKCcuL2l0ZW1fY2xpY2thYmxlX3RlbXBsYXRlLnRwbCcpO1xudmFyIHVuY2xpY2thYmxlVGVtcGxhdGUgPSByZXF1aXJlKCcuL2l0ZW1fdW5jbGlja2FibGVfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgbGlzdCBpdGVtIHZpZXdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgdGFnTmFtZTogJ2xpJyxcbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1saXN0SXRlbScsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1idXR0b24nOiAnX29uSXRlbUNsaWNrJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLmdldCgndmFsdWUnKTtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm1vZGVsLmdldCgnYWdnJykgfHzCoHRoaXMuZGF0YU1vZGVsLmlzTG9ja2VkKCkgP1xuICAgICAgdW5jbGlja2FibGVUZW1wbGF0ZSA6IGNsaWNrYWJsZVRlbXBsYXRlO1xuXG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgY3VzdG9tQ29sb3I6IHRoaXMuZGF0YU1vZGVsLmlzQ29sb3JBcHBsaWVkKCksXG4gICAgICAgIGlzQWdncmVnYXRlZDogdGhpcy5tb2RlbC5nZXQoJ2FnZycpLFxuICAgICAgICBuYW1lOiB0aGlzLm1vZGVsLmdldCgnbmFtZScpLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyKHZhbHVlKSxcbiAgICAgICAgcGVyY2VudGFnZTogKCh2YWx1ZSAvIHRoaXMuZGF0YU1vZGVsLmdldCgnbWF4JykpICogMTAwKSxcbiAgICAgICAgY29sb3I6IHRoaXMubW9kZWwuZ2V0KCdjb2xvcicpLFxuICAgICAgICBpc0Rpc2FibGVkOiAhdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJykgPyAnaXMtZGlzYWJsZWQnIDogJycsXG4gICAgICAgIHByZWZpeDogdGhpcy5kYXRhTW9kZWwuZ2V0KCdwcmVmaXgnKSxcbiAgICAgICAgc3VmZml4OiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3N1ZmZpeCcpXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZScsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoIGNoYW5nZTpjYXRlZ29yeUNvbG9ycycsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuZGF0YU1vZGVsKTtcbiAgfSxcblxuICBfb25JdGVtQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJpZ2dlcignaXRlbUNsaWNrZWQnLCB0aGlzLm1vZGVsLCB0aGlzKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtSW5uZXIgQ0RCLVdpZGdldC1saXN0SXRlbUlubmVyLS1mdWxsU3BhY2UgQ0RCLVdpZGdldC1saXN0QnV0dG9uIGpzLWJ1dHRvbiAnK1xuKChfX3Q9KCBpc0Rpc2FibGVkID8gJ2lzLWRpc2FibGVkJyA6ICcnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiA8c3BhbiBjbGFzcz1cIkNEQi1XaWRnZXQtY2hlY2tib3ggJytcbigoX190PSggaXNEaXNhYmxlZCA/ICcnIDogJ2lzLWNoZWNrZWQnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPjwvc3Bhbj4gPGRpdiBjbGFzcz1cInUtbFNwYWNlLS14bFwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGwgQ0RCLVdpZGdldC10ZXh0U21hbGwtLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGwtLXVwcGVyXCIgdGl0bGU9XCInK1xuKChfX3Q9KCBuYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIG5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9wPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXJcIiB0aXRsZT1cIicrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIHByZWZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCBzdWZmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9wPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtcHJvZ3Jlc3NCYXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtcHJvZ3Jlc3NTdGF0ZVwiIHN0eWxlPVwid2lkdGg6ICcrXG4oKF9fdD0oIHBlcmNlbnRhZ2UgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJVwiPjwvZGl2PiA8L2Rpdj4gPC9kaXY+IDwvYnV0dG9uPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vc2VhcmNoX2l0ZW1fY2xpY2thYmxlX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIENhdGVnb3J5IHNlYXJjaCBsaXN0IHZpZXdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgdGFnTmFtZTogJ2xpJyxcbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1saXN0SXRlbScsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1idXR0b24nOiAnX29uSXRlbUNsaWNrJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGRhdGEgbW9kZWwgY29tZXMgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSBpbiBvcmRlciB0byBnZXRcbiAgICAvLyB0aGUgbWF4IHZhbHVlIGFuZCBzZXQgcHJvcGVybHkgdGhlIHByb2dyZXNzIGJhciBhbmQgYWRkIHRoZVxuICAgIC8vIG5lY2Vzc2FyeSBzdWZmaXggYW5kIHByZWZpeCBmb3IgdGhlIGl0ZW0uXG4gICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLm9wdGlvbnMuZGF0YU1vZGVsO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5nZXQoJ3ZhbHVlJyk7XG5cbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICBuYW1lOiB0aGlzLm1vZGVsLmdldCgnbmFtZScpLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyKHZhbHVlKSxcbiAgICAgICAgcGVyY2VudGFnZTogKCh2YWx1ZSAvIHRoaXMuZGF0YU1vZGVsLmdldCgnbWF4JykpICogMTAwKSxcbiAgICAgICAgaXNEaXNhYmxlZDogIXRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZCcpLFxuICAgICAgICBwcmVmaXg6IHRoaXMuZGF0YU1vZGVsLmdldCgncHJlZml4JyksXG4gICAgICAgIHN1ZmZpeDogdGhpcy5kYXRhTW9kZWwuZ2V0KCdzdWZmaXgnKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6c2VsZWN0ZWQnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gIH0sXG5cbiAgX29uSXRlbUNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnc2VsZWN0ZWQnLCAhdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJykpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtIENEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2xpPiA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtIENEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2xpPiA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtIENEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2xpPiA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtIENEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2xpPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIENhdGVnb3J5SXRlbVZpZXcgPSByZXF1aXJlKCcuL2l0ZW0vaXRlbV92aWV3Jyk7XG52YXIgcGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL2l0ZW1zX3BsYWNlaG9sZGVyX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIENhdGVnb3J5IGxpc3Qgdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBvcHRpb25zOiB7XG4gICAgcGFnaW5hdG9yOiBmYWxzZSxcbiAgICBpdGVtc1BlclBhZ2U6IDZcbiAgfSxcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWxpc3QgQ0RCLVdpZGdldC1saXN0LS13cmFwcGVkIGpzLWxpc3QnLFxuICB0YWdOYW1lOiAndWwnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5vcHRpb25zLnZpZXdNb2RlbDtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBpc0RhdGFFbXB0eSA9IF8uaXNFbXB0eShkYXRhKSB8fCBfLnNpemUoZGF0YSkgPT09IDA7XG5cbiAgICBpZiAoaXNEYXRhRW1wdHkpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBsYWNlaG9sZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlckxpc3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwuYmluZCgnY2hhbmdlOnNlYXJjaCcsIHRoaXMudG9nZ2xlLCB0aGlzKTtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6ZGF0YSBjaGFuZ2U6c2VhcmNoRGF0YScsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuZGF0YU1vZGVsKTtcbiAgfSxcblxuICBfcmVuZGVyUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIENoYW5nZSB2aWV3IGNsYXNzZXNcbiAgICB0aGlzLiRlbFxuICAgICAgLmFkZENsYXNzKCdDREItV2lkZ2V0LWxpc3QtLXdpdGhCb3JkZXJzJylcbiAgICAgIC5yZW1vdmVDbGFzcygnQ0RCLVdpZGdldC1saXN0LS13cmFwcGVkJyk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHBsYWNlaG9sZGVyKCkpO1xuICB9LFxuXG4gIF9yZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBDaGFuZ2UgdmlldyBjbGFzc2VzXG4gICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdC0td2l0aEJvcmRlcnMnKTtcbiAgICB0aGlzLiRlbFsgdGhpcy5vcHRpb25zLnBhZ2luYXRvciA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnQ0RCLVdpZGdldC1saXN0LS13cmFwcGVkJyk7XG5cbiAgICB2YXIgZ3JvdXBJdGVtO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgZGF0YS5lYWNoKGZ1bmN0aW9uKG1kbCwgaSkge1xuICAgICAgaWYgKGkgJSB0aGlzLm9wdGlvbnMuaXRlbXNQZXJQYWdlID09PSAwKSB7XG4gICAgICAgIGdyb3VwSXRlbSA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdEdyb3VwJyk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChncm91cEl0ZW0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWRkSXRlbShtZGwsIGdyb3VwSXRlbSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX2FkZEl0ZW06IGZ1bmN0aW9uKG1kbCwgJHBhcmVudCkge1xuICAgIHZhciB2ID0gbmV3IENhdGVnb3J5SXRlbVZpZXcoe1xuICAgICAgbW9kZWw6IG1kbCxcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5kYXRhTW9kZWxcbiAgICB9KTtcbiAgICB2LmJpbmQoJ2l0ZW1DbGlja2VkJywgdGhpcy5fc2V0RmlsdGVycywgdGhpcyk7XG4gICAgdGhpcy5hZGRWaWV3KHYpO1xuICAgICRwYXJlbnQuYXBwZW5kKHYucmVuZGVyKCkuZWwpO1xuICB9LFxuXG4gIF9zZXRGaWx0ZXJzOiBmdW5jdGlvbihtZGwpIHtcbiAgICB2YXIgaXNTZWxlY3RlZCA9IG1kbC5nZXQoJ3NlbGVjdGVkJyk7XG5cbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgaWYgKCF0aGlzLmRhdGFNb2RlbC5nZXRSZWplY3RlZENvdW50KCkgJiYgIXRoaXMuZGF0YU1vZGVsLmdldEFjY2VwdGVkQ291bnQoKSAmJiB0aGlzLmRhdGFNb2RlbC5nZXRDb3VudCgpID4gMSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YU1vZGVsLmdldERhdGEoKTtcbiAgICAgICAgdmFyIHJlamVjdHMgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBlbGVtZW50cyBcInVuc2VsZWN0ZWRcIlxuICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBtLmdldCgnbmFtZScpO1xuICAgICAgICAgIGlmIChuYW1lICE9PSBtZGwuZ2V0KCduYW1lJykpIHtcbiAgICAgICAgICAgIG0uc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5hY2NlcHRGaWx0ZXJzKG1kbC5nZXQoJ25hbWUnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZGwuc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwucmVqZWN0RmlsdGVycyhtZGwuZ2V0KCduYW1lJykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZGwuc2V0KCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgdGhpcy5kYXRhTW9kZWwuYWNjZXB0RmlsdGVycyhtZGwuZ2V0KCduYW1lJykpO1xuICAgIH1cbiAgfSxcblxuICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbICF0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSA/ICdzaG93JyA6ICdoaWRlJ10oKTtcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnaXMtaGlkZGVuJyk7XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtXCI+IDxoNCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZyBDREItV2lkZ2V0LXRleHRCaWctLWJvbGRcIj5ObyByZXN1bHRzPC9oND4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCB1LXRTcGFjZS14bFwiPllvdXIgc2VhcmNoIFwiJytcbigoX190PSggcSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIiBkaWRuXFwndCBtYXRjaDxicj53aXRoIGFueSB2YWx1ZS48L3A+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGwgdS10U3BhY2UteGxcIj5Ucnkgc2VhcmNoaW5nIGFnYWluLjwvcD4gPC9saT4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBDYXRlZ29yeUl0ZW1zVmlldyA9IHJlcXVpcmUoJy4vaXRlbXNfdmlldycpO1xudmFyIFdpZGdldFNlYXJjaENhdGVnb3J5SXRlbVZpZXcgPSByZXF1aXJlKCcuL2l0ZW0vc2VhcmNoX2l0ZW1fdmlldycpO1xudmFyIHBsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9zZWFyY2hfaXRlbXNfbm9fcmVzdWx0c190ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBDYXRlZ29yeSBsaXN0IHZpZXdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBDYXRlZ29yeUl0ZW1zVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbGlzdCBpcy1oaWRkZW4gQ0RCLVdpZGdldC1saXN0LS13cmFwcGVkIGpzLWxpc3QnLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YU1vZGVsLmdldFNlYXJjaFJlc3VsdCgpO1xuICAgIHZhciBpc0RhdGFFbXB0eSA9IGRhdGEuaXNFbXB0eSgpIHx8IGRhdGEuc2l6ZSgpID09PSAwO1xuXG4gICAgaWYgKGlzRGF0YUVtcHR5KSB7XG4gICAgICB0aGlzLl9yZW5kZXJQbGFjZWhvbGRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJMaXN0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9yZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnQ0RCLVdpZGdldC1saXN0LS13aXRoQm9yZGVycyBDREItV2lkZ2V0LWxpc3QtLW5vcmVzdWx0cycpO1xuICAgIHRoaXMuJGVsLmFkZENsYXNzKCdDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQnKTtcblxuICAgIHZhciBncm91cEl0ZW07XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXRTZWFyY2hSZXN1bHQoKTtcblxuICAgIGRhdGEuZWFjaChmdW5jdGlvbihtZGwsIGkpIHtcbiAgICAgIGlmIChpICUgdGhpcy5vcHRpb25zLml0ZW1zUGVyUGFnZSA9PT0gMCkge1xuICAgICAgICBncm91cEl0ZW0gPSAkKCc8ZGl2PicpLmFkZENsYXNzKCdDREItV2lkZ2V0LWxpc3RHcm91cCcpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoZ3JvdXBJdGVtKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZEl0ZW0obWRsLCBncm91cEl0ZW0pO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIF9yZW5kZXJQbGFjZWhvbGRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hhbmdlIHZpZXcgY2xhc3Nlc1xuICAgIHRoaXMuJGVsXG4gICAgICAuYWRkQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdC0tbm9yZXN1bHRzJylcbiAgICAgIC5yZW1vdmVDbGFzcygnQ0RCLVdpZGdldC1saXN0LS13cmFwcGVkJyk7XG5cbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgcGxhY2Vob2xkZXIoe1xuICAgICAgICBxOiB0aGlzLmRhdGFNb2RlbC5nZXRTZWFyY2hRdWVyeSgpXG4gICAgICB9KVxuICAgICk7XG4gIH0sXG5cbiAgX2FkZEl0ZW06IGZ1bmN0aW9uKG1kbCwgJHBhcmVudCkge1xuICAgIHZhciB2ID0gbmV3IFdpZGdldFNlYXJjaENhdGVnb3J5SXRlbVZpZXcoe1xuICAgICAgbW9kZWw6IG1kbCxcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5kYXRhTW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLmFkZFZpZXcodik7XG4gICAgJHBhcmVudC5hcHBlbmQodi5yZW5kZXIoKS5lbCk7XG4gIH0sXG5cbiAgdG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzWyB0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSA/ICdzaG93JyA6ICdoaWRlJ10oKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBkMyA9IGNkYi5kMztcbnZhciBDYXRlZ29yeUNvbG9ycyA9IHJlcXVpcmUoJy4vbW9kZWxzL2NhdGVnb3J5X2NvbG9ycycpO1xudmFyIFdpZGdldE1vZGVsID0gcmVxdWlyZSgnLi4vd2lkZ2V0X21vZGVsJyk7XG52YXIgV2lkZ2V0U2VhcmNoTW9kZWwgPSByZXF1aXJlKCcuL21vZGVscy9zZWFyY2hfbW9kZWwnKTtcbnZhciBDYXRlZ29yeU1vZGVsUmFuZ2UgPSByZXF1aXJlKCcuL21vZGVscy9jYXRlZ29yeV9tb2RlbF9yYW5nZScpO1xudmFyIENhdGVnb3JpZXNDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9tb2RlbHMvY2F0ZWdvcmllc19jb2xsZWN0aW9uJyk7XG52YXIgTG9ja2VkQ2F0c0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL21vZGVscy9sb2NrZWRfY2F0ZWdvcmllc19jb2xsZWN0aW9uJyk7XG5cbi8qKlxuICogIENhdGVnb3J5IHdpZGdldCBtb2RlbFxuICpcbiAqICAtIEl0IGhhcyBzZXZlcmFsIGludGVybmFsIG1vZGVscy9jb2xsZWN0aW9uc1xuICpcbiAqICDCtyBzZWFyY2ggbW9kZWw6IGl0IG1hbmFnZXMgY2F0ZWdvcnkgc2VhcmNoIHJlc3VsdHMuXG4gKiAgwrcgbG9ja2VkIGNvbGxlY3Rpb246IGl0IHN0b3JlcyBsb2NrZWQgaXRlbXMuXG4gKiAgwrcgZmlsdGVyIG1vZGVsOiBpdCBrbm93cyB3aGljaCBpdGVtcyBhcmUgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0TW9kZWwuZXh0ZW5kKHtcblxuICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndXJsJykgKyAnP2Jib3g9JyArIHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpICsgJyZvd25fZmlsdGVyPScgKyAodGhpcy5nZXQoJ2xvY2tlZCcpID8gMSA6IDApO1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgdGhpcy5fZGF0YSA9IG5ldyBDYXRlZ29yaWVzQ29sbGVjdGlvbigpO1xuXG4gICAgV2lkZ2V0TW9kZWwucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0cyk7XG5cbiAgICAvLyBMb2NrZWQgY2F0ZWdvcmllcyBjb2xsZWN0aW9uXG4gICAgdGhpcy5sb2NrZWQgPSBuZXcgTG9ja2VkQ2F0c0NvbGxlY3Rpb24oKTtcblxuICAgIC8vIEludGVybmFsIG1vZGVsIGZvciBjYWxjdWxhdGluZyB0b3RhbCBhbW91bnQgb2YgdmFsdWVzIGluIHRoZSBjYXRlZ29yeVxuICAgIHRoaXMucmFuZ2VNb2RlbCA9IG5ldyBDYXRlZ29yeU1vZGVsUmFuZ2UoKTtcblxuICAgIC8vIENvbG9ycyBjbGFzc1xuICAgIHRoaXMuY29sb3JzID0gbmV3IENhdGVnb3J5Q29sb3JzKCk7XG5cbiAgICAvLyBTZWFyY2ggbW9kZWxcbiAgICB0aGlzLnNlYXJjaCA9IG5ldyBXaWRnZXRTZWFyY2hNb2RlbCh7fSwge1xuICAgICAgbG9ja2VkOiB0aGlzLmxvY2tlZFxuICAgIH0pO1xuICB9LFxuXG4gIC8vIFNldCBhbnkgbmVlZGVkIHBhcmFtZXRlciB3aGVuIHRoZXkgaGF2ZSBjaGFuZ2VkIGluIHRoaXMgbW9kZWxcbiAgX3NldEludGVybmFsTW9kZWxzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXJsID0gdGhpcy5nZXQoJ3VybCcpO1xuXG4gICAgdGhpcy5zZWFyY2guc2V0KHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgYm91bmRpbmdCb3g6IHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpXG4gICAgfSk7XG5cbiAgICB0aGlzLnJhbmdlTW9kZWwuc2V0VXJsKHVybCk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlQmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldEludGVybmFsTW9kZWxzKCk7XG5cbiAgICB0aGlzLnJhbmdlTW9kZWwuYmluZCgnY2hhbmdlOnRvdGFsQ291bnQnLCBmdW5jdGlvbihtZGwsIHZhbHVlKSB7XG4gICAgICB0aGlzLnNldCgndG90YWxDb3VudCcsIHZhbHVlKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYmluZCgnY2hhbmdlOnVybCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZiAodGhpcy5nZXQoJ3N5bmMnKSAmJiAhdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIHRoaXMuX2ZldGNoKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTpib3VuZGluZ0JveCcsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSWYgYSBzZWFyY2ggaXMgYXBwbGllZCBhbmQgYm91bmRpbmcgYm91bmRzIGhhcyBjaGFuZ2VkLFxuICAgICAgLy8gZG9uJ3QgZmV0Y2ggbmV3IHJhdyBkYXRhXG4gICAgICBpZiAodGhpcy5nZXQoJ2Jib3gnKSAmJiAhdGhpcy5pc1NlYXJjaEFwcGxpZWQoKSAmJiAhdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIHRoaXMuX2ZldGNoKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTp1cmwgY2hhbmdlOmJvdW5kaW5nQm94JywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNlYXJjaC5zZXQoe1xuICAgICAgICB1cmw6IHRoaXMuZ2V0KCd1cmwnKSxcbiAgICAgICAgYm91bmRpbmdCb3g6IHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYmluZCgnY2hhbmdlOmNvbGxhcHNlZCcsIGZ1bmN0aW9uKG1kbCwgaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICghaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKG1kbC5jaGFuZ2VkQXR0cmlidXRlcyh0aGlzLl9wcmV2aW91c0F0dHJzKSkge1xuICAgICAgICAgIHRoaXMuX2ZldGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cnMgPSB7XG4gICAgICAgICAgdXJsOiB0aGlzLmdldCgndXJsJyksXG4gICAgICAgICAgYm91bmRpbmdCb3g6IHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmxvY2tlZC5iaW5kKCdjaGFuZ2UgYWRkIHJlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6bG9ja0NvbGxlY3Rpb24nLCB0aGlzLmxvY2tlZCwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnNlYXJjaC5iaW5kKCdsb2FkaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJsb2FkaW5nXCIsIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuc2VhcmNoLmJpbmQoJ3N5bmMnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcInN5bmNcIiwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5zZWFyY2guYmluZCgnZXJyb3InLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWUgfHwgKGUgJiYgZS5zdGF0dXNUZXh0ICE9PSBcImFib3J0XCIpKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcImVycm9yXCIsIHRoaXMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuc2VhcmNoLmJpbmQoJ2NoYW5nZTpkYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpzZWFyY2hEYXRhJywgdGhpcy5zZWFyY2gsIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qXG4gICAqICBIZWxwZXIgbWV0aG9kcyBmb3IgaW50ZXJuYWwgbW9kZWxzL2NvbGxlY3Rpb25zXG4gICAqXG4gICAqL1xuXG4gIGFwcGx5Q2F0ZWdvcnlDb2xvcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdjYXRlZ29yeUNvbG9ycycsIHRydWUpO1xuICAgIHZhciBjb2xvcnNEYXRhID0gdGhpcy5fZGF0YS5tYXAoZnVuY3Rpb24obSl7XG4gICAgICByZXR1cm4gWyBtLmdldCgnbmFtZScpLCBtLmdldCgnY29sb3InKSBdO1xuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcignYXBwbHlDYXRlZ29yeUNvbG9ycycsIGNvbG9yc0RhdGEsIHRoaXMpO1xuICB9LFxuXG4gIGNhbmNlbENhdGVnb3J5Q29sb3JzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnY2F0ZWdvcnlDb2xvcnMnLCBmYWxzZSk7XG4gICAgdGhpcy50cmlnZ2VyKCdjYW5jZWxDYXRlZ29yeUNvbG9ycycsIHRoaXMpO1xuICB9LFxuXG4gIGlzQ29sb3JBcHBsaWVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2NhdGVnb3J5Q29sb3JzJyk7XG4gIH0sXG5cbiAgLy8gTG9ja2VkIGNvbGxlY3Rpb24gaGVscGVyIG1ldGhvZHMgLy9cblxuICBnZXRMb2NrZWRTaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NrZWQuc2l6ZSgpO1xuICB9LFxuXG4gIGlzTG9ja2VkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2xvY2tlZCcpO1xuICB9LFxuXG4gIGNhbkJlTG9ja2VkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xvY2tlZCgpIHx8XG4gICAgICB0aGlzLmdldEFjY2VwdGVkQ291bnQoKSA+IDA7XG4gIH0sXG5cbiAgY2FuQXBwbHlMb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhY2NlcHRlZENvbGxlY3Rpb24gPSB0aGlzLmZpbHRlci5nZXRBY2NlcHRlZCgpO1xuICAgIGlmICh0aGlzLmZpbHRlci5nZXRBY2NlcHRlZCgpLnNpemUoKSAhPT0gdGhpcy5sb2NrZWQuc2l6ZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWRDb2xsZWN0aW9uLmZpbmQoZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuICF0aGlzLmxvY2tlZC5pc0l0ZW1Mb2NrZWQobS5nZXQoJ25hbWUnKSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgYXBwbHlMb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50TG9ja2VkID0gdGhpcy5sb2NrZWQuZ2V0SXRlbXNOYW1lKCk7XG4gICAgaWYgKCFjdXJyZW50TG9ja2VkLmxlbmd0aCkge1xuICAgICAgdGhpcy51bmxvY2tDYXRlZ29yaWVzKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc2V0KCdsb2NrZWQnLCB0cnVlKTtcbiAgICB0aGlzLmZpbHRlci5jbGVhbkZpbHRlcihmYWxzZSk7XG4gICAgdGhpcy5maWx0ZXIuYWNjZXB0KGN1cnJlbnRMb2NrZWQpO1xuICAgIHRoaXMuZmlsdGVyLmFwcGx5RmlsdGVyKCk7XG4gICAgdGhpcy5jbGVhblNlYXJjaCgpO1xuICB9LFxuXG4gIGxvY2tDYXRlZ29yaWVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnbG9ja2VkJywgdHJ1ZSk7XG4gICAgdGhpcy5fZmV0Y2goKTtcbiAgfSxcblxuICB1bmxvY2tDYXRlZ29yaWVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnbG9ja2VkJywgZmFsc2UpO1xuICAgIHRoaXMuYWNjZXB0QWxsKCk7XG4gIH0sXG5cbiAgLy8gU2VhcmNoIG1vZGVsIGhlbHBlciBtZXRob2RzIC8vXG5cbiAgZ2V0U2VhcmNoUXVlcnk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlYXJjaC5nZXRTZWFyY2hRdWVyeSgpO1xuICB9LFxuXG4gIHNldFNlYXJjaFF1ZXJ5OiBmdW5jdGlvbihxKSB7XG4gICAgdGhpcy5zZWFyY2guc2V0KCdxJywgcSk7XG4gIH0sXG5cbiAgaXNTZWFyY2hWYWxpZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoLmlzVmFsaWQoKTtcbiAgfSxcblxuICBnZXRTZWFyY2hSZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlYXJjaC5nZXREYXRhKCk7XG4gIH0sXG5cbiAgZ2V0U2VhcmNoQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlYXJjaC5nZXRDb3VudCgpO1xuICB9LFxuXG4gIGFwcGx5U2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNlYXJjaC5mZXRjaCgpO1xuICB9LFxuXG4gIGlzU2VhcmNoQXBwbGllZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoLmlzU2VhcmNoQXBwbGllZCgpO1xuICB9LFxuXG4gIGNsZWFuU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxvY2tlZC5yZXNldEl0ZW1zKFtdKTtcbiAgICB0aGlzLnNlYXJjaC5yZXNldERhdGEoKTtcbiAgfSxcblxuICBzZXR1cFNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VhcmNoQXBwbGllZCgpKSB7XG4gICAgICB2YXIgYWNjZXB0ZWRDYXRzID0gdGhpcy5maWx0ZXIuZ2V0QWNjZXB0ZWQoKS50b0pTT04oKTtcbiAgICAgIHRoaXMubG9ja2VkLmFkZEl0ZW1zKGFjY2VwdGVkQ2F0cyk7XG4gICAgICB0aGlzLnNlYXJjaC5zZXREYXRhKFxuICAgICAgICB0aGlzLl9kYXRhLnRvSlNPTigpXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICAvLyBGaWx0ZXIgbW9kZWwgaGVscGVyIG1ldGhvZHMgLy9cblxuICBnZXRSZWplY3RlZENvdW50OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIucmVqZWN0ZWRDYXRlZ29yaWVzLnNpemUoKTtcbiAgfSxcblxuICBnZXRBY2NlcHRlZENvdW50OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIuYWNjZXB0ZWRDYXRlZ29yaWVzLnNpemUoKTtcbiAgfSxcblxuICBhY2NlcHRGaWx0ZXJzOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICB0aGlzLmZpbHRlci5hY2NlcHQodmFsdWVzKTtcbiAgfSxcblxuICByZWplY3RGaWx0ZXJzOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICB0aGlzLmZpbHRlci5yZWplY3QodmFsdWVzKTtcbiAgfSxcblxuICByZWplY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZmlsdGVyLnJlamVjdEFsbCgpO1xuICB9LFxuXG4gIGFjY2VwdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maWx0ZXIuYWNjZXB0QWxsKCk7XG4gIH0sXG5cbiAgaXNBbGxGaWx0ZXJzUmVqZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlci5nZXQoJ3JlamVjdEFsbCcpO1xuICB9LFxuXG4gIC8vIFByb3BlciBtb2RlbCBoZWxwZXIgbWV0aG9kcyAvL1xuXG4gIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9LFxuXG4gIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnNpemUoKTtcbiAgfSxcblxuICBnZXRDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdjYXRlZ29yaWVzQ291bnQnKTtcbiAgfSxcblxuICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1NlYXJjaEFwcGxpZWQoKSkge1xuICAgICAgdGhpcy5zZWFyY2guZmV0Y2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gRGF0YSBwYXJzZXIgbWV0aG9kcyAvL1xuXG4gIF9wYXJzZURhdGE6IGZ1bmN0aW9uKGNhdGVnb3JpZXMpIHtcbiAgICB2YXIgbmV3RGF0YSA9IFtdO1xuICAgIHZhciBfdG1wQXJyYXkgPSB7fTtcbiAgICB2YXIgYWNjZXB0ZWRDYXRzID0gdGhpcy5maWx0ZXIuZ2V0QWNjZXB0ZWQoKTtcblxuICAgIC8vIFVwZGF0ZSBjb2xvcnMgYnkgZGF0YSBjYXRlZ29yaWVzXG4gICAgdGhpcy5jb2xvcnMudXBkYXRlRGF0YShcbiAgICAgIF8udW5pcShcbiAgICAgICAgXy51bmlvbihcbiAgICAgICAgICBfLnBsdWNrKGNhdGVnb3JpZXMsICdjYXRlZ29yeScpLFxuICAgICAgICAgIF8ucGx1Y2soYWNjZXB0ZWRDYXRzLCAnbmFtZScpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuXG4gICAgXy5lYWNoKGNhdGVnb3JpZXMsIGZ1bmN0aW9uKGRhdHVtLCBpKSB7XG4gICAgICB2YXIgY2F0ZWdvcnkgPSBkYXR1bS5jYXRlZ29yeTtcbiAgICAgIHZhciBpc1JlamVjdGVkID0gdGhpcy5maWx0ZXIuaXNSZWplY3RlZChjYXRlZ29yeSk7XG4gICAgICBfdG1wQXJyYXlbY2F0ZWdvcnldID0gdHJ1ZTtcblxuICAgICAgbmV3RGF0YS5wdXNoKHtcbiAgICAgICAgc2VsZWN0ZWQ6ICFpc1JlamVjdGVkLFxuICAgICAgICBuYW1lOiBjYXRlZ29yeSxcbiAgICAgICAgYWdnOiBkYXR1bS5hZ2csXG4gICAgICAgIHZhbHVlOiBkYXR1bS52YWx1ZSxcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3JzLmdldENvbG9yQnlDYXRlZ29yeShjYXRlZ29yeSlcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgLy8gQWRkIGFjY2VwdGVkIGl0ZW1zIHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBjYXRlZ29yaWVzIGRhdGFcbiAgICAgIGFjY2VwdGVkQ2F0cy5lYWNoKGZ1bmN0aW9uKG1kbCwgaSkge1xuICAgICAgICB2YXIgY2F0ZWdvcnkgPSBtZGwuZ2V0KCduYW1lJykudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCFfdG1wQXJyYXlbY2F0ZWdvcnldKSB7XG4gICAgICAgICAgbmV3RGF0YS5wdXNoKHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3JzLmdldENvbG9yQnlDYXRlZ29yeShjYXRlZ29yeSksXG4gICAgICAgICAgICBuYW1lOiBjYXRlZ29yeSxcbiAgICAgICAgICAgIGFnZzogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbmV3RGF0YVxuICAgIH1cbiAgfSxcblxuICBzZXRDYXRlZ29yaWVzOiBmdW5jdGlvbihkKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fcGFyc2VEYXRhKGQpO1xuICAgIHRoaXMuX2RhdGEucmVzZXQoYXR0cnMuZGF0YSk7XG4gICAgdGhpcy5zZXQoYXR0cnMpO1xuICAgIGlmICh0aGlzLmlzQ29sb3JBcHBsaWVkKCkpIHtcbiAgICAgIHRoaXMuYXBwbHlDYXRlZ29yeUNvbG9ycygpO1xuICAgIH1cbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZCkge1xuICAgIHZhciBjYXRlZ29yaWVzID0gZC5jYXRlZ29yaWVzO1xuICAgIHZhciBhdHRycyA9IHRoaXMuX3BhcnNlRGF0YShjYXRlZ29yaWVzKTtcblxuICAgIF8uZXh0ZW5kKGF0dHJzLCB7XG4gICAgICAgIG51bGxzOiBkLm51bGxzLFxuICAgICAgICBtaW46IGQubWluLFxuICAgICAgICBtYXg6IGQubWF4LFxuICAgICAgICBjb3VudDogZC5jb3VudCxcbiAgICAgICAgY2F0ZWdvcmllc0NvdW50OiBkLmNhdGVnb3JpZXNDb3VudFxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5fZGF0YS5yZXNldChhdHRycy5kYXRhKTtcbiAgICBpZiAodGhpcy5pc0NvbG9yQXBwbGllZCgpKSB7XG4gICAgICB0aGlzLmFwcGx5Q2F0ZWdvcnlDb2xvcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9LFxuXG4gIC8vIEJhY2tib25lIHRvSnNvbiBmdW5jdGlvbiBvdmVycmlkZVxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYWdncmVnYXRpb25cIixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY29sdW1uOiB0aGlzLmdldCgnY29sdW1uJyksXG4gICAgICAgIGFnZ3JlZ2F0aW9uOiB0aGlzLmdldCgnYWdncmVnYXRpb24nKSxcbiAgICAgICAgYWdncmVnYXRpb25Db2x1bW46IHRoaXMuZ2V0KCdhZ2dyZWdhdGlvbkNvbHVtbicpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgQ2F0ZWdvcnlJdGVtTW9kZWwgPSByZXF1aXJlKCcuL2NhdGVnb3J5X2l0ZW1fbW9kZWwnKTtcblxuLyoqXG4gKiAgRGF0YSBjYXRlZ29yaWVzIGNvbGxlY3Rpb25cbiAqXG4gKiAgLSBJdCBiYXNpY2FsbHkgc29ydHMgYnkgKHZhbHVlLCBzZWxlY3RlZCBhbmQgXCJPdGhlclwiKS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuICBtb2RlbDogQ2F0ZWdvcnlJdGVtTW9kZWwsXG5cbiAgY29tcGFyYXRvcjogZnVuY3Rpb24oYSxiKSB7XG4gICAgaWYgKGEuZ2V0KCduYW1lJykgPT09ICdPdGhlcicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYi5nZXQoJ25hbWUnKSA9PT0gJ090aGVyJykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYS5nZXQoJ3ZhbHVlJykgPT09IGIuZ2V0KCd2YWx1ZScpKSB7XG4gICAgICByZXR1cm4gKGEuZ2V0KCdzZWxlY3RlZCcpIDwgYi5nZXQoJ3NlbGVjdGVkJykpID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGEuZ2V0KCd2YWx1ZScpIDwgYi5nZXQoJ3ZhbHVlJykpID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG4vLyB2YXIgY29sb3JicmV3ZXIgPSByZXF1aXJlKCdjb2xvcmJyZXdlcicpO1xuLy8gdmFyIGNhdGVnb3J5Q29sb3JzID0gXy5pbml0aWFsKGNvbG9yYnJld2VyLkFjY2VudFs4XSk7IC8vIENvbG9yIGJyZXdlciBjb2xvcnNcbnZhciBjYXRlZ29yeUNvbG9ycyA9IFsnIzJDQTA5NScsJyNFNTgxMUInLCcjNEE0REJBJywnI0FEMkJBRCcsJyM1NTkwMzAnLCcjRTFDMjIxJ107IC8vIERlbW8gY29sb3JzXG52YXIgZGVmYXVsdENvbG9yID0gJyNDQ0MnO1xuXG4vKipcbiAqICBDbGFzcyB0byBzZXQgY2F0ZWdvcmllcyB0byBlYWNoIGNvbG9yXG4gKiAgLSBSaWdodCBub3csIHRoZXJlIGlzIGEgcmVsYXRpb24gMSBjb2xvciB0byAxIGNhdGVnb3J5LlxuICogIC0gSWYgdGhhdCBjYXRlZ29yeSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBuZXcgZGF0YSwgdGhhdFxuICogICAgY29sb3Igd2lsbCBiZSBmcmVlZC5cbiAqXG4gKi9cblxuZnVuY3Rpb24gQ2F0ZWdvcnlDb2xvcnMoKSB7XG4gIHRoaXMuY29sb3JzID0ge307XG4gIF8uZWFjaChjYXRlZ29yeUNvbG9ycywgZnVuY3Rpb24oYykge1xuICAgIHRoaXMuY29sb3JzW2NdID0gbnVsbDtcbiAgfSwgdGhpcyk7XG59XG5cbkNhdGVnb3J5Q29sb3JzLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24oZCkge1xuICAvLyBSZW1vdmUgY2F0ZWdvcmllcyBmcm9tIGNvbG9ycyB3aGVyZSB0aGV5IGFyZSBub3QgcHJlc2VudCBhbnltb3JlXG4gIF8uZWFjaCh0aGlzLmNvbG9ycywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGlmICghXy5jb250YWlucyhkLCB2YWx1ZSkpIHtcbiAgICAgIHRoaXMuY29sb3JzW2tleV0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gXy53aXRob3V0KGQsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIC8vIFNldCBjb2xvcnMgYnkgbmV3IGNhdGVnb3JpZXNcbiAgXy5lYWNoKGQsIGZ1bmN0aW9uKGNhdGVnb3J5KSB7XG4gICAgdmFyIG5leHRGcmVlQ29sb3IgPSB0aGlzLmdldE5leHRBdmFpbGFibGVDb2xvcigpO1xuICAgIGlmIChuZXh0RnJlZUNvbG9yKSB7XG4gICAgICB0aGlzLmNvbG9yc1tuZXh0RnJlZUNvbG9yXSA9IGNhdGVnb3J5O1xuICAgIH1cbiAgfSwgdGhpcyk7XG59O1xuXG5DYXRlZ29yeUNvbG9ycy5wcm90b3R5cGUuZ2V0TmV4dEF2YWlsYWJsZUNvbG9yID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgaW4gdGhpcy5jb2xvcnMpIHtcbiAgICBpZiAodGhpcy5jb2xvcnNbaV0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbkNhdGVnb3J5Q29sb3JzLnByb3RvdHlwZS5nZXRDb2xvckJ5Q2F0ZWdvcnkgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbG9ycykge1xuICAgIGlmICh0aGlzLmNvbG9yc1tpXSA9PT0gY2F0ZWdvcnkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdENvbG9yO1xufTtcblxuQ2F0ZWdvcnlDb2xvcnMucHJvdG90eXBlLmdldENhdGVnb3J5QnlDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICByZXR1cm4gdGhpcy5jb2xvcnNbY29sb3JdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXRlZ29yeUNvbG9ycztcbiIsIlxudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG5cbi8qKlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICBuYW1lOiAnJyxcbiAgICBhZ2c6IGZhbHNlLFxuICAgIHZhbHVlOiAwXG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG5cbi8qKlxuICogIFRoaXMgbW9kZWwgaXMgdXNlZCBmb3IgZ2V0dGluZyB0aGUgdG90YWwgYW1vdW50IG9mIHZhbHVlc1xuICogIGZyb20gdGhlIGNhdGVnb3J5LlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICB1cmw6ICcnLFxuICAgIHRvdGFsQ291bnQ6IDBcbiAgfSxcblxuICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndXJsJyk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6dXJsJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZldGNoKCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgc2V0VXJsOiBmdW5jdGlvbih1cmwpIHtcbiAgICB0aGlzLnNldCgndXJsJywgdXJsKTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZCkge1xuICAgIC8vIENhbGN1bGF0aW5nIHRoZSB0b3RhbCBhbW91bnQgb2YgYWxsIGNhdGVnb3JpZXMgd2l0aCB0aGUgc3VtIG9mIGFsbFxuICAgIC8vIHZhbHVlcyBmcm9tIHRoaXMgbW9kZWwgaW5jbHVkZWQgdGhlIGFnZ3JlZ2F0ZWQgKE90aGVyKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsQ291bnQ6IF8ucmVkdWNlKFxuICAgICAgICBfLnBsdWNrKGQuY2F0ZWdvcmllcywgJ3ZhbHVlJyksXG4gICAgICAgIGZ1bmN0aW9uKG1lbW8sIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG1lbW8gKyB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgMFxuICAgICAgKVxuICAgIH07XG4gIH1cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBDYXRlZ29yeUl0ZW1Nb2RlbCA9IHJlcXVpcmUoJy4vY2F0ZWdvcnlfaXRlbV9tb2RlbCcpO1xuXG4vKipcbiAqICBMb2NrZWQgY2F0ZWdvcmllcyBjb2xsZWN0aW9uXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIG1vZGVsOiBDYXRlZ29yeUl0ZW1Nb2RlbCxcblxuICBhZGRJdGVtOiBmdW5jdGlvbihtZGwpIHtcbiAgICBpZiAoIXRoaXMuaXNJdGVtTG9ja2VkKG1kbC5nZXQoJ25hbWUnKSkpIHtcbiAgICAgIHRoaXMuYWRkKG1kbCk7XG4gICAgfVxuICB9LFxuXG4gIGFkZEl0ZW1zOiBmdW5jdGlvbihtZGxzKSB7XG4gICAgXy5lYWNoKG1kbHMsIGZ1bmN0aW9uKG0pIHtcbiAgICAgIGlmICghdGhpcy5pc0l0ZW1Mb2NrZWQobS5uYW1lKSkge1xuICAgICAgICB0aGlzLmFkZChtKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICByZXNldEl0ZW1zOiBmdW5jdGlvbihtZGxzKSB7XG4gICAgdGhpcy5yZXNldChtZGxzKTtcbiAgfSxcblxuICByZW1vdmVJdGVtOiBmdW5jdGlvbihtZGwpIHtcbiAgICB2YXIgbG9ja2VkSXRlbSA9IHRoaXMuaXNJdGVtTG9ja2VkKG1kbC5nZXQoJ25hbWUnKSk7XG4gICAgaWYgKGxvY2tlZEl0ZW0pIHtcbiAgICAgIHRoaXMucmVtb3ZlKGxvY2tlZEl0ZW0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXNldChbXSk7XG4gIH0sXG5cbiAgaXNJdGVtTG9ja2VkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gZC5nZXQoJ25hbWUnKSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgfSxcblxuICBnZXRJdGVtc05hbWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBsdWNrKCduYW1lJyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgQ2F0ZWdvcmllc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NhdGVnb3JpZXNfY29sbGVjdGlvbicpO1xuXG4vKipcbiAqIENhdGVnb3J5IHNlYXJjaCBtb2RlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICBxOiAnJyxcbiAgICBkYXRhOiBbXSxcbiAgICB1cmw6ICcnXG4gIH0sXG5cbiAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3VybCcpICsgJy9zZWFyY2g/cT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZ2V0KCdxJykpO1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgLy8gTG9ja2VkIGNvbGxlY3Rpb24gd2lsbCBoYXZlIHRoZSBzdGF0dXNcbiAgICAvLyBvZiB0aGUgc2VsZWN0ZWQvbG9ja2VkIGl0ZW1zXG4gICAgdGhpcy5sb2NrZWQgPSBvcHRzLmxvY2tlZDtcbiAgICB0aGlzLl9kYXRhID0gbmV3IENhdGVnb3JpZXNDb2xsZWN0aW9uKCk7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGF0YS5iaW5kKCdjaGFuZ2U6c2VsZWN0ZWQnLCB0aGlzLl9vbkNoYW5nZVNlbGVjdGVkLCB0aGlzKTtcbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTpib3VuZGluZ0JveCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNTZWFyY2hBcHBsaWVkKCkpIHtcbiAgICAgICAgdGhpcy5mZXRjaCgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgY2F0ZWdvcmllcyA9IHRoaXMuX3BhcnNlRGF0YShkYXRhKTtcbiAgICB0aGlzLl9kYXRhLnJlc2V0KGNhdGVnb3JpZXMpO1xuICAgIHRoaXMuc2V0KCdkYXRhJywgY2F0ZWdvcmllcyk7XG4gIH0sXG5cbiAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH0sXG5cbiAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZSgpO1xuICB9LFxuXG4gIGdldENvdW50OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTaXplKCk7XG4gIH0sXG5cbiAgaXNWYWxpZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuZ2V0KCdxJyk7XG4gICAgcmV0dXJuICEhKHN0cnx8JycpO1xuICB9LFxuXG4gIGlzTG9ja2VkOiBmdW5jdGlvbigpIHt9LFxuXG4gIHJlc2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXREYXRhKFtdKTtcbiAgICB0aGlzLnNldCgncScsICcnKTtcbiAgfSxcblxuICBnZXRTZWFyY2hRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdxJyk7XG4gIH0sXG5cbiAgaXNTZWFyY2hBcHBsaWVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgJiYgdGhpcy5nZXRTaXplKCkgPiAwO1xuICB9LFxuXG4gIF9vbkNoYW5nZVNlbGVjdGVkOiBmdW5jdGlvbihtZGwsIGlzU2VsZWN0ZWQpIHtcbiAgICB0aGlzLmxvY2tlZFsgaXNTZWxlY3RlZCA/ICdhZGRJdGVtJyA6ICdyZW1vdmVJdGVtJyBdKG1kbCk7XG4gIH0sXG5cbiAgX3BhcnNlRGF0YTogZnVuY3Rpb24oY2F0ZWdvcmllcykge1xuICAgIHZhciBuZXdEYXRhID0gW107XG4gICAgXy5lYWNoKGNhdGVnb3JpZXMsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmICghZC5hZ2cpIHtcbiAgICAgICAgdmFyIGNhdGVnb3J5ID0gKGQuY2F0ZWdvcnkgfHwgZC5uYW1lKS50b1N0cmluZygpO1xuICAgICAgICB2YXIgaXNMb2NrZWQgPSB0aGlzLmxvY2tlZC5pc0l0ZW1Mb2NrZWQoY2F0ZWdvcnkpO1xuICAgICAgICBuZXdEYXRhLnB1c2goe1xuICAgICAgICAgIHNlbGVjdGVkOiBpc0xvY2tlZCxcbiAgICAgICAgICBuYW1lOiBjYXRlZ29yeSxcbiAgICAgICAgICBhZ2c6IGQuYWdnLFxuICAgICAgICAgIHZhbHVlOiBkLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgY2F0ZWdvcmllcyA9IHRoaXMuX3BhcnNlRGF0YShyLmNhdGVnb3JpZXMpO1xuICAgIHRoaXMuX2RhdGEucmVzZXQoY2F0ZWdvcmllcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGNhdGVnb3JpZXNcbiAgICB9O1xuICB9LFxuXG4gIGZldGNoOiBmdW5jdGlvbihvcHRzKSB7XG4gICAgdGhpcy50cmlnZ2VyKFwibG9hZGluZ1wiLCB0aGlzKTtcbiAgICByZXR1cm4gTW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0cyk7XG4gIH0sXG5cbiAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuX3hocikge1xuICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMuX3hociA9IE1vZGVsLnByb3RvdHlwZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5feGhyLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX3hociA9IG51bGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nJztcbiBpZiAoaXNTZWFyY2hFbmFibGVkKSB7IFxuX19wKz0nIDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1ib2xkIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWRhcmsgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXJcIj4nK1xuKChfX3Q9KCB0b3RhbExvY2tlZCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgc2VsZWN0ZWQ8L3A+ICc7XG4gfSBlbHNlIHsgXG5fX3ArPScgPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tZGFyayBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPiAnO1xuIGlmIChpc0xvY2tlZCkgeyBcbl9fcCs9JyAnK1xuKChfX3Q9KCB0b3RhbENhdHMgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIGJsb2NrZWQgPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtbGluayB1LWxTcGFjZSBqcy11bmxvY2tcIj51bmxvY2s8L2J1dHRvbj4gJztcbiB9IGVsc2UgeyBcbl9fcCs9JyAnK1xuKChfX3Q9KCByZWplY3RlZENhdHMgPT09IDAgJiYgYWNjZXB0ZWRDYXRzID09PSAwIHx8IGFjY2VwdGVkQ2F0cyA+PSB0b3RhbENhdHMgPyBcIkFsbCBzZWxlY3RlZFwiIDogYWNjZXB0ZWRDYXRzICsgXCIgc2VsZWN0ZWRcIiApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgJztcbiBpZiAoY2FuQmVMb2NrZWQpIHsgXG5fX3ArPScgPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtbGluayB1LWxTcGFjZSBqcy1sb2NrXCI+bG9jazwvYnV0dG9uPiAnO1xuIH1cbl9fcCs9JyAnO1xuIH1cbl9fcCs9JyA8L3A+ICc7XG4gaWYgKCFpc0xvY2tlZCkgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1maWx0ZXJCdXR0b25zXCI+ICc7XG4gaWYgKHJlamVjdGVkQ2F0cyA+IDAgfHzCoGFjY2VwdGVkQ2F0cyA+IDAgfHzCoGlzQWxsUmVqZWN0ZWQpIHsgXG5fX3ArPScgPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtbGluayBDREItV2lkZ2V0LWZpbHRlckJ1dHRvbiBqcy1hbGxcIj5hbGw8L2J1dHRvbj4gJztcbiB9IFxuX19wKz0nICc7XG4gaWYgKHRvdGFsQ2F0cyA+IHJlamVjdGVkQ2F0cyAmJiAhaXNBbGxSZWplY3RlZCkgeyBcbl9fcCs9JyA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1saW5rIENEQi1XaWRnZXQtZmlsdGVyQnV0dG9uIGpzLW5vbmVcIj5ub25lPC9idXR0b24+ICc7XG4gfSBcbl9fcCs9JyA8L2Rpdj4gJztcbiB9IFxuX19wKz0nICc7XG4gfSBcbl9fcCs9Jyc7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL29wdGlvbnNfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgZmlsdGVyIHZpZXdcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtZmlsdGVyIENEQi1XaWRnZXQtY29udGVudFNwYWNlZCBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQtLXNpZGVNYXJnaW5zJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLWFsbCc6ICdfb25TZWxlY3RBbGwnLFxuICAgICdjbGljayAuanMtbm9uZSc6ICdfb25VbnNlbGVjdEFsbCcsXG4gICAgJ2NsaWNrIC5qcy1sb2NrJzogJ19sb2NrQ2F0ZWdvcmllcycsXG4gICAgJ2NsaWNrIC5qcy11bmxvY2snOiAnX3VubG9ja0NhdGVnb3JpZXMnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLm9wdGlvbnMuZGF0YU1vZGVsO1xuICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5vcHRpb25zLnZpZXdNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbENhdHMgPSB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCkuc2l6ZSgpO1xuICAgIHZhciByZWplY3RlZENhdHMgPSB0aGlzLmRhdGFNb2RlbC5nZXRSZWplY3RlZENvdW50KCk7XG4gICAgdmFyIGFjY2VwdGVkQ2F0cyA9IHRoaXMuZGF0YU1vZGVsLmdldEFjY2VwdGVkQ291bnQoKTtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIGlzTG9ja2VkOiB0aGlzLmRhdGFNb2RlbC5pc0xvY2tlZCgpLFxuICAgICAgICBjYW5CZUxvY2tlZDogdGhpcy5kYXRhTW9kZWwuY2FuQmVMb2NrZWQoKSxcbiAgICAgICAgdG90YWxMb2NrZWQ6IHRoaXMuZGF0YU1vZGVsLmdldExvY2tlZFNpemUoKSxcbiAgICAgICAgaXNTZWFyY2hFbmFibGVkOiB0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSxcbiAgICAgICAgaXNTZWFyY2hBcHBsaWVkOiB0aGlzLmRhdGFNb2RlbC5pc1NlYXJjaEFwcGxpZWQoKSxcbiAgICAgICAgaXNBbGxSZWplY3RlZDogdGhpcy5kYXRhTW9kZWwuaXNBbGxGaWx0ZXJzUmVqZWN0ZWQoKSxcbiAgICAgICAgdG90YWxDYXRzOiB0b3RhbENhdHMsXG4gICAgICAgIHJlamVjdGVkQ2F0czogcmVqZWN0ZWRDYXRzLFxuICAgICAgICBhY2NlcHRlZENhdHM6IGFjY2VwdGVkQ2F0c1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhIGNoYW5nZTpmaWx0ZXIgY2hhbmdlOmxvY2tlZCBjaGFuZ2U6bG9ja0NvbGxlY3Rpb24nLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgdGhpcy52aWV3TW9kZWwuYmluZCgnY2hhbmdlOnNlYXJjaCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuZGF0YU1vZGVsKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMudmlld01vZGVsKTtcbiAgfSxcblxuICBfbG9ja0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmxvY2tDYXRlZ29yaWVzKCk7XG4gIH0sXG5cbiAgX3VubG9ja0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLnVubG9ja0NhdGVnb3JpZXMoKTtcbiAgfSxcblxuICBfb25VbnNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwucmVqZWN0QWxsKCk7XG4gIH0sXG5cbiAgX29uU2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5hY2NlcHRBbGwoKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudEZsZXhcIj4gPGJ1dHRvbiBjbGFzcz1cInUtclNwYWNlLS1tIENEQi1XaWRnZXQtYnV0dG9uSWNvbiBDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLXVwcGVyIGpzLXNlYXJjaFRvZ2dsZVwiPiA8aSBjbGFzcz1cIkNEQi1JY29uIENEQi1JY29uLS1jZW50ZXIgQ0RCLUljb24tbGVucyB1LXJTcGFjZVwiPjwvaT4gPHNwYW4gY2xhc3M9XCJ1LWlCbG9ja1wiPiBzZWFyY2ggPC9zcGFuPiA8L2J1dHRvbj4gPC9kaXY+ICc7XG4gaWYgKHNob3dQYWdpbmF0b3IpIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbmF2RG90cyBqcy1kb3RzXCI+ICc7XG4gZm9yICh2YXIgaSA9IDAsIGwgPSBwYWdlczsgaSA8IGw7IGkrKykgeyBcbl9fcCs9JzxidXR0b24gY2xhc3M9XCJDREItU2hhcGUtZG90IENEQi1XaWRnZXQtZG90LS1uYXZpZ2F0aW9uIGpzLXBhZ2UgJztcbiBpZiAoY3VycmVudFBhZ2UgPT09IGkpIHsgXG5fX3ArPSdpcy1zZWxlY3RlZCc7XG4gfSBcbl9fcCs9J1wiIGRhdGEtcGFnZT1cIicrXG4oKF9fdD0oIGkgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9idXR0b24+JztcbiB9IFxuX19wKz0nIDwvZGl2PiAnO1xuIH0gXG5fX3ArPScnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIGRlZmF1bHRUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vcGFnaW5hdG9yX3RlbXBsYXRlLnRwbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBvcHRpb25zOiB7XG4gICAgaXRlbXNQZXJQYWdlOiA2LFxuICAgIHRlbXBsYXRlOiBkZWZhdWx0VGVtcGxhdGUsXG4gICAgcGFnaW5hdG9yOiBmYWxzZVxuICB9LFxuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbmF2IENEQi1XaWRnZXQtY29udGVudFNwYWNlZCcsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1zZWFyY2hUb2dnbGUnOiAnX29uU2VhcmNoQ2xpY2tlZCcsXG4gICAgJ2NsaWNrIC5qcy1wYWdlJzogJ19vbkRvdENsaWNrJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMub3B0aW9ucy52aWV3TW9kZWw7XG4gICAgdGhpcy5fJHRhcmdldCA9IHRoaXMub3B0aW9ucy4kdGFyZ2V0O1xuICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe1xuICAgICAgcGFnZTogMFxuICAgIH0pO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICB2YXIgcGFnZXMgPSBNYXRoLmNlaWwodGhpcy5kYXRhTW9kZWwuZ2V0U2l6ZSgpIC8gdGhpcy5vcHRpb25zLml0ZW1zUGVyUGFnZSk7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlO1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHNob3dQYWdpbmF0b3I6IHRoaXMub3B0aW9ucy5wYWdpbmF0b3IsXG4gICAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLm1vZGVsLmdldCgncGFnZScpLFxuICAgICAgICBwYWdlczogcGFnZXNcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLl9zY3JvbGxUb1BhZ2UoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgICQod2luZG93KS5iaW5kKCdyZXNpemUuJyArIHRoaXMuY2lkLCBfLmJpbmQodGhpcy5fc2Nyb2xsVG9QYWdlLCB0aGlzKSk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6cGFnZScsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6ZGF0YSBjaGFuZ2U6c2VhcmNoRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2V0UGFnZSgpO1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoJywgdGhpcy50b2dnbGUsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5kYXRhTW9kZWwpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy52aWV3TW9kZWwpO1xuICB9LFxuXG4gIC8vIElmIGN1cnJlbnQgcGFnZSBkb2Vzbid0IGV4aXN0IGR1ZSB0byBhIGRhdGEgY2hhbmdlLCB3ZSBzaG91bGQgcmVzZXQgaXRcbiAgX3NldFBhZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3VudCA9IHRoaXMuZGF0YU1vZGVsLmdldFNpemUoKTtcbiAgICB2YXIgcGFnZXMgPSBNYXRoLmNlaWwoY291bnQgLyB0aGlzLl9JVEVNU19QRVJfUEFHRSk7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdwYWdlJykgPiAocGFnZXMgLSAxKSkge1xuICAgICAgdGhpcy5tb2RlbC5zZXQoeyBwYWdlOiAwIH0sIHsgc2lsZW50IDp0cnVlIH0pO1xuICAgIH1cbiAgfSxcblxuICBfb25TZWFyY2hDbGlja2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5zZXR1cFNlYXJjaCgpO1xuICAgIHRoaXMudmlld01vZGVsLnRvZ2dsZVNlYXJjaCgpO1xuICB9LFxuXG4gIF9zY3JvbGxUb1BhZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYWdlID0gdGhpcy5tb2RlbC5nZXQoJ3BhZ2UnKTtcbiAgICB2YXIgcGFnZVdpZHRoID0gdGhpcy5fJHRhcmdldC5maW5kKCcuQ0RCLVdpZGdldC1saXN0R3JvdXA6ZXEoMCknKS5vdXRlcldpZHRoKCk7XG4gICAgdGhpcy5fJHRhcmdldC5jc3MoJ21hcmdpbi1sZWZ0JywgLSAocGFnZSAqIHBhZ2VXaWR0aCkpO1xuICB9LFxuXG4gIF9vbkRvdENsaWNrOiBmdW5jdGlvbihldikge1xuICAgIHZhciBwYWdlID0gJChldi50YXJnZXQpLmRhdGEoJ3BhZ2UnKTtcbiAgICB0aGlzLm1vZGVsLnNldCgncGFnZScsIHBhZ2UpO1xuICB9LFxuXG4gIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sgdGhpcy52aWV3TW9kZWwuaXNTZWFyY2hFbmFibGVkKCkgPyAnaGlkZScgOiAnc2hvdycgXSgpO1xuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmFkZENsYXNzKCdpcy1oaWRkZW4nKTtcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnaXMtaGlkZGVuJyk7XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICQod2luZG93KS51bmJpbmQoJ3Jlc2l6ZS4nICsgdGhpcy5jaWQpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnRGbGV4XCI+IDxidXR0b24gY2xhc3M9XCJ1LXJTcGFjZS0tbSBDREItV2lkZ2V0LWxpbmsganMtc2VhcmNoVG9nZ2xlXCI+Y2FuY2VsPC9idXR0b24+IDwvZGl2PiAnO1xuIGlmIChzaG93UGFnaW5hdG9yKSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LW5hdkRvdHMganMtZG90c1wiPiAnO1xuIGZvciAodmFyIGkgPSAwLCBsID0gcGFnZXM7IGkgPCBsOyBpKyspIHsgXG5fX3ArPSc8YnV0dG9uIGNsYXNzPVwiQ0RCLVNoYXBlLWRvdCBDREItV2lkZ2V0LWRvdC0tbmF2aWdhdGlvbiBqcy1wYWdlICc7XG4gaWYgKGN1cnJlbnRQYWdlID09PSBpKSB7IFxuX19wKz0naXMtc2VsZWN0ZWQnO1xuIH0gXG5fX3ArPSdcIiBkYXRhLXBhZ2U9XCInK1xuKChfX3Q9KCBpICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPjwvYnV0dG9uPic7XG4gfSBcbl9fcCs9JyA8L2Rpdj4gJztcbiB9IFxuX19wKz0nJztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBQYWdpbmF0b3JWaWV3ID0gcmVxdWlyZSgnLi9wYWdpbmF0b3JfdmlldycpO1xudmFyIHNlYXJjaFRlbXBsYXRlID0gcmVxdWlyZSgnLi9zZWFyY2hfcGFnaW5hdG9yX3RlbXBsYXRlLnRwbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2luYXRvclZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LW5hdiBpcy1oaWRkZW4gQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkJyxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgdmFyIHBhZ2VzID0gTWF0aC5jZWlsKHRoaXMuZGF0YU1vZGVsLmdldFNlYXJjaENvdW50KCkgLyB0aGlzLm9wdGlvbnMuaXRlbXNQZXJQYWdlKTtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgc2VhcmNoVGVtcGxhdGUoe1xuICAgICAgICBzaG93UGFnaW5hdG9yOiB0cnVlLFxuICAgICAgICBjdXJyZW50UGFnZTogdGhpcy5tb2RlbC5nZXQoJ3BhZ2UnKSxcbiAgICAgICAgcGFnZXM6IHBhZ2VzXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5fc2Nyb2xsVG9QYWdlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfc2V0UGFnZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoQ291bnQoKTtcbiAgICB2YXIgcGFnZXMgPSBNYXRoLmNlaWwoY291bnQgLyB0aGlzLl9JVEVNU19QRVJfUEFHRSk7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdwYWdlJykgPiAocGFnZXMgLSAxKSkge1xuICAgICAgdGhpcy5tb2RlbC5zZXQoeyBwYWdlOiAwIH0sIHsgc2lsZW50IDp0cnVlIH0pO1xuICAgIH1cbiAgfSxcblxuICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbICF0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSA/ICdoaWRlJyA6ICdzaG93JyBdKCk7XG4gIH0sXG5cbiAgX29uU2VhcmNoQ2xpY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuY2xlYW5TZWFyY2goKTtcbiAgICB0aGlzLnZpZXdNb2RlbC50b2dnbGVTZWFyY2goKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPScnO1xuIGlmIChpc1NlYXJjaEVuYWJsZWQpIHsgXG5fX3ArPScgPGR0IGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvSXRlbVwiPiAnO1xuIGlmIChpc1NlYXJjaEFwcGxpZWQpIHsgXG5fX3ArPScgJytcbigoX190PSggcmVzdWx0c0NvdW50ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyBmb3VuZCAnO1xuIH0gZWxzZSB7IFxuX19wKz0nICZuYnNwOyAnO1xuIH0gXG5fX3ArPScgPC9kdD4gJztcbiB9IGVsc2UgeyBcbl9fcCs9JyA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtXCI+JytcbigoX190PSggbnVsbHNQZXIgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJSBudWxsIHJvd3M8L2R0PiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtXCI+PHNwYW4gY2xhc3M9XCJqcy1jYXRzXCI+JytcbigoX190PSggY2F0c1BlciApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3NwYW4+JSBpbiAnK1xuKChfX3Q9KCB0b3RhbENhdHMgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIGNhdGVnb3InK1xuKChfX3Q9KCB0b3RhbENhdHMgIT09IDEgPyAnaWVzJyA6ICd5JyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2R0PiAnO1xuIH0gXG5fX3ArPScnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBkMyA9IGNkYi5kMztcbnZhciBmb3JtYXR0ZXIgPSBjZGIuY29yZS5mb3JtYXQ7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3N0YXRzX3RlbXBsYXRlLnRwbCcpO1xudmFyIGFuaW1hdGlvblRlbXBsYXRlID0gcmVxdWlyZSgnLi9jYXRzX3RlbXBsYXRlLnRwbCcpO1xudmFyIEFuaW1hdGVWYWx1ZXMgPSByZXF1aXJlKCcuLi8uLi9hbmltYXRlX3ZhbHVlcycpO1xuXG4vKipcbiAqIENhdGVnb3J5IHN0YXRzIGluZm8gdmlld1xuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWluZm8gQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlcicsXG4gIHRhZ05hbWU6ICdkbCcsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm9wdGlvbnMudmlld01vZGVsO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIGlzU2VhcmNoRW5hYmxlZDogdGhpcy52aWV3TW9kZWwuaXNTZWFyY2hFbmFibGVkKCksXG4gICAgICAgIGlzU2VhcmNoQXBwbGllZDogdGhpcy5kYXRhTW9kZWwuaXNTZWFyY2hBcHBsaWVkKCksXG4gICAgICAgIHJlc3VsdHNDb3VudDogdGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoQ291bnQoKSxcbiAgICAgICAgdG90YWxDYXRzOiB0aGlzLl9nZXRDYXRlZ29yaWVzU2l6ZSgpLFxuICAgICAgICBudWxsc1BlcjogdGhpcy5fZ2V0TnVsbFBlcmNlbnRhZ2UoKSxcbiAgICAgICAgY2F0c1BlcjogdGhpcy5fZ2V0Q3VycmVudENhdGVnb3JpZXNQZXJjZW50YWdlKClcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRlVmFsdWVzKHtcbiAgICAgIGVsOiB0aGlzLiRlbFxuICAgIH0pO1xuXG4gICAgYW5pbWF0b3IuYW5pbWF0ZUZyb21WYWx1ZXModGhpcy5fZ2V0UHJldmlvdXNDYXRlZ29yaWVzUGVyY2VudGFnZSgpLCB0aGlzLl9nZXRDdXJyZW50Q2F0ZWdvcmllc1BlcmNlbnRhZ2UoKSwgJy5qcy1jYXRzJyxcbiAgICAgIGFuaW1hdGlvblRlbXBsYXRlLCB7IGRlZmF1bHRWYWx1ZTogJy0nLCBhbmltYXRpb25TcGVlZDogNzAwLCBmb3JtYXR0ZXI6IGZvcm1hdHRlci5mb3JtYXRWYWx1ZSB9XG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhIGNoYW5nZTpsb2NrZWQgY2hhbmdlOnNlYXJjaCBjaGFuZ2U6dG90YWxDb3VudCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5kYXRhTW9kZWwpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy52aWV3TW9kZWwpO1xuICB9LFxuXG4gIF9nZXROdWxsUGVyY2VudGFnZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG51bGxzID0gdGhpcy5kYXRhTW9kZWwuZ2V0KCdudWxscycpO1xuICAgIHZhciB0b3RhbCA9IHRoaXMuZGF0YU1vZGVsLmdldCgndG90YWxDb3VudCcpIHx8IDA7XG4gICAgcmV0dXJuICFudWxscyA/IDAgOiAoKG51bGxzL3RvdGFsKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgfSxcblxuICBfZ2V0UHJldmlvdXNDYXRlZ29yaWVzUGVyY2VudGFnZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5kYXRhTW9kZWwucHJldmlvdXMoJ3RvdGFsQ291bnQnKSB8fCAwO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTW9kZWwuZ2V0UHJldmlvdXNEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhdGVnb3JpZXNQZXJjZW50YWdlKGRhdGEsIHRvdGFsKTtcbiAgfSxcblxuICBfZ2V0Q3VycmVudENhdGVnb3JpZXNQZXJjZW50YWdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG90YWwgPSB0aGlzLmRhdGFNb2RlbC5nZXQoJ3RvdGFsQ291bnQnKSB8fCAwO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTW9kZWwuZ2V0RGF0YSgpLnRvSlNPTigpO1xuICAgIHJldHVybiB0aGlzLl9nZXRDYXRlZ29yaWVzUGVyY2VudGFnZShkYXRhLCB0b3RhbCk7XG4gIH0sXG5cbiAgX2dldENhdGVnb3JpZXNQZXJjZW50YWdlOiBmdW5jdGlvbihkYXRhLCB0b3RhbCkge1xuICAgIGlmICghdG90YWwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VG90YWwgPSBkYXRhLnJlZHVjZShmdW5jdGlvbihtZW1vLCBtZGwpIHtcbiAgICAgIHJldHVybiAhbWRsLmFnZyA/ICggbWVtbyArIHBhcnNlRmxvYXQobWRsLnZhbHVlKSkgOiBtZW1vO1xuICAgIH0sIDApO1xuXG4gICAgaWYgKCFjdXJyZW50VG90YWwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiAoKGN1cnJlbnRUb3RhbCAvIHRvdGFsKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgfSxcblxuICBfZ2V0Q2F0ZWdvcmllc1NpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnBsdWNrKFxuICAgICAgdGhpcy5kYXRhTW9kZWwuZ2V0RGF0YSgpLnJlamVjdChmdW5jdGlvbihtZGwpIHtcbiAgICAgICAgcmV0dXJuIG1kbC5nZXQoJ2FnZycpO1xuICAgICAgfSksICduYW1lJykubGVuZ3RoO1xuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nJztcbiBpZiAoaXNTZWFyY2hFbmFibGVkKSB7IFxuX19wKz0nIDxmb3JtIGNsYXNzPVwiQ0RCLVdpZGdldC1zZWFyY2gganMtZm9ybVwiPiA8aSBjbGFzcz1cIkNEQi1JY29uIENEQi1JY29uLWxlbnMgQ0RCLVdpZGdldC1zZWFyY2hMZW5zXCI+PC9pPiA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dElucHV0IENEQi1XaWRnZXQtc2VhcmNoVGV4dElucHV0IGpzLXRleHRJbnB1dFwiIHZhbHVlPVwiJytcbigoX190PSggcSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaCBieSAnK1xuKChfX3Q9KCBjb2x1bW5OYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiAnO1xuIGlmIChjYW5TaG93QXBwbHkpIHsgXG5fX3ArPScgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJDREItV2lkZ2V0LWxpbmsgQ0RCLVdpZGdldC1zZWFyY2hBcHBseSBqcy1hcHBseUxvY2tlZFwiPmFwcGx5PC9idXR0b24+ICc7XG4gfSBcbl9fcCs9JyA8L2Zvcm0+ICc7XG4gfSBlbHNlIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGl0bGUgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxoMyBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZ1wiIHRpdGxlPVwiJytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMz4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtb3B0aW9ucyBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtYnV0dG9uSWNvbiBDREItV2lkZ2V0LWJ1dHRvbkljb24tLWNpcmNsZSBqcy1jb2xvcnMgJytcbigoX190PSggaXNDb2xvckFwcGxpZWQgPyAnaXMtc2VsZWN0ZWQnIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nICcrXG4oKF9fdD0oIGlzQ29sb3JBcHBsaWVkID8gJ2pzLWNhbmNlbENvbG9ycycgOiAnanMtYXBwbHlDb2xvcnMnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiIGRhdGEtdG9vbHRpcD1cIlxcbiAgICAgICAgICAnK1xuKChfX3Q9KCBpc0NvbG9yQXBwbGllZCA/ICdSZW1vdmUgY29sb3JzJyA6ICdBcHBseSBjb2xvcnMnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1xcbiAgICAgICAgXCI+IDxpIGNsYXNzPVwiQ0RCLUljb24gQ0RCLUljb24tc3lyaW5nZSBDREItSWNvbi0tdG9wXCI+PC9pPiA8L2J1dHRvbj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1TaGFwZS10aHJlZVBvaW50cyBqcy1jb2xsYXBzZVwiIGRhdGEtdG9vbHRpcD1cIicrXG4oKF9fdD0oIGlzQ29sbGFwc2VkID8gJ1Nob3cnIDogJ0hpZGUnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiA8c3BhbiBjbGFzcz1cIkNEQi1TaGFwZS10aHJlZVBvaW50c0l0ZW1cIj48L3NwYW4+IDwvYnV0dG9uPiA8L2Rpdj4gPC9kaXY+ICc7XG4gfSBcbl9fcCs9Jyc7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgJCA9IGNkYi4kO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIFRvb2x0aXBWaWV3ID0gcmVxdWlyZSgnLi4vLi4vd2lkZ2V0LXRvb2x0aXAtdmlldycpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9zZWFyY2hfdGl0bGVfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogIFNob3cgY2F0ZWdvcnkgdGl0bGUgb3Igc2VhcmNoIGFueSBjYXRlZ29yeVxuICogICsgYW5vdGhlciBvcHRpb25zIGZvciB0aGlzIHdpZGdldCwgYXMgaW4sXG4gKiAgY29sb3JpemUgY2F0ZWdvcmllcywgbG9jayBkZWZpbmVkIGNhdGVnb3JpZXMuLi5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2tleXVwIC5qcy10ZXh0SW5wdXQnOiAnX29uS2V5dXBJbnB1dCcsXG4gICAgJ3N1Ym1pdCAuanMtZm9ybSc6ICdfb25TdWJtaXRGb3JtJyxcbiAgICAnY2xpY2sgLmpzLWFwcGx5TG9ja2VkJzogJ19hcHBseUxvY2tlZCcsXG4gICAgJ2NsaWNrIC5qcy1hcHBseUNvbG9ycyc6ICdfYXBwbHlDb2xvcnMnLFxuICAgICdjbGljayAuanMtY2FuY2VsQ29sb3JzJzogJ19jYW5jZWxDb2xvcnMnLFxuICAgICdjbGljayAuanMtY29sbGFwc2UnOiAnX3RvZ2dsZUNvbGxhcHNlJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5vcHRpb25zLnZpZXdNb2RlbDtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICBpc0NvbGxhcHNlZDogdGhpcy5kYXRhTW9kZWwuaXNDb2xsYXBzZWQoKSxcbiAgICAgICAgaXNDb2xvckFwcGxpZWQ6IHRoaXMuZGF0YU1vZGVsLmlzQ29sb3JBcHBsaWVkKCksXG4gICAgICAgIHRpdGxlOiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIGNvbHVtbk5hbWU6IHRoaXMuZGF0YU1vZGVsLmdldCgnY29sdW1uJyksXG4gICAgICAgIHE6IHRoaXMuZGF0YU1vZGVsLmdldFNlYXJjaFF1ZXJ5KCksXG4gICAgICAgIGlzTG9ja2VkOiB0aGlzLmRhdGFNb2RlbC5pc0xvY2tlZCgpLFxuICAgICAgICBjYW5CZUxvY2tlZDogdGhpcy5kYXRhTW9kZWwuY2FuQmVMb2NrZWQoKSxcbiAgICAgICAgaXNTZWFyY2hFbmFibGVkOiB0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSxcbiAgICAgICAgY2FuU2hvd0FwcGx5OiB0aGlzLmRhdGFNb2RlbC5jYW5BcHBseUxvY2tlZCgpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5faW5pdFZpZXdzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwuYmluZCgnY2hhbmdlOnNlYXJjaCcsIHRoaXMuX29uU2VhcmNoVG9nZ2xlZCwgdGhpcyk7XG4gICAgdGhpcy5kYXRhTW9kZWwuYmluZCgnY2hhbmdlOmZpbHRlciBjaGFuZ2U6bG9ja0NvbGxlY3Rpb24gY2hhbmdlOmNhdGVnb3J5Q29sb3JzIGNoYW5nZTpjb2xsYXBzZWQnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLmRhdGFNb2RlbCk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLnZpZXdNb2RlbCk7XG4gIH0sXG5cbiAgX2luaXRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbGxhcHNlVG9vbHRpcCA9IG5ldyBUb29sdGlwVmlldyh7XG4gICAgICB0YXJnZXQ6IHRoaXMuJCgnLmpzLWNvbGxhcHNlJylcbiAgICB9KTtcbiAgICAkKCdib2R5JykuYXBwZW5kKGNvbGxhcHNlVG9vbHRpcC5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KGNvbGxhcHNlVG9vbHRpcCk7XG5cbiAgICB2YXIgY29sb3JzVG9vbHRpcCA9IG5ldyBUb29sdGlwVmlldyh7XG4gICAgICB0YXJnZXQ6IHRoaXMuJCgnLmpzLWNvbG9ycycpXG4gICAgfSk7XG4gICAgJCgnYm9keScpLmFwcGVuZChjb2xvcnNUb29sdGlwLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoY29sb3JzVG9vbHRpcCk7XG4gIH0sXG5cbiAgX29uU2VhcmNoVG9nZ2xlZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlzU2VhcmNoRW5hYmxlZCA9IHRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpO1xuICAgIHRoaXNbaXNTZWFyY2hFbmFibGVkID8gJ19iaW5kRVNDJyA6ICdfdW5iaW5kRVNDJ10oKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIGlmIChpc1NlYXJjaEVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2ZvY3VzT25JbnB1dCgpO1xuICAgIH1cbiAgfSxcblxuICBfb25TdWJtaXRGb3JtOiBmdW5jdGlvbihldikge1xuICAgIGlmIChldikge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgdmFyIHEgPSB0aGlzLiQoJy5qcy10ZXh0SW5wdXQnKS52YWwoKTtcbiAgICBpZiAodGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoUXVlcnkoKSAhPT0gcSkge1xuICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0U2VhcmNoUXVlcnkocSk7XG4gICAgICBpZiAodGhpcy5kYXRhTW9kZWwuaXNTZWFyY2hWYWxpZCgpKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmFwcGx5U2VhcmNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9mb2N1c09uSW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi4kKCcuanMtdGV4dElucHV0JykuZm9jdXMoKTtcbiAgICB9LCAwKTtcbiAgfSxcblxuICBfb25LZXl1cElucHV0OiBfLmRlYm91bmNlKFxuICAgIGZ1bmN0aW9uKGV2KSB7XG4gICAgICB2YXIgcSA9IHRoaXMuJCgnLmpzLXRleHRJbnB1dCcpLnZhbCgpO1xuICAgICAgaWYgKGV2LmtleUNvZGUgIT09IDEzICYmIGV2LmtleUNvZGUgIT09IDI3ICYmIHEgIT09IFwiXCIpIHtcbiAgICAgICAgdGhpcy5fb25TdWJtaXRGb3JtKCk7XG4gICAgICB9XG4gICAgfSwgMjUwXG4gICksXG5cbiAgX2JpbmRFU0M6IGZ1bmN0aW9uKCkge1xuICAgICQoZG9jdW1lbnQpLmJpbmQoXCJrZXl1cC5cIiArIHRoaXMuY2lkLCBfLmJpbmQodGhpcy5fb25LZXlVcCwgdGhpcykpO1xuICB9LFxuXG4gIF91bmJpbmRFU0M6IGZ1bmN0aW9uKCkge1xuICAgICQoZG9jdW1lbnQpLnVuYmluZChcImtleXVwLlwiICsgdGhpcy5jaWQpO1xuICB9LFxuXG4gIF9vbktleVVwOiBmdW5jdGlvbihldikge1xuICAgIGlmIChldi5rZXlDb2RlID09PSAyNykge1xuICAgICAgdGhpcy5fY2FuY2VsU2VhcmNoKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIF9hcHBseUxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwudG9nZ2xlU2VhcmNoKCk7XG4gICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlMb2NrZWQoKTtcbiAgfSxcblxuICBfYXBwbHlDb2xvcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmFwcGx5Q2F0ZWdvcnlDb2xvcnMoKTtcbiAgfSxcblxuICBfY2FuY2VsQ29sb3JzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5jYW5jZWxDYXRlZ29yeUNvbG9ycygpO1xuICB9LFxuXG4gIF9jYW5jZWxTZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmNsZWFuU2VhcmNoKCk7XG4gICAgdGhpcy52aWV3TW9kZWwuZGlzYWJsZVNlYXJjaCgpO1xuICB9LFxuXG4gIF90b2dnbGVDb2xsYXBzZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwudG9nZ2xlQ29sbGFwc2VkKCk7XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VuYmluZEVTQygpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JycrXG4oKF9fdD0oIHByZWZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCBzdWZmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBmb3JtYXR0ZXIgPSBjZGIuY29yZS5mb3JtYXQ7XG52YXIgZDMgPSBjZGIuZDM7XG52YXIgJCA9IGNkYi4kO1xudmFyIFdpZGdldENvbnRlbnQgPSByZXF1aXJlKCcuLi9zdGFuZGFyZC93aWRnZXRfY29udGVudF92aWV3Jyk7XG52YXIgV2lkZ2V0Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vd2lkZ2V0X2NvbnRlbnRfbW9kZWwnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUudHBsJyk7XG52YXIgVG9vbHRpcFZpZXcgPSByZXF1aXJlKCcuLi93aWRnZXQtdG9vbHRpcC12aWV3Jyk7XG52YXIgYW5pbWF0aW9uVGVtcGxhdGUgPSByZXF1aXJlKCcuL2FuaW1hdGlvbl90ZW1wbGF0ZS50cGwnKTtcbnZhciBBbmltYXRlVmFsdWVzID0gcmVxdWlyZSgnLi4vYW5pbWF0ZV92YWx1ZXMuanMnKTtcblxuLyoqXG4gKiBEZWZhdWx0IHdpZGdldCBjb250ZW50IHZpZXc6XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0Q29udGVudC5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtY29sbGFwc2UnOiAnX3RvZ2dsZUNvbGxhcHNlJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBXaWRnZXRWaWV3TW9kZWwoKTtcbiAgICBXaWRnZXRDb250ZW50LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFNb2RlbC5nZXQoJ2RhdGEnKTtcblxuICAgIHZhciBmb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGQzLmZvcm1hdCgnMCwwMDAnKTtcblxuICAgICAgaWYgKF8uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUudG9GaXhlZCgyKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgdmFyIG51bGxzID0gIV8uaXNVbmRlZmluZWQodGhpcy5kYXRhTW9kZWwuZ2V0KCdudWxscycpKSAmJiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyKHRoaXMuZGF0YU1vZGVsLmdldCgnbnVsbHMnKSkgfHzCoCctJztcbiAgICB2YXIgaXNDb2xsYXBzZWQgPSB0aGlzLmRhdGFNb2RlbC5pc0NvbGxhcHNlZCgpO1xuXG4gICAgdmFyIHByZWZpeCA9IHRoaXMuZGF0YU1vZGVsLmdldCgncHJlZml4Jyk7XG4gICAgdmFyIHN1ZmZpeCA9IHRoaXMuZGF0YU1vZGVsLmdldCgnc3VmZml4Jyk7XG5cbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICB0aXRsZTogdGhpcy5kYXRhTW9kZWwuZ2V0KCd0aXRsZScpLFxuICAgICAgICBvcGVyYXRpb246IHRoaXMuZGF0YU1vZGVsLmdldCgnb3BlcmF0aW9uJyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbnVsbHM6IG51bGxzLFxuICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgIGlzQ29sbGFwc2VkOiBpc0NvbGxhcHNlZFxuICAgICAgfSlcbiAgICApO1xuXG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdGVWYWx1ZXMoe1xuICAgICAgZWw6IHRoaXMuJGVsXG4gICAgfSk7XG5cbiAgICBhbmltYXRvci5hbmltYXRlVmFsdWUodGhpcy5kYXRhTW9kZWwsICdkYXRhJywgJy5qcy12YWx1ZScsIGFuaW1hdGlvblRlbXBsYXRlLCB7IGFuaW1hdGlvblNwZWVkOiA3MDAsIGZvcm1hdHRlcjogZm9ybWF0LCB0ZW1wbGF0ZURhdGE6IHsgcHJlZml4OiBwcmVmaXgsIHN1ZmZpeDogc3VmZml4IH19KTtcblxuICAgIHRoaXMuJGVsLnRvZ2dsZUNsYXNzKCdpcy1jb2xsYXBzZWQnLCAhIWlzQ29sbGFwc2VkKTtcblxuICAgIHRoaXMuX2luaXRWaWV3cygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuYmluZCgnY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICBXaWRnZXRDb250ZW50LnByb3RvdHlwZS5faW5pdEJpbmRzLmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgX2luaXRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvb2x0aXAgPSBuZXcgVG9vbHRpcFZpZXcoe1xuICAgICAgdGFyZ2V0OiB0aGlzLiQoJy5qcy1jb2xsYXBzZScpXG4gICAgfSk7XG4gICAgJCgnYm9keScpLmFwcGVuZCh0b29sdGlwLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcodG9vbHRpcCk7XG4gIH0sXG5cbiAgX3RvZ2dsZUNvbGxhcHNlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC50b2dnbGVDb2xsYXBzZWQoKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgV2lkZ2V0TW9kZWwgPSByZXF1aXJlKCcuLi93aWRnZXRfbW9kZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRNb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiBfLmV4dGVuZChcbiAgICB7fSxcbiAgICBXaWRnZXRNb2RlbC5wcm90b3R5cGUuZGVmYXVsdHMsXG4gICAge1xuICAgICAgZGF0YTogJycsXG4gICAgICBzdWZmaXg6ICcnLFxuICAgICAgcHJlZml4OiAnJ1xuICAgIH1cbiAgKSxcblxuICAvLyBUT0RPOiBUaGUgcmVzcG9uc2UgZm9ybWF0IGhhcyBwcm9iYWJseSBjaGFuZ2VkXG4gIHBhcnNlOiBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHIucmVzdWx0LFxuICAgICAgbnVsbHM6IHIubnVsbHNcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZvcm11bGFcIixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY29sdW1uOiB0aGlzLmdldCgnY29sdW1uJyksXG4gICAgICAgIG9wZXJhdGlvbjogdGhpcy5nZXQoJ29wZXJhdGlvbicpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtaGVhZGVyXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRpdGxlIENEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxoMyBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZ1wiPicrXG4oKF9fdD0oIHRpdGxlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvaDM+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRhZyBDREItV2lkZ2V0LXRhZy0tJytcbigoX190PSggb3BlcmF0aW9uICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiA8c3BhbiBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXJcIj4nK1xuKChfX3Q9KCBvcGVyYXRpb24gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9zcGFuPiA8L2Rpdj4gPC9kaXY+IDxidXR0b24gY2xhc3M9XCJDREItU2hhcGUtdGhyZWVQb2ludHMganMtY29sbGFwc2VcIiBkYXRhLXRvb2x0aXA9XCInK1xuKChfX3Q9KCBpc0NvbGxhcHNlZCA/ICdTaG93JyA6ICdIaWRlJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4gPHNwYW4gY2xhc3M9XCJDREItU2hhcGUtdGhyZWVQb2ludHNJdGVtXCI+PC9zcGFuPiA8L2J1dHRvbj4gPC9kaXY+IDxkbCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb1wiPiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXJcIj4nK1xuKChfX3Q9KCBudWxscyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgbnVsbCByb3dzPC9kdD4gPC9kbD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnRcIj4gJztcbiBpZiAodmFsdWUpIHsgXG5fX3ArPScgPGg0IGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnZ2VyIENEQi1XaWRnZXQtdGV4dEJpZ2dlci0tbWF4V2lkdGgganMtdmFsdWVcIiB0aXRsZT1cIicrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiAnK1xuKChfX3Q9KCBwcmVmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggc3VmZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyA8L2g0PiAnO1xuIH0gZWxzZSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtLS1mYWtlXCI+PC9kaXY+ICc7XG4gfSBcbl9fcCs9JyA8L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JycrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHN1ZmZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIF8gPSBjZGIuXztcbnZhciBkMyA9IGNkYi5kMztcbnZhciBmb3JtYXR0ZXIgPSBjZGIuY29yZS5mb3JtYXQ7XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICAgLy8gcmVuZGVyIHRoZSBjaGFydCBvbmNlIHRoZSB3aWR0aCBpcyBzZXQgYXMgZGVmYXVsdCwgcHJvdmlkZSBmYWxzZSB2YWx1ZSBmb3IgdGhpcyBwcm9wIHRvIGRpc2FibGUgdGhpcyBiZWhhdmlvclxuICAgICAvLyBlLmcuIGZvciBcIm1pbmlcIiBoaXN0b2dyYW0gYmVoYXZpb3JcbiAgICBzaG93T25XaWR0aENoYW5nZTogdHJ1ZSxcblxuICAgIGxhYmVsc01hcmdpbjogMTYsIC8vIHB4XG4gICAgaGFzQXhpc1RpcDogZmFsc2UsXG4gICAgbWluaW11bUJhckhlaWdodDogMixcbiAgICBhbmltYXRpb25TcGVlZDogNzUwLFxuICAgIGhhbmRsZVdpZHRoOiA2LFxuICAgIGhhbmRsZUhlaWdodDogMjMsXG4gICAgaGFuZGxlUmFkaXVzOiAzLFxuICAgIGRpdmlzaW9uV2lkdGg6IDgwLFxuICAgIGFuaW1hdGlvbkJhckRlbGF5OiBmdW5jdGlvbihkLCBpKSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqICgxMDAgKyAoaSAqIDEwKSk7XG4gICAgfSxcbiAgICB0cmFuc2l0aW9uVHlwZTogJ2VsYXN0aWMnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFfLmlzTnVtYmVyKHRoaXMub3B0aW9ucy5oZWlnaHQpKSB0aHJvdyBuZXcgRXJyb3IoJ2hlaWdodCBpcyByZXF1aXJlZCcpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe30sIHRoaXMuZGVmYXVsdHMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBfLmJpbmRBbGwodGhpcywgJ19zZWxlY3RCYXJzJywgJ19hZGp1c3RCcnVzaEhhbmRsZXMnLCAnX29uQnJ1c2hNb3ZlJywgJ19vbkJydXNoU3RhcnQnLCAnX29uTW91c2VNb3ZlJywgJ19vbk1vdXNlT3V0Jyk7XG5cbiAgICAvLyBVc2UgdGhpcyBzcGVjaWFsIHNldHVwIGZvciBlYWNoIHZpZXcgaW5zdGFuY2Ugb3QgaGF2ZSBpdHMgb3duIGRlYm91bmNlZCBsaXN0ZW5lclxuICAgIC8vIFRPRE8gaW4gdGhlb3J5IHRoZXJlJ3MgdGhlIHBvc3NpYmxpdHkgdGhhdCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIGJlZm9yZSB0aGUgdmlldyBpcyByZW5kZXJlZCBpbiB0aGUgRE9NLFxuICAgIC8vICB3aGljaCB3b3VsZCBsZWFkIHRvIHRoZSB2aWV3IG5vdCBiZWluZyB2aXNpYmxlIHVudGlsIGFuIGV4cGxpY2l0IHdpbmRvdyByZXNpemUuXG4gICAgLy8gIGEgd2FzQWRkZWRUb0RPTSBldmVudCB3b3VsZCd2ZSBiZWVuIG5pY2UgdG8gaGF2ZVxuICAgIHRoaXMuX29uV2luZG93UmVzaXplID0gXy5kZWJvdW5jZSh0aGlzLl9yZXNpemVUb1BhcmVudEVsZW1lbnQuYmluZCh0aGlzKSwgNTApO1xuICAgICQod2luZG93KS5iaW5kKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSk7XG5cbiAgICAvLyB1c2luZyB0YWdOYW1lOiAnc3ZnJyBkb2Vzbid0IHdvcmssXG4gICAgLy8gYW5kIHcvbyBjbGFzcz1cIlwiIGQzIHdvbid0IGluc3RhbnRpYXRlIHByb3Blcmx5XG4gICAgdGhpcy5zZXRFbGVtZW50KCQoJzxzdmcgY2xhc3M9XCJcIj48L3N2Zz4nKVswXSk7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGQzLnNlbGVjdCh0aGlzLmVsKVxuICAgIC5hdHRyKCd3aWR0aCcsIDApXG4gICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMub3B0aW9ucy5oZWlnaHQpO1xuXG4gICAgdGhpcy5jYW52YXNcbiAgICAuYXBwZW5kKCdnJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLVdpZGdldENhbnZhcycpO1xuXG4gICAgdGhpcy5fc2V0dXBNb2RlbCgpO1xuICAgIHRoaXMuX3NldHVwQmluZGluZ3MoKTtcbiAgICB0aGlzLl9zZXR1cERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLl9zZXR1cEQzQmluZGluZ3MoKTtcblxuICAgIHRoaXMuaGlkZSgpOyAvLyB3aWxsIGJlIHRvZ2dsZWQgb24gd2lkdGggY2hhbmdlXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZUNoYXJ0KCk7XG4gICAgdGhpcy5fZ2VuZXJhdGVDaGFydENvbnRlbnQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgJCh3aW5kb3cpLnVuYmluZCgncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgcmVwbGFjZURhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLm1vZGVsLnNldCh7IGRhdGE6IGRhdGEgfSk7XG4gIH0sXG5cbiAgdG9nZ2xlTGFiZWxzOiBmdW5jdGlvbihzaG93KSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ3Nob3dMYWJlbHMnLCBzaG93KTtcbiAgfSxcblxuICBjaGFydFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHRoaXMubW9kZWwuZ2V0KCdtYXJnaW4nKTtcblxuICAgIC8vIEdldCBtYXggYmVjYXVzZSB3aWR0aCBtaWdodCBiZSBuZWdhdGl2ZSBpbml0aWFsbHlcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5tb2RlbC5nZXQoJ3dpZHRoJykgLSBtLmxlZnQgLSBtLnJpZ2h0KTtcbiAgfSxcblxuICBjaGFydEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG0gPSB0aGlzLm1vZGVsLmdldCgnbWFyZ2luJyk7XG4gICAgdmFyIGxhYmVsc01hcmdpbiA9IHRoaXMubW9kZWwuZ2V0KCdzaG93TGFiZWxzJylcbiAgICAgID8gdGhpcy5kZWZhdWx0cy5sYWJlbHNNYXJnaW5cbiAgICAgIDogMDtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXQoJ2hlaWdodCcpIC0gbS50b3AgLSBtLmJvdHRvbSAtIGxhYmVsc01hcmdpbjtcbiAgfSxcblxuICBfcmVzaXplVG9QYXJlbnRFbGVtZW50OiBmdW5jdGlvbigpIHtcblxuICAgIGlmICh0aGlzLiRlbC5wYXJlbnQoKSkge1xuICAgICAgLy8gSGlkZSB0aGlzIHZpZXcgdGVtcG9yYXJpbHkgdG8gZ2V0IGFjdHVhbCBzaXplIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyXG4gICAgICB2YXIgd2FzSGlkZGVuID0gdGhpcy5pc0hpZGRlbigpO1xuXG4gICAgICB0aGlzLmhpZGUoKTtcblxuICAgICAgdmFyIHdpZHRoID0gdGhpcy4kZWwucGFyZW50KCkud2lkdGgoKSB8fCAwO1xuXG4gICAgICBpZiAod2FzSGlkZGVuKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW9kZWwuc2V0KCd3aWR0aCcsIHdpZHRoKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQ2hhbmdlTGVmdEF4aXNUaXA6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VwZGF0ZUF4aXNUaXAoJ2xlZnQnKTtcbiAgfSxcblxuICBfb25DaGFuZ2VSaWdodEF4aXNUaXA6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VwZGF0ZUF4aXNUaXAoJ3JpZ2h0Jyk7XG4gIH0sXG5cbiAgX3VwZGF0ZUF4aXNUaXA6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciB0ZXh0TGFiZWwgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwVGV4dC5DREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKTtcbiAgICB2YXIgYXhpc1RpcCAgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwLkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciByZWN0TGFiZWwgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwUmVjdC5DREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKTtcbiAgICB2YXIgaGFuZGxlICAgID0gdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtaGFuZGxlLkNEQi1DaGFydC1oYW5kbGUtJyArIGNsYXNzTmFtZSk7XG5cbiAgICB0ZXh0TGFiZWwuZGF0YShbdGhpcy5tb2RlbC5nZXQoY2xhc3NOYW1lICsgJ19heGlzX3RpcCcpXSkudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdE51bWJlcihkKTtcbiAgICB9KTtcblxuICAgIHZhciB3aWR0aCA9IHRleHRMYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIHJlY3RMYWJlbC5hdHRyKCd3aWR0aCcsIHdpZHRoICsgNCk7XG5cbiAgICB2YXIgcGFydHMgPSAvdHJhbnNsYXRlXFwoXFxzKihbXlxccywpXSspLCAoW15cXHMsKV0rKS8uZXhlYyhoYW5kbGUuYXR0cigndHJhbnNmb3JtJykpO1xuICAgIHZhciB4UG9zID0gK3BhcnRzWzFdICsgMztcblxuICAgIGlmICgoeFBvcyAtIHdpZHRoLzIpIDwgMCkge1xuICAgICAgYXhpc1RpcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDUyKScpO1xuICAgICAgdGV4dExhYmVsLmF0dHIoJ2R4JywgLXhQb3MpO1xuICAgICAgcmVjdExhYmVsLmF0dHIoJ3gnLCAgLXhQb3MpO1xuICAgIH0gZWxzZSBpZiAoKHhQb3MgKyB3aWR0aC8yICsgMikgPj0gdGhpcy5jaGFydFdpZHRoKCkpIHtcbiAgICAgIGF4aXNUaXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCA1MiknKTtcbiAgICAgIHRleHRMYWJlbC5hdHRyKCdkeCcsIHRoaXMuY2hhcnRXaWR0aCgpIC0gKHhQb3MgKyB3aWR0aCAtIDIpKTtcbiAgICAgIHJlY3RMYWJlbC5hdHRyKCd4JywgdGhpcy5jaGFydFdpZHRoKCkgLSAoeFBvcyArIHdpZHRoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNUaXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgtJyArICh3aWR0aC8yKSArICcsIDUyKScpO1xuICAgICAgcmVjdExhYmVsLmF0dHIoJ3gnLCAwKTtcbiAgICAgIHRleHRMYWJlbC5hdHRyKCdkeCcsICsyKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQ2hhbmdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwucHJldmlvdXMoJ2RhdGEnKS5sZW5ndGggIT0gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkNoYW5nZVJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2xvX2luZGV4JykgPT09IDAgJiYgdGhpcy5tb2RlbC5nZXQoJ2hpX2luZGV4JykgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdyYW5nZV91cGRhdGVkJywgdGhpcy5tb2RlbC5nZXQoJ2xvX2luZGV4JyksIHRoaXMubW9kZWwuZ2V0KCdoaV9pbmRleCcpKTtcbiAgfSxcblxuICBfb25DaGFuZ2VXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5tb2RlbC5nZXQoJ3dpZHRoJyk7XG4gICAgdGhpcy4kZWwud2lkdGgod2lkdGgpO1xuICAgIHRoaXMuY2hhcnQuYXR0cignd2lkdGgnLCB3aWR0aCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93T25XaWR0aENoYW5nZSAmJiB3aWR0aCA+IDApIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICB2YXIgbG9CYXJJbmRleCA9IHRoaXMubW9kZWwuZ2V0KCdsb19pbmRleCcpO1xuICAgIHZhciBoaUJhckluZGV4ID0gdGhpcy5tb2RlbC5nZXQoJ2hpX2luZGV4Jyk7XG4gICAgdGhpcy5zZWxlY3RSYW5nZShsb0JhckluZGV4LCBoaUJhckluZGV4KTtcbiAgfSxcblxuICBfb25DaGFuZ2VIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLm1vZGVsLmdldCgnaGVpZ2h0Jyk7XG5cbiAgICB0aGlzLiRlbC5oZWlnaHQoaGVpZ2h0KTtcbiAgICB0aGlzLmNoYXJ0LmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgdGhpcy5sZWZ0SGFuZGxlLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgdGhpcy5yaWdodEhhbmRsZS5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgdGhpcy5yZXNldCgpO1xuICB9LFxuXG4gIF9vbkNoYW5nU2hvd0xhYmVsczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYXhpcy5zdHlsZSgnb3BhY2l0eScsIHRoaXMubW9kZWwuZ2V0KCdzaG93TGFiZWxzJykgPyAxIDogMCk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlUG9zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5tb2RlbC5nZXQoJ3BvcycpO1xuICAgIHZhciBtYXJnaW4gPSB0aGlzLm1vZGVsLmdldCgnbWFyZ2luJyk7XG5cbiAgICB2YXIgeCA9ICtwb3MueDtcbiAgICB2YXIgeSA9ICtwb3MueTtcblxuICAgIHRoaXMuY2hhcnRcbiAgICAudHJhbnNpdGlvbigpXG4gICAgLmR1cmF0aW9uKDE1MClcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKG1hcmdpbi5sZWZ0ICsgeCkgKyAnLCAnICsgKG1hcmdpbi50b3AgKyB5KSArICcpJyk7XG4gIH0sXG5cbiAgX29uQnJ1c2hTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuYnJ1c2guZXh0ZW50KCk7XG4gICAgdmFyIGhpRXh0ZW50ID0gZXh0ZW50WzFdO1xuICAgIHZhciByaWdodFggPSB0aGlzLnhTY2FsZShoaUV4dGVudCkgLSB0aGlzLm9wdGlvbnMuaGFuZGxlV2lkdGggLyAyO1xuXG4gICAgdGhpcy5jaGFydC5jbGFzc2VkKCdpcy1zZWxlY3RhYmxlJywgdHJ1ZSk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2hhcnQuY2xhc3NlZCgnaXMtZHJhZ2dpbmcnLCB0aGlzLm1vZGVsLmdldCgnZHJhZ2dpbmcnKSk7XG4gICAgdGhpcy5fdXBkYXRlQXhpc1RpcE9wYWNpdHkoJ3JpZ2h0Jyk7XG4gICAgdGhpcy5fdXBkYXRlQXhpc1RpcE9wYWNpdHkoJ2xlZnQnKTtcbiAgfSxcblxuICBfc2hvd0F4aXNUaXA6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciB0ZXh0TGFiZWwgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwVGV4dC5DREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKTtcbiAgICB2YXIgYXhpc1RpcCAgID0gdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtYXhpc1RpcC5DREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKTtcbiAgICB2YXIgcmVjdExhYmVsID0gdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtYXhpc1RpcFJlY3QuQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSk7XG5cbiAgICBpZiAodGV4dExhYmVsKSB7XG4gICAgICB0ZXh0TGFiZWwudHJhbnNpdGlvbigpLmR1cmF0aW9uKDIwMCkuYXR0cignb3BhY2l0eScsICAxKTtcbiAgICB9XG4gICAgaWYgKHJlY3RMYWJlbCkge1xuICAgICAgcmVjdExhYmVsLnRyYW5zaXRpb24oKS5kdXJhdGlvbigyMDApLmF0dHIoJ29wYWNpdHknLCAgMSk7XG4gICAgfVxuICB9LFxuXG4gIF9oaWRlQXhpc1RpcDogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIHRleHRMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBUZXh0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciBheGlzVGlwICAgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwLkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciByZWN0TGFiZWwgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwUmVjdC5DREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKTtcblxuICAgIGlmICh0ZXh0TGFiZWwpIHtcbiAgICAgIHRleHRMYWJlbC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMjAwKS5hdHRyKCdvcGFjaXR5JywgIDApO1xuICAgIH1cbiAgICBpZiAocmVjdExhYmVsKSB7XG4gICAgICByZWN0TGFiZWwudHJhbnNpdGlvbigpLmR1cmF0aW9uKDIwMCkuYXR0cignb3BhY2l0eScsICAwKTtcbiAgICB9XG4gIH0sXG5cbiAgX3VwZGF0ZUF4aXNUaXBPcGFjaXR5OiBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2RyYWdnaW5nJykpIHtcbiAgICAgIHRoaXMuX3Nob3dBeGlzVGlwKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hpZGVBeGlzVGlwKGNsYXNzTmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkJydXNoTW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoeyBkcmFnZ2luZzogdHJ1ZSB9KTtcbiAgICB0aGlzLl9zZWxlY3RCYXJzKCk7XG4gICAgdGhpcy5fYWRqdXN0QnJ1c2hIYW5kbGVzKCk7XG4gIH0sXG5cbiAgX29uTW91c2VPdXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYXJzID0gdGhpcy5jaGFydC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtYmFyJyk7XG4gICAgYmFycy5jbGFzc2VkKCdpcy1oaWdobGlnaHRlZCcsIGZhbHNlKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2hvdmVyJywgeyB2YWx1ZTogbnVsbCB9KTtcbiAgfSxcblxuICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gZDMuZXZlbnQub2Zmc2V0WDtcbiAgICB2YXIgeSA9IGQzLmV2ZW50Lm9mZnNldFk7XG5cbiAgICB2YXIgYmFySW5kZXggPSBNYXRoLmZsb29yKHggLyB0aGlzLmJhcldpZHRoKTtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdkYXRhJyk7XG5cbiAgICBpZiAoZGF0YVtiYXJJbmRleF0gPT09IHVuZGVmaW5lZCB8fCBkYXRhW2JhckluZGV4XSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmVxID0gZGF0YVtiYXJJbmRleF0uZnJlcTtcbiAgICB2YXIgaG92ZXJQcm9wZXJ0aWVzID0ge307XG5cbiAgICB2YXIgYmFyID0gdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtYmFyOm50aC1jaGlsZCgnICsgKGJhckluZGV4ICsgMSkgKyAnKScpO1xuXG4gICAgaWYgKGJhciAmJiBiYXIubm9kZSgpICYmICFiYXIuY2xhc3NlZCgnaXMtc2VsZWN0ZWQnKSkge1xuXG4gICAgICB2YXIgbGVmdCA9IChiYXJJbmRleCAqIHRoaXMuYmFyV2lkdGgpICsgKHRoaXMuYmFyV2lkdGgvMik7XG5cbiAgICAgIHZhciB0b3AgPSB0aGlzLnlTY2FsZShmcmVxKTtcblxuICAgICAgdmFyIGggPSB0aGlzLmNoYXJ0SGVpZ2h0KCkgLSB0aGlzLnlTY2FsZShmcmVxKTtcblxuICAgICAgaWYgKGggPCB0aGlzLm9wdGlvbnMubWluaW11bUJhckhlaWdodCAmJiBoID4gMCkge1xuICAgICAgICB0b3AgPSB0aGlzLmNoYXJ0SGVpZ2h0KCkgLSB0aGlzLm9wdGlvbnMubWluaW11bUJhckhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pc0RyYWdnaW5nKCkgJiYgZnJlcSA+IDApIHtcbiAgICAgICAgdmFyIGQgPSBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyKGZyZXEpO1xuICAgICAgICBob3ZlclByb3BlcnRpZXMgPSB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCBkYXRhOiBkIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3ZlclByb3BlcnRpZXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGhvdmVyUHJvcGVydGllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdob3ZlcicsIGhvdmVyUHJvcGVydGllcyk7XG5cbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKVxuICAgIC5jbGFzc2VkKCdpcy1oaWdobGlnaHRlZCcsIGZhbHNlKTtcblxuICAgIGlmIChiYXIgJiYgYmFyLm5vZGUoKSkge1xuICAgICAgYmFyLmNsYXNzZWQoJ2lzLWhpZ2hsaWdodGVkJywgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZW1vdmVDaGFydENvbnRlbnQoKTtcbiAgICB0aGlzLl9zZXR1cERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLl9jYWxjQmFyV2lkdGgoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUNoYXJ0Q29udGVudCgpO1xuICAgIHRoaXMuX3JlbW92ZVNoYWRvd0JhcnMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZVNoYWRvd0JhcnMoKTtcbiAgfSxcblxuICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXR1cERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLl9yZW1vdmVBeGlzKCk7XG4gICAgdGhpcy5fZ2VuZXJhdGVBeGlzKCk7XG4gICAgdGhpcy5fdXBkYXRlQ2hhcnQoKTtcblxuICAgIHRoaXMuX2dlbmVyYXRlU2hhZG93QmFycygpO1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZXMnKS5tb3ZlVG9Gcm9udCgpO1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQnJ1c2gnKS5tb3ZlVG9Gcm9udCgpO1xuICB9LFxuXG4gIHJlc2V0SW5kZXhlczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoeyBsb19pbmRleDogbnVsbCwgaGlfaW5kZXg6IG51bGwgfSk7XG4gIH0sXG5cbiAgcmVtb3ZlU2hhZG93QmFyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ3Nob3dfc2hhZG93X2JhcnMnLCBmYWxzZSk7XG4gIH0sXG5cbiAgX3JlbW92ZVNoYWRvd0JhcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LXNoYWRvd0JhcnMnKS5yZW1vdmUoKTtcbiAgfSxcblxuICBfcmVtb3ZlQmFyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtYmFycycpLnJlbW92ZSgpO1xuICB9LFxuXG4gIF9yZW1vdmVCcnVzaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5zZWxlY3RBbGwoJy5CcnVzaCcpLnJlbW92ZSgpO1xuICAgIHRoaXMuY2hhcnQuY2xhc3NlZCgnaXMtc2VsZWN0YWJsZScsIGZhbHNlKTtcbiAgfSxcblxuICBfcmVtb3ZlTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWxpbmVzJykucmVtb3ZlKCk7XG4gIH0sXG5cbiAgX3JlbW92ZUNoYXJ0Q29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVtb3ZlQnJ1c2goKTtcbiAgICB0aGlzLl9yZW1vdmVIYW5kbGVzKCk7XG4gICAgdGhpcy5fcmVtb3ZlQmFycygpO1xuICAgIHRoaXMuX3JlbW92ZUF4aXMoKTtcbiAgICB0aGlzLl9yZW1vdmVMaW5lcygpO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUNoYXJ0Q29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVBeGlzKCk7XG4gICAgdGhpcy5fZ2VuZXJhdGVMaW5lcygpO1xuXG4gICAgdGhpcy5fZ2VuZXJhdGVCYXJzKCk7XG4gICAgdGhpcy5fZ2VuZXJhdGVIYW5kbGVzKCk7XG4gICAgdGhpcy5fc2V0dXBCcnVzaCgpO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUxpbmVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZUhvcml6b250YWxMaW5lcygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlICE9PSAndGltZScpIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlVmVydGljYWxMaW5lcygpO1xuICAgIH1cbiAgfSxcblxuICBfZ2VuZXJhdGVWZXJ0aWNhbExpbmVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGluZXMgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1saW5lcycpO1xuXG4gICAgbGluZXMuYXBwZW5kKCdnJylcbiAgICAuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWxpbmUnKVxuICAgIC5kYXRhKHRoaXMudmVydGljYWxSYW5nZS5zbGljZSgxLCB0aGlzLnZlcnRpY2FsUmFuZ2UubGVuZ3RoIC0gMSkpXG4gICAgLmVudGVyKCkuYXBwZW5kKCdzdmc6bGluZScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1saW5lJylcbiAgICAuYXR0cigneTEnLCAwKVxuICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pXG4gICAgLmF0dHIoJ3kyJywgdGhpcy5jaGFydEhlaWdodCgpKVxuICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUhvcml6b250YWxMaW5lczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbmVzID0gdGhpcy5jaGFydC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtbGluZXMnKTtcblxuICAgIGxpbmVzLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ3knKVxuICAgIC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtbGluZScpXG4gICAgLmRhdGEodGhpcy5ob3Jpem9udGFsUmFuZ2UpXG4gICAgLmVudGVyKCkuYXBwZW5kKCdzdmc6bGluZScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1saW5lJylcbiAgICAuYXR0cigneDEnLCAwKVxuICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pXG4gICAgLmF0dHIoJ3gyJywgdGhpcy5jaGFydFdpZHRoKCkpXG4gICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSk7XG5cbiAgICB0aGlzLmJvdHRvbUxpbmUgPSBsaW5lc1xuICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtbGluZSBDREItQ2hhcnQtbGluZS0tYm90dG9tJylcbiAgICAuYXR0cigneDEnLCAwKVxuICAgIC5hdHRyKCd5MScsIHRoaXMuY2hhcnRIZWlnaHQoKSlcbiAgICAuYXR0cigneDInLCB0aGlzLmNoYXJ0V2lkdGgoKSAtIDEpXG4gICAgLmF0dHIoJ3kyJywgdGhpcy5jaGFydEhlaWdodCgpKTtcbiAgfSxcblxuICAgX3NldHVwRDNCaW5kaW5nczogZnVuY3Rpb24oKSB7IC8vIFRPRE86IG1vdmUgdG8gYSBoZWxwZXJcblxuICAgIGQzLnNlbGVjdGlvbi5wcm90b3R5cGUubW92ZVRvQmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIGZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlVG9Gcm9udCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuXG4gIF9zZXR1cE1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsID0gbmV3IE1vZGVsKHtcbiAgICAgIHNob3dMYWJlbHM6IHRydWUsXG4gICAgICBkYXRhOiB0aGlzLm9wdGlvbnMuZGF0YSxcbiAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmhlaWdodCxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBzaG93X3NoYWRvd19iYXJzOiB0aGlzLm9wdGlvbnMuc2hhZG93RGF0YSxcbiAgICAgIG1hcmdpbjogXy5jbG9uZSh0aGlzLm9wdGlvbnMubWFyZ2luKSxcbiAgICAgIHdpZHRoOiAwLCAvLyB3aWxsIGJlIHNldCBvbiByZXNpemUgbGlzdGVuZXJcbiAgICAgIHBvczogeyB4OiAwLCB5OiAwIH1cbiAgICB9KTtcbiAgfSxcblxuICBfc2V0dXBCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6ZGF0YScsIHRoaXMuX29uQ2hhbmdlRGF0YSwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6ZGlzcGxheScsIHRoaXMuX29uQ2hhbmdlRGlzcGxheSwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6ZHJhZ2dpbmcnLCB0aGlzLl9vbkNoYW5nZURyYWdnaW5nLCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpoZWlnaHQnLCB0aGlzLl9vbkNoYW5nZUhlaWdodCwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6bGVmdF9heGlzX3RpcCcsIHRoaXMuX29uQ2hhbmdlTGVmdEF4aXNUaXAsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOmxvX2luZGV4IGNoYW5nZTpoaV9pbmRleCcsIHRoaXMuX29uQ2hhbmdlUmFuZ2UsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOnBvcycsIHRoaXMuX29uQ2hhbmdlUG9zLCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpyaWdodF9heGlzX3RpcCcsIHRoaXMuX29uQ2hhbmdlUmlnaHRBeGlzVGlwLCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpzaG93TGFiZWxzJywgdGhpcy5fb25DaGFuZ1Nob3dMYWJlbHMsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOnNob3dfc2hhZG93X2JhcnMnLCB0aGlzLl9vbkNoYW5nZVNob3dTaGFkb3dCYXJzLCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTp3aWR0aCcsIHRoaXMuX29uQ2hhbmdlV2lkdGgsIHRoaXMpO1xuICB9LFxuXG4gIF9zZXR1cERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldHVwU2NhbGVzKCk7XG4gICAgdGhpcy5fc2V0dXBSYW5nZXMoKTtcbiAgICB0aGlzLl9vbldpbmRvd1Jlc2l6ZSgpO1xuICB9LFxuXG4gIF9zZXR1cFNjYWxlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldCgnZGF0YScpO1xuXG4gICAgdGhpcy54U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWzAsIDEwMF0pLnJhbmdlKFswLCB0aGlzLmNoYXJ0V2lkdGgoKV0pO1xuICAgIHRoaXMueVNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXy5pc0VtcHR5KGQpID8gMCA6IGQuZnJlcTsgfSApXSkucmFuZ2UoW3RoaXMuY2hhcnRIZWlnaHQoKSwgMF0pO1xuXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICB0aGlzLnhBeGlzU2NhbGUgPSBkMy50aW1lLnNjYWxlKCkuZG9tYWluKFtkYXRhWzBdLnN0YXJ0ICogMTAwMCwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdLmVuZCAqIDEwMDBdKS5uaWNlKCkucmFuZ2UoWzAsIHRoaXMuY2hhcnRXaWR0aCgpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueEF4aXNTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLnJhbmdlKFtkYXRhWzBdLnN0YXJ0LCBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uZW5kXSkuZG9tYWluKFswLCB0aGlzLmNoYXJ0V2lkdGgoKV0pO1xuICAgIH1cbiAgfSxcblxuICBfc2V0dXBSYW5nZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gTWF0aC5yb3VuZCh0aGlzLmNoYXJ0V2lkdGgoKSAvIHRoaXMub3B0aW9ucy5kaXZpc2lvbldpZHRoKTtcbiAgICB0aGlzLnZlcnRpY2FsUmFuZ2UgPSBkMy5yYW5nZSgwLCB0aGlzLmNoYXJ0V2lkdGgoKSArIHRoaXMuY2hhcnRXaWR0aCgpIC8gbiwgdGhpcy5jaGFydFdpZHRoKCkgLyBuKTtcbiAgICB0aGlzLmhvcml6b250YWxSYW5nZSA9IGQzLnJhbmdlKDAsIHRoaXMuY2hhcnRIZWlnaHQoKSArIHRoaXMuY2hhcnRIZWlnaHQoKSAvIDIsIHRoaXMuY2hhcnRIZWlnaHQoKSAvIDIpO1xuICB9LFxuXG4gIF9jYWxjQmFyV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYmFyV2lkdGggPSB0aGlzLmNoYXJ0V2lkdGgoKSAvIHRoaXMubW9kZWwuZ2V0KCdkYXRhJykubGVuZ3RoO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUNoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFyZ2luID0gdGhpcy5tb2RlbC5nZXQoJ21hcmdpbicpO1xuXG4gICAgdGhpcy5jaGFydCA9IGQzLnNlbGVjdCh0aGlzLmVsKVxuICAgIC5zZWxlY3RBbGwoJy5DREItV2lkZ2V0Q2FudmFzJylcbiAgICAuYXBwZW5kKCdnJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0JylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCAnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICB0aGlzLmNoYXJ0LmNsYXNzZWQodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJywgdHJ1ZSk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlU2hvd1NoYWRvd0JhcnM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnc2hvd19zaGFkb3dfYmFycycpKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZVNoYWRvd0JhcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93QmFycygpO1xuICAgIH1cbiAgfSxcblxuICBfb25DaGFuZ2VEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2Rpc3BsYXknKSkge1xuICAgICAgdGhpcy5fc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oaWRlKCk7XG4gICAgfVxuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuc2V0KCdkaXNwbGF5JywgZmFsc2UpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuc2V0KCdkaXNwbGF5JywgdHJ1ZSk7XG4gIH0sXG5cbiAgX2hpZGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmhpZGUoKTtcbiAgfSxcblxuICBfc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuc2hvdygpO1xuICB9LFxuXG4gIGlzSGlkZGVuOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMubW9kZWwuZ2V0KCdkaXNwbGF5Jyk7XG4gIH0sXG5cbiAgX3NlbGVjdEJhcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5icnVzaC5leHRlbnQoKTtcbiAgICB2YXIgbG8gPSBleHRlbnRbMF07XG4gICAgdmFyIGhpID0gZXh0ZW50WzFdO1xuXG5cbiAgICB0aGlzLm1vZGVsLnNldCh7IGxvX2luZGV4OiB0aGlzLl9nZXRMb0JhckluZGV4KCksIGhpX2luZGV4OiB0aGlzLl9nZXRIaUJhckluZGV4KCkgfSk7XG5cbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKS5jbGFzc2VkKCdpcy1zZWxlY3RlZCcsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBhID0gTWF0aC5mbG9vcihpICogc2VsZi5iYXJXaWR0aCk7XG4gICAgICB2YXIgYiA9IE1hdGguZmxvb3IoYSArIHNlbGYuYmFyV2lkdGgpO1xuICAgICAgdmFyIExPID0gTWF0aC5mbG9vcihzZWxmLnhTY2FsZShsbykpO1xuICAgICAgdmFyIEhJID0gTWF0aC5mbG9vcihzZWxmLnhTY2FsZShoaSkpO1xuICAgICAgdmFyIGlzSW4gPSAoYSA+IExPICYmIGEgPCBISSkgfHwgKGIgPiBMTyAmJiBiIDwgSEkpIHx8IChhIDw9IExPICYmIGIgPj0gSEkpO1xuICAgICAgcmV0dXJuICFpc0luO1xuICAgIH0pO1xuICB9LFxuXG4gIF9pc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXQoJ2RyYWdnaW5nJyk7XG4gIH0sXG5cbiAgX21vdmU6IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMubW9kZWwuc2V0KHsgcG9zOiBwb3MgfSk7XG4gIH0sXG5cbiAgZXhwYW5kOiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICB0aGlzLmNhbnZhcy5hdHRyKCdoZWlnaHQnLCB0aGlzLm1vZGVsLmdldCgnaGVpZ2h0JykgKyBoZWlnaHQpO1xuICAgIHRoaXMuX21vdmUoeyB4OiAwLCB5OiBoZWlnaHQgfSk7XG4gIH0sXG5cbiAgY29udHJhY3Q6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgIHRoaXMuY2FudmFzLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgdGhpcy5fbW92ZSh7IHg6IDAsIHk6IDAgfSk7XG4gIH0sXG5cbiAgcmVzaXplSGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgfSxcblxuICByZW1vdmVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzZXRJbmRleGVzKCk7XG4gICAgdGhpcy5jaGFydC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtYmFyJykuY2xhc3NlZCgnaXMtc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgdGhpcy5fcmVtb3ZlQnJ1c2goKTtcbiAgICB0aGlzLl9zZXR1cEJydXNoKCk7XG4gIH0sXG5cbiAgc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpIHtcbiAgICBpZiAoIWxvQmFySW5kZXggJiYgIWhpQmFySW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbG9Qb3NpdGlvbiA9IHRoaXMuX2dldEJhclBvc2l0aW9uKGxvQmFySW5kZXgpO1xuICAgIHZhciBoaVBvc2l0aW9uID0gdGhpcy5fZ2V0QmFyUG9zaXRpb24oaGlCYXJJbmRleCk7XG5cbiAgICB0aGlzLl9zZWxlY3RSYW5nZShsb1Bvc2l0aW9uLCBoaVBvc2l0aW9uKTtcbiAgfSxcblxuICBfc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uKGxvUG9zaXRpb24sIGhpUG9zaXRpb24pIHtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdCgnLkJydXNoJykudHJhbnNpdGlvbigpXG4gICAgLmR1cmF0aW9uKHRoaXMuYnJ1c2guZW1wdHkoKSA/IDAgOiAxNTApXG4gICAgLmNhbGwodGhpcy5icnVzaC5leHRlbnQoW2xvUG9zaXRpb24sIGhpUG9zaXRpb25dKSlcbiAgICAuY2FsbCh0aGlzLmJydXNoLmV2ZW50KTtcbiAgfSxcblxuICBfZ2V0TG9CYXJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuYnJ1c2guZXh0ZW50KCk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy54U2NhbGUoZXh0ZW50WzBdKSAvIHRoaXMuYmFyV2lkdGgpO1xuICB9LFxuXG4gIF9nZXRIaUJhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5icnVzaC5leHRlbnQoKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLnhTY2FsZShleHRlbnRbMV0pIC8gdGhpcy5iYXJXaWR0aCk7XG4gIH0sXG5cbiAgX2dldEJhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IGQzLmV2ZW50LnNvdXJjZUV2ZW50Lm9mZnNldFg7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoeCAvIHRoaXMuYmFyV2lkdGgpO1xuICB9LFxuXG4gIF9nZXRCYXJQb3NpdGlvbjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdkYXRhJyk7XG4gICAgcmV0dXJuIGluZGV4ICogKDEwMCAvIGRhdGEubGVuZ3RoKTtcbiAgfSxcblxuICBfc2V0dXBCcnVzaDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHhTY2FsZSA9IHRoaXMueFNjYWxlO1xuICAgIHZhciBicnVzaCA9IHRoaXMuYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKS54KHRoaXMueFNjYWxlKTtcblxuICAgIGZ1bmN0aW9uIG9uQnJ1c2hFbmQoKSB7XG4gICAgICB2YXIgZGF0YSA9IHNlbGYubW9kZWwuZ2V0KCdkYXRhJyk7XG4gICAgICB2YXIgbG9Qb3NpdGlvbiwgaGlQb3NpdGlvbjtcblxuICAgICAgc2VsZi5tb2RlbC5zZXQoeyBkcmFnZ2luZzogZmFsc2UgfSk7XG5cbiAgICAgIGlmIChicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgIHNlbGYuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWJhcicpLmNsYXNzZWQoJ2lzLXNlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaC5leHRlbnQoWzAsIDBdKSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBsb0JhckluZGV4ID0gc2VsZi5fZ2V0TG9CYXJJbmRleCgpO1xuICAgICAgICB2YXIgaGlCYXJJbmRleCA9IHNlbGYuX2dldEhpQmFySW5kZXgoKTtcblxuICAgICAgICBsb1Bvc2l0aW9uID0gc2VsZi5fZ2V0QmFyUG9zaXRpb24obG9CYXJJbmRleCk7XG4gICAgICAgIGhpUG9zaXRpb24gPSBzZWxmLl9nZXRCYXJQb3NpdGlvbihoaUJhckluZGV4KTtcblxuICAgICAgICBpZiAoIWQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvQmFySW5kZXggPT09IGhpQmFySW5kZXgpIHtcbiAgICAgICAgICBpZiAoaGlCYXJJbmRleCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9Qb3NpdGlvbiA9IHNlbGYuX2dldEJhclBvc2l0aW9uKGxvQmFySW5kZXggLSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlQb3NpdGlvbiA9IHNlbGYuX2dldEJhclBvc2l0aW9uKGhpQmFySW5kZXggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9zZWxlY3RSYW5nZShsb1Bvc2l0aW9uLCBoaVBvc2l0aW9uKTtcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoeyBsb19pbmRleDogbG9CYXJJbmRleCwgaGlfaW5kZXg6IGhpQmFySW5kZXggfSk7XG4gICAgICAgIHNlbGYuX2FkanVzdEJydXNoSGFuZGxlcygpO1xuICAgICAgICBzZWxmLl9zZWxlY3RCYXJzKCk7XG5cbiAgICAgICAgc2VsZi50cmlnZ2VyKCdvbl9icnVzaF9lbmQnLCBzZWxmLm1vZGVsLmdldCgnbG9faW5kZXgnKSwgc2VsZi5tb2RlbC5nZXQoJ2hpX2luZGV4JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgJiYgbG9Qb3NpdGlvbiA9PT0gdW5kZWZpbmVkICYmIGhpUG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYmFySW5kZXggPSBzZWxmLl9nZXRCYXJJbmRleCgpO1xuXG4gICAgICAgIGxvUG9zaXRpb24gPSBzZWxmLl9nZXRCYXJQb3NpdGlvbihiYXJJbmRleCk7XG4gICAgICAgIGhpUG9zaXRpb24gPSBzZWxmLl9nZXRCYXJQb3NpdGlvbihiYXJJbmRleCArIDEpO1xuXG4gICAgICAgIHNlbGYubW9kZWwuc2V0KHsgbG9faW5kZXg6IGJhckluZGV4LCBoaV9pbmRleDogYmFySW5kZXggKyAxIH0pO1xuICAgICAgICBzZWxmLl9zZWxlY3RSYW5nZShsb1Bvc2l0aW9uLCBoaVBvc2l0aW9uKTtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdvbl9icnVzaF9lbmQnLCBzZWxmLm1vZGVsLmdldCgnbG9faW5kZXgnKSwgc2VsZi5tb2RlbC5nZXQoJ2hpX2luZGV4JykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKTtcblxuICAgIHRoaXMuYnJ1c2hcbiAgICAub24oJ2JydXNoc3RhcnQnLCB0aGlzLl9vbkJydXNoU3RhcnQpXG4gICAgLm9uKCdicnVzaCcsIHRoaXMuX29uQnJ1c2hNb3ZlKVxuICAgIC5vbignYnJ1c2hlbmQnLCBvbkJydXNoRW5kKTtcblxuICAgIHRoaXMuY2hhcnQuYXBwZW5kKCdnJylcbiAgICAuYXR0cignY2xhc3MnLCAnQnJ1c2gnKVxuICAgIC5jYWxsKHRoaXMuYnJ1c2gpXG4gICAgLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgLmF0dHIoJ3knLCAwKVxuICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmNoYXJ0SGVpZ2h0KCkpXG4gICAgLm9uKCdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQpXG4gICAgLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gIH0sXG5cbiAgX2FkanVzdEJydXNoSGFuZGxlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuYnJ1c2guZXh0ZW50KCk7XG5cbiAgICB2YXIgbG9FeHRlbnQgPSBleHRlbnRbMF07XG4gICAgdmFyIGhpRXh0ZW50ID0gZXh0ZW50WzFdO1xuXG4gICAgdmFyIGxlZnRYICA9IHRoaXMueFNjYWxlKGxvRXh0ZW50KSAtIHRoaXMub3B0aW9ucy5oYW5kbGVXaWR0aCAvIDI7XG4gICAgdmFyIHJpZ2h0WCA9IHRoaXMueFNjYWxlKGhpRXh0ZW50KSAtIHRoaXMub3B0aW9ucy5oYW5kbGVXaWR0aCAvIDI7XG5cbiAgICB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1oYW5kbGUtbGVmdCcpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGxlZnRYICsgJywgMCknKTtcblxuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZS1yaWdodCcpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHJpZ2h0WCArICcsIDApJyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhc0F4aXNUaXApIHtcbiAgICAgIHRoaXMubW9kZWwuc2V0KHtcbiAgICAgICAgbGVmdF9heGlzX3RpcDogdGhpcy54QXhpc1NjYWxlKGxlZnRYICsgMyksXG4gICAgICAgIHJpZ2h0X2F4aXNfdGlwOiB0aGlzLnhBeGlzU2NhbGUocmlnaHRYICsgMylcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBfZ2VuZXJhdGVBeGlzVGlwOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcblxuICAgIHZhciBoYW5kbGUgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1oYW5kbGUuQ0RCLUNoYXJ0LWhhbmRsZS0nICsgY2xhc3NOYW1lKTtcblxuICAgIHZhciBheGlzVGlwID0gaGFuZGxlLnNlbGVjdEFsbChcImdcIilcbiAgICAuZGF0YShbJyddKVxuICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWF4aXNUaXAgQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSlcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZSgwLDUyKVwiOyB9KTtcblxuICAgIHRoaXMucmVjdExhYmVsID0gYXhpc1RpcC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1heGlzVGlwUmVjdCBDREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKVxuICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDEyKVxuICAgIC5hdHRyKFwid2lkdGhcIiwgMTApO1xuXG4gICAgdGhpcy50ZXh0TGFiZWwgPSBheGlzVGlwLmFwcGVuZChcInRleHRcIilcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWF4aXNUaXBUZXh0IENEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpXG4gICAgLmF0dHIoXCJkeVwiLCBcIjExXCIpXG4gICAgLmF0dHIoXCJkeFwiLCBcIjBcIilcbiAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTtcbiAgfSxcblxuICBfZ2VuZXJhdGVIYW5kbGU6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciBvcHRzID0geyB3aWR0aDogdGhpcy5vcHRpb25zLmhhbmRsZVdpZHRoLCBoZWlnaHQ6IHRoaXMub3B0aW9ucy5oYW5kbGVIZWlnaHQsIHJhZGl1czogdGhpcy5vcHRpb25zLmhhbmRsZVJhZGl1cyB9O1xuICAgIHZhciB5UG9zID0gKHRoaXMuY2hhcnRIZWlnaHQoKSAvIDIpIC0gKHRoaXMub3B0aW9ucy5oYW5kbGVIZWlnaHQgLyAyKTtcblxuICAgIHZhciBoYW5kbGUgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1oYW5kbGVzJylcbiAgICAuYXBwZW5kKCdnJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWhhbmRsZSBDREItQ2hhcnQtaGFuZGxlLScgKyBjbGFzc05hbWUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYXNBeGlzVGlwKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZUF4aXNUaXAoY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBoYW5kbGVcbiAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWhhbmRsZUxpbmUnKVxuICAgIC5hdHRyKCd4MScsIDMpXG4gICAgLmF0dHIoJ3kxJywgLTQpXG4gICAgLmF0dHIoJ3gyJywgMylcbiAgICAuYXR0cigneTInLCB0aGlzLmNoYXJ0SGVpZ2h0KCkgKyA0KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFzSGFuZGxlcykge1xuICAgICAgaGFuZGxlXG4gICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtaGFuZGxlUmVjdCcpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAnICsgeVBvcyArICcpJylcbiAgICAgIC5hdHRyKCd3aWR0aCcsIG9wdHMud2lkdGgpXG4gICAgICAuYXR0cignaGVpZ2h0Jywgb3B0cy5oZWlnaHQpXG4gICAgICAuYXR0cigncngnLCBvcHRzLnJhZGl1cylcbiAgICAgIC5hdHRyKCdyeScsIG9wdHMucmFkaXVzKTtcblxuICAgICAgdmFyIHkgPSAyMTsgLy8gaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgZ3JpcFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBoYW5kbGVcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtaGFuZGxlR3JpcCcpXG4gICAgICAgIC5hdHRyKCd4MScsIDIpXG4gICAgICAgIC5hdHRyKCd5MScsIHkgKyBpKjMpXG4gICAgICAgIC5hdHRyKCd4MicsIDQpXG4gICAgICAgIC5hdHRyKCd5MicsIHkgKyBpKjMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH0sXG5cbiAgX2dlbmVyYXRlSGFuZGxlczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtaGFuZGxlcycpO1xuICAgIHRoaXMubGVmdEhhbmRsZSAgPSB0aGlzLl9nZW5lcmF0ZUhhbmRsZSgnbGVmdCcpO1xuICAgIHRoaXMucmlnaHRIYW5kbGUgPSB0aGlzLl9nZW5lcmF0ZUhhbmRsZSgncmlnaHQnKTtcbiAgfSxcblxuICBfZ2VuZXJhdGVIYW5kbGVMaW5lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtaGFuZGxlcycpLmFwcGVuZCgnbGluZScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1oYW5kbGVMaW5lJylcbiAgICAuYXR0cigneDEnLCAwKVxuICAgIC5hdHRyKCd5MScsIDApXG4gICAgLmF0dHIoJ3gyJywgMClcbiAgICAuYXR0cigneTInLCB0aGlzLmNoYXJ0SGVpZ2h0KCkpO1xuICB9LFxuXG4gIF9yZW1vdmVIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1oYW5kbGVzJykucmVtb3ZlKCk7XG4gIH0sXG5cbiAgX3JlbW92ZUF4aXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FudmFzLnNlbGVjdCgnLkNEQi1DaGFydC1heGlzJykucmVtb3ZlKCk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlQWRqdXN0QW5jaG9yTWV0aG9kOiBmdW5jdGlvbih0aWNrcykge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAodGlja3MubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgX2dlbmVyYXRlQXhpczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYXhpcyA9IHRoaXMub3B0aW9ucy50eXBlID09PSAndGltZSdcbiAgICAgID8gdGhpcy5fZ2VuZXJhdGVUaW1lQXhpcygpXG4gICAgICA6IHRoaXMuX2dlbmVyYXRlTnVtZXJpY0F4aXMoKTtcblxuICAgIHRoaXMuX29uQ2hhbmdTaG93TGFiZWxzKCk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlTnVtZXJpY0F4aXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWRqdXN0VGV4dEFuY2hvciA9IHRoaXMuX2dlbmVyYXRlQWRqdXN0QW5jaG9yTWV0aG9kKHRoaXMudmVydGljYWxSYW5nZSk7XG5cbiAgICB2YXIgYXhpcyA9IHRoaXMuY2hhcnQuYXBwZW5kKCdnJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWF4aXMnKTtcblxuICAgIGF4aXNcbiAgICAuYXBwZW5kKCdnJylcbiAgICAuc2VsZWN0QWxsKCcuTGFiZWwnKVxuICAgIC5kYXRhKHRoaXMudmVydGljYWxSYW5nZSlcbiAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pXG4gICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHNlbGYuY2hhcnRIZWlnaHQoKSArIDE1OyB9KVxuICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgYWRqdXN0VGV4dEFuY2hvcilcbiAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdE51bWJlcihzZWxmLnhBeGlzU2NhbGUoZCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF4aXM7XG4gIH0sXG5cbiAgX2dlbmVyYXRlVGltZUF4aXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhZGp1c3RUZXh0QW5jaG9yID0gdGhpcy5fZ2VuZXJhdGVBZGp1c3RBbmNob3JNZXRob2QodGhpcy54QXhpc1NjYWxlLnRpY2tzKCkpO1xuXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgIC5vcmllbnQoXCJib3R0b21cIilcbiAgICAudGlja1BhZGRpbmcoNSlcbiAgICAuaW5uZXJUaWNrU2l6ZSgtdGhpcy5jaGFydEhlaWdodCgpKVxuICAgIC5zY2FsZSh0aGlzLnhBeGlzU2NhbGUpXG4gICAgLm9yaWVudCgnYm90dG9tJyk7XG5cbiAgICB2YXIgYXhpcyA9IHRoaXMuY2FudmFzLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoXCJjbGFzc1wiLCAnQ0RCLUNoYXJ0LWF4aXMnKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyAodGhpcy5jaGFydEhlaWdodCgpICsgNSkgKyBcIilcIilcbiAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICBheGlzLnNlbGVjdEFsbCgndGV4dCcpLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGFkanVzdFRleHRBbmNob3IpO1xuICAgIGF4aXMubW92ZVRvQmFjaygpO1xuXG4gICAgcmV0dXJuIGF4aXM7XG4gIH0sXG5cbiAgX3VwZGF0ZUNoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldCgnZGF0YScpO1xuXG4gICAgdmFyIGJhcnMgPSB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKVxuICAgIC5kYXRhKGRhdGEpO1xuXG4gICAgYmFyc1xuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZCgncmVjdCcpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1iYXInKVxuICAgIC5hdHRyKCdkYXRhJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gXy5pc0VtcHR5KGQpID8gMCA6ICBkLmZyZXE7IH0pXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoaSAqIHNlbGYuYmFyV2lkdGgpICsgJywgMCApJztcbiAgICB9KVxuICAgIC5hdHRyKCd5Jywgc2VsZi5jaGFydEhlaWdodCgpKVxuICAgIC5hdHRyKCdoZWlnaHQnLCAwKVxuICAgIC5hdHRyKCd3aWR0aCcsIE1hdGgubWF4KDAsIHRoaXMuYmFyV2lkdGggLSAxKSk7XG5cbiAgICBiYXJzXG4gICAgLnRyYW5zaXRpb24oKVxuICAgIC5kdXJhdGlvbigyMDApXG4gICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQpIHtcblxuICAgICAgaWYgKF8uaXNFbXB0eShkKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGggPSBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSBzZWxmLnlTY2FsZShkLmZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIGggPSBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgIH0pXG4gICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkKSB7XG4gICAgICBpZiAoXy5pc0VtcHR5KGQpKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoID0gc2VsZi5jaGFydEhlaWdodCgpIC0gc2VsZi55U2NhbGUoZC5mcmVxKTtcblxuICAgICAgaWYgKGggPCBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodCAmJiBoID4gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi5jaGFydEhlaWdodCgpIC0gc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi55U2NhbGUoZC5mcmVxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGJhcnNcbiAgICAuZXhpdCgpXG4gICAgLnRyYW5zaXRpb24oKVxuICAgIC5kdXJhdGlvbigyMDApXG4gICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0pXG4gICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gc2VsZi5jaGFydEhlaWdodCgpO1xuICAgIH0pO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUJhcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdkYXRhJyk7XG5cbiAgICB0aGlzLl9jYWxjQmFyV2lkdGgoKTtcblxuICAgIHZhciBiYXJzID0gdGhpcy5jaGFydC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDApJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWJhcnMnKVxuICAgIC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtYmFyJylcbiAgICAuZGF0YShkYXRhKTtcblxuICAgIGJhcnNcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYmFyJylcbiAgICAuYXR0cignZGF0YScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIF8uaXNFbXB0eShkKSA/IDAgOiAgZC5mcmVxOyB9KVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKGkgKiBzZWxmLmJhcldpZHRoKSArICcsIDAgKSc7XG4gICAgfSlcbiAgICAuYXR0cigneScsIHNlbGYuY2hhcnRIZWlnaHQoKSlcbiAgICAuYXR0cignaGVpZ2h0JywgMClcbiAgICAuYXR0cignd2lkdGgnLCBNYXRoLm1heCgwLCB0aGlzLmJhcldpZHRoIC0gMSkpO1xuXG4gICAgYmFyc1xuICAgIC50cmFuc2l0aW9uKClcbiAgICAuZWFzZSh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblR5cGUpXG4gICAgLmR1cmF0aW9uKHRoaXMub3B0aW9ucy5hbmltYXRpb25TcGVlZClcbiAgICAuZGVsYXkodGhpcy5vcHRpb25zLmFuaW1hdGlvbkJhckRlbGF5KVxuICAgIC50cmFuc2l0aW9uKClcbiAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCkge1xuXG4gICAgICBpZiAoXy5pc0VtcHR5KGQpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYueVNjYWxlKGQuZnJlcSk7XG5cbiAgICAgIGlmIChoIDwgc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQgJiYgaCA+IDApIHtcbiAgICAgICAgaCA9IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgfSlcbiAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmIChfLmlzRW1wdHkoZCkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhcnRIZWlnaHQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGggPSBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSBzZWxmLnlTY2FsZShkLmZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLnlTY2FsZShkLmZyZXEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHNob3dTaGFkb3dCYXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnc2hvd19zaGFkb3dfYmFycycsIHRydWUpO1xuICB9LFxuXG4gIF9nZW5lcmF0ZVNoYWRvd0JhcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5vcHRpb25zLnNoYWRvd0RhdGE7XG5cbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICF0aGlzLm1vZGVsLmdldCgnc2hvd19zaGFkb3dfYmFycycpKSB7XG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3dCYXJzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVtb3ZlU2hhZG93QmFycygpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHlTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihbMCwgZDMubWF4KGRhdGEsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIF8uaXNFbXB0eShkKSA/IDAgOiBkLmZyZXE7IH0gKV0pLnJhbmdlKFt0aGlzLmNoYXJ0SGVpZ2h0KCksIDBdKTtcbiAgICB2YXIgYmFyV2lkdGggPSB0aGlzLmNoYXJ0V2lkdGgoKSAvIGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIGJhcnMgPSB0aGlzLmNoYXJ0LmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgMCknKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtc2hhZG93QmFycycpXG4gICAgLnNlbGVjdEFsbCgnLkNEQi1DaGFydC1zaGFkb3dCYXInKVxuICAgIC5kYXRhKGRhdGEpXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LXNoYWRvd0JhcicpXG4gICAgLmF0dHIoJ2RhdGEnLCBmdW5jdGlvbihkKSB7IHJldHVybiBfLmlzRW1wdHkoZCkgPyAwIDogIGQuZnJlcTsgfSlcbiAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChpICogYmFyV2lkdGgpICsgJywgMCApJztcbiAgICB9KVxuICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKF8uaXNFbXB0eShkKSkge1xuICAgICAgICByZXR1cm4gc2VsZi5jaGFydEhlaWdodCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHNlbGYuY2hhcnRIZWlnaHQoKSAtIHlTY2FsZShkLmZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB5U2NhbGUoZC5mcmVxKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5hdHRyKCd3aWR0aCcsIE1hdGgubWF4KDAsIGJhcldpZHRoIC0gMSkpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQpIHtcblxuICAgICAgaWYgKF8uaXNFbXB0eShkKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGggPSBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSB5U2NhbGUoZC5mcmVxKTtcblxuICAgICAgaWYgKGggPCBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodCAmJiBoID4gMCkge1xuICAgICAgICBoID0gc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaDtcbiAgICB9KTtcblxuICAgIC8vIFdlIG5lZWQgdG8gZXhwbGljaXRseSBtb3ZlIHRoZSBsaW5lcyBvZiB0aGUgZ3JpZCBiZWhpbmQgdGhlIHNoYWRvdyBiYXJzXG4gICAgdGhpcy5jaGFydC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtc2hhZG93QmFycycpLm1vdmVUb0JhY2soKTtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1saW5lcycpLm1vdmVUb0JhY2soKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBIaXN0b2dyYW1UaXRsZVZpZXcgPSByZXF1aXJlKCcuL2hpc3RvZ3JhbV90aXRsZV92aWV3Jyk7XG52YXIgV2lkZ2V0Q29udGVudCA9IHJlcXVpcmUoJy4uL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3ZpZXcnKTtcbnZhciBXaWRnZXRWaWV3TW9kZWwgPSByZXF1aXJlKCcuLi93aWRnZXRfY29udGVudF9tb2RlbCcpO1xudmFyIEhpc3RvZ3JhbUNoYXJ0VmlldyA9IHJlcXVpcmUoJy4vY2hhcnQnKTtcbnZhciBwbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vcGxhY2Vob2xkZXIudHBsJyk7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2NvbnRlbnQudHBsJyk7XG52YXIgQW5pbWF0ZVZhbHVlcyA9IHJlcXVpcmUoJy4uL2FuaW1hdGVfdmFsdWVzLmpzJyk7XG52YXIgYW5pbWF0aW9uVGVtcGxhdGUgPSByZXF1aXJlKCcuL2FuaW1hdGlvbl90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBXaWRnZXQgY29udGVudCB2aWV3IGZvciBhIGhpc3RvZ3JhbVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldENvbnRlbnQuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIGNoYXJ0SGVpZ2h0OiA0OCArIDIwICsgNFxuICB9LFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtY2xlYXInOiAnX2NsZWFyJyxcbiAgICAnY2xpY2sgLmpzLXpvb20nOiAnX3pvb20nXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgV2lkZ2V0Vmlld01vZGVsKCk7XG4gICAgdGhpcy5sb2NrZWRCeVVzZXIgPSBmYWxzZTtcbiAgICBXaWRnZXRDb250ZW50LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgX2luaXRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRpdGxlVmlldyA9IG5ldyBIaXN0b2dyYW1UaXRsZVZpZXcoe1xuICAgICAgdmlld01vZGVsOiB0aGlzLnZpZXdNb2RlbCxcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5tb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuJCgnLmpzLXRpdGxlJykuaHRtbCh0aXRsZVZpZXcucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyh0aXRsZVZpZXcpO1xuXG4gICAgdGhpcy5fcmVuZGVyTWluaUNoYXJ0KCk7XG4gICAgdGhpcy5fcmVuZGVyTWFpbkNoYXJ0KCk7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5vbmNlKCdjaGFuZ2U6ZGF0YScsIHRoaXMuX29uRmlyc3RMb2FkLCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpjb2xsYXBzZWQnLCBmdW5jdGlvbihtZGwsIGlzQ29sbGFwc2VkKSB7XG4gICAgICB0aGlzLiRlbC50b2dnbGVDbGFzcygnaXMtY29sbGFwc2VkJywgISFpc0NvbGxhcHNlZCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX29uRmlyc3RMb2FkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHRoaXMuX3N0b3JlQm91bmRzKCk7XG5cbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlTW9kZWwsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuX2ZldGNoKCk7XG4gIH0sXG5cbiAgX3N0b3JlQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zdGFydCA9IGRhdGFbMF0uc3RhcnQ7XG4gICAgICB0aGlzLmVuZCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5lbmQ7XG4gICAgICB0aGlzLmJpbnNDb3VudCA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5tb2RlbC5zZXQoeyBzdGFydDogdGhpcy5zdGFydCwgZW5kOiB0aGlzLmVuZCwgYmluczogdGhpcy5iaW5zQ291bnQgfSk7XG4gICAgfVxuICB9LFxuXG4gIF9pc1pvb21lZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld01vZGVsLmdldCgnem9vbWVkJyk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlTW9kZWw6IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gV2hlbiB0aGUgaGlzdG9ncmFtIGlzIHpvb21lZCwgd2UgZG9uJ3QgbmVlZCB0byByZWx5XG4gICAgLy8gb24gdGhlIGNoYW5nZSB1cmwgdG8gdXBkYXRlIHRoZSBoaXN0b2dyYW1cbiAgICBpZiAodGhpcy5tb2RlbC5jaGFuZ2VkLnVybCAmJiB0aGlzLl9pc1pvb21lZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGFjdGlvbiB3YXMgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG4gICAgLy8gZG9uJ3QgcmVwbGFjZSB0aGUgc3RvcmVkIGRhdGFcbiAgICBpZiAodGhpcy5sb2NrZWRCeVVzZXIpIHtcbiAgICAgIHRoaXMubG9ja2VkQnlVc2VyID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9pc1pvb21lZCgpKSB7XG4gICAgICAgIHRoaXMuem9vbWVkRGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuc2hvd1NoYWRvd0JhcnMoKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbERhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICAgICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVwbGFjZURhdGEodGhpcy5tb2RlbC5nZXREYXRhKCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVuc2V0dGluZ1JhbmdlKSB7XG4gICAgICB0aGlzLl91bnNldFJhbmdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9pc1pvb21lZCgpICYmICF0aGlzLmxvY2tab29tZWREYXRhKSB7XG4gICAgICAgIHRoaXMubG9ja1pvb21lZERhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLnpvb21lZERhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTdGF0cygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBpc0RhdGFFbXB0eSA9IF8uaXNFbXB0eShkYXRhKSB8fCBfLnNpemUoZGF0YSkgPT09IDA7XG5cbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICB0aXRsZTogdGhpcy5tb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIGl0ZW1zQ291bnQ6ICFpc0RhdGFFbXB0eSA/IGRhdGEubGVuZ3RoIDogJy0nXG4gICAgICB9KVxuICAgICk7XG5cbiAgICBpZiAoaXNEYXRhRW1wdHkpIHtcbiAgICAgIHRoaXMuX2FkZFBsYWNlaG9sZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgICB0aGlzLl9zZXR1cEJpbmRpbmdzKCk7XG4gICAgICB0aGlzLl9pbml0Vmlld3MoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfdW5zZXRSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51bnNldHRpbmdSYW5nZSA9IGZhbHNlO1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LnJlcGxhY2VEYXRhKHRoaXMub3JpZ2luYWxEYXRhKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQoeyBsb19pbmRleDogbnVsbCwgaGlfaW5kZXg6IG51bGwgfSk7XG5cbiAgICBpZiAoIXRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LnNob3dTaGFkb3dCYXJzKCk7XG4gICAgfVxuICB9LFxuXG4gIF9hZGRQbGFjZWhvbGRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kKCcuanMtY29udGVudCcpLmFwcGVuZChwbGFjZWhvbGRlcigpKTtcbiAgfSxcblxuICBfcmVuZGVyTWFpbkNoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0VmlldyA9IG5ldyBIaXN0b2dyYW1DaGFydFZpZXcoKHtcbiAgICAgIG1hcmdpbjogeyB0b3A6IDQsIHJpZ2h0OiA0LCBib3R0b206IDQsIGxlZnQ6IDQgfSxcbiAgICAgIGhhc1NoYWRvd0JhcmRzOiB0cnVlLFxuICAgICAgaGFzSGFuZGxlczogdHJ1ZSxcbiAgICAgIGhhc0F4aXNUaXA6IHRydWUsXG4gICAgICB3aWR0aDogdGhpcy5jYW52YXNXaWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5kZWZhdWx0cy5jaGFydEhlaWdodCxcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwuZ2V0RGF0YSgpLFxuICAgICAgc2hhZG93RGF0YTogdGhpcy5tb2RlbC5nZXREYXRhKClcbiAgICB9KSk7XG5cbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LmVsKTtcbiAgICB0aGlzLmFkZFZpZXcodGhpcy5oaXN0b2dyYW1DaGFydFZpZXcpO1xuXG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuYmluZCgncmFuZ2VfdXBkYXRlZCcsIHRoaXMuX29uUmFuZ2VVcGRhdGVkLCB0aGlzKTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5iaW5kKCdvbl9icnVzaF9lbmQnLCB0aGlzLl9vbkJydXNoRW5kLCB0aGlzKTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5iaW5kKCdob3ZlcicsIHRoaXMuX29uVmFsdWVIb3ZlciwgdGhpcyk7XG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVuZGVyKCkuc2hvdygpO1xuXG4gICAgdGhpcy5fdXBkYXRlU3RhdHMoKTtcbiAgfSxcblxuICBfcmVuZGVyTWluaUNoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1pbmlIaXN0b2dyYW1DaGFydFZpZXcgPSBuZXcgSGlzdG9ncmFtQ2hhcnRWaWV3KCh7XG4gICAgICBjbGFzc05hbWU6ICdDREItQ2hhcnQtLW1pbmknLFxuICAgICAgbWFyZ2luOiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogNCwgbGVmdDogNCB9LFxuICAgICAgaGVpZ2h0OiA0MCxcbiAgICAgIHNob3dPbldpZHRoQ2hhbmdlOiBmYWxzZSxcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwuZ2V0RGF0YSgpXG4gICAgfSkpO1xuXG4gICAgdGhpcy5hZGRWaWV3KHRoaXMubWluaUhpc3RvZ3JhbUNoYXJ0Vmlldyk7XG4gICAgdGhpcy4kKCcuanMtY29udGVudCcpLmFwcGVuZCh0aGlzLm1pbmlIaXN0b2dyYW1DaGFydFZpZXcuZWwpO1xuICAgIHRoaXMubWluaUhpc3RvZ3JhbUNoYXJ0Vmlldy5iaW5kKCdvbl9icnVzaF9lbmQnLCB0aGlzLl9vbk1pbmlSYW5nZVVwZGF0ZWQsIHRoaXMpO1xuICAgIHRoaXMubWluaUhpc3RvZ3JhbUNoYXJ0Vmlldy5yZW5kZXIoKTtcbiAgfSxcblxuICBfc2V0dXBCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwuYmluZCgnY2hhbmdlOnpvb21lZCcsIHRoaXMuX29uQ2hhbmdlWm9vbWVkLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6em9vbV9lbmFibGVkJywgdGhpcy5fb25DaGFuZ2Vab29tRW5hYmxlZCwgdGhpcyk7XG4gICAgdGhpcy52aWV3TW9kZWwuYmluZCgnY2hhbmdlOmZpbHRlcl9lbmFibGVkJywgdGhpcy5fb25DaGFuZ2VGaWx0ZXJFbmFibGVkLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6dG90YWwnLCB0aGlzLl9vbkNoYW5nZVRvdGFsLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6bnVsbHMnLCB0aGlzLl9vbkNoYW5nZU51bGxzLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6bWF4JywgICB0aGlzLl9vbkNoYW5nZU1heCwgdGhpcyk7XG4gICAgdGhpcy52aWV3TW9kZWwuYmluZCgnY2hhbmdlOm1pbicsICAgdGhpcy5fb25DaGFuZ2VNaW4sIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTphdmcnLCAgIHRoaXMuX29uQ2hhbmdlQXZnLCB0aGlzKTtcbiAgfSxcblxuICBfY2xlYXJUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoXCIuanMtdG9vbHRpcFwiKS5zdG9wKCkuaGlkZSgpO1xuICB9LFxuXG4gIF9vblZhbHVlSG92ZXI6IGZ1bmN0aW9uKGluZm8pIHtcbiAgICB2YXIgJHRvb2x0aXAgPSB0aGlzLiQoXCIuanMtdG9vbHRpcFwiKTtcblxuICAgIGlmIChpbmZvICYmIGluZm8uZGF0YSkge1xuICAgICAgdmFyIGJvdHRvbSA9IHRoaXMuZGVmYXVsdHMuY2hhcnRIZWlnaHQgKyAzIC0gaW5mby50b3A7XG5cbiAgICAgICR0b29sdGlwLmNzcyh7IGJvdHRvbTogYm90dG9tLCBsZWZ0OiBpbmZvLmxlZnQgfSk7XG4gICAgICAkdG9vbHRpcC50ZXh0KGluZm8uZGF0YSk7XG4gICAgICAkdG9vbHRpcC5jc3MoeyBsZWZ0OiBpbmZvLmxlZnQgLSAkdG9vbHRpcC53aWR0aCgpLzIgfSk7XG4gICAgICAkdG9vbHRpcC5mYWRlSW4oNzApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jbGVhclRvb2x0aXAoKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uTWluaVJhbmdlVXBkYXRlZDogZnVuY3Rpb24obG9CYXJJbmRleCwgaGlCYXJJbmRleCkge1xuICAgIHRoaXMubG9ja2VkQnlVc2VyID0gZmFsc2U7XG4gICAgdGhpcy5sb2NrWm9vbWVkRGF0YSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fY2xlYXJUb29sdGlwKCk7XG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVtb3ZlU2VsZWN0aW9uKCk7XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMub3JpZ2luYWxEYXRhO1xuXG4gICAgaWYgKGxvQmFySW5kZXggPj0gMCAmJiBsb0JhckluZGV4IDwgZGF0YS5sZW5ndGggJiYgKGhpQmFySW5kZXggLSAxKSA+PSAwICYmIChoaUJhckluZGV4IC0gMSkgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5maWx0ZXIuc2V0UmFuZ2UoXG4gICAgICAgIGRhdGFbbG9CYXJJbmRleF0uc3RhcnQsXG4gICAgICAgIGRhdGFbaGlCYXJJbmRleCAtIDFdLmVuZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBhcnJheSBib3VuZHMnLCBsb0JhckluZGV4LCBoaUJhckluZGV4LCBkYXRhKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQnJ1c2hFbmQ6IGZ1bmN0aW9uKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2dldERhdGEoKTtcbiAgICBcbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgIHRoaXMubG9ja2VkQnlVc2VyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydGllcyA9IHsgZmlsdGVyX2VuYWJsZWQ6IHRydWUsIGxvX2luZGV4OiBsb0JhckluZGV4LCBoaV9pbmRleDogaGlCYXJJbmRleCB9O1xuXG4gICAgaWYgKCF0aGlzLnZpZXdNb2RlbC5nZXQoJ3pvb21lZCcpKSB7XG4gICAgICBwcm9wZXJ0aWVzLnpvb21fZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy52aWV3TW9kZWwuc2V0KHByb3BlcnRpZXMpO1xuXG4gICAgaWYgKGxvQmFySW5kZXggPj0gMCAmJiBsb0JhckluZGV4IDwgZGF0YS5sZW5ndGggJiYgKGhpQmFySW5kZXggLSAxKSA+PSAwICYmIChoaUJhckluZGV4IC0gMSkgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5maWx0ZXIuc2V0UmFuZ2UoXG4gICAgICAgIGRhdGFbbG9CYXJJbmRleF0uc3RhcnQsXG4gICAgICAgIGRhdGFbaGlCYXJJbmRleCAtIDFdLmVuZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBhcnJheSBib3VuZHMnLCBsb0JhckluZGV4LCBoaUJhckluZGV4LCBkYXRhKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uUmFuZ2VVcGRhdGVkOiBmdW5jdGlvbihsb0JhckluZGV4LCBoaUJhckluZGV4KSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMudmlld01vZGVsLmdldCgnem9vbWVkJykpIHtcbiAgICAgIHRoaXMudmlld01vZGVsLnNldCh7IHpvb21fZW5hYmxlZDogZmFsc2UsIGxvX2luZGV4OiBsb0JhckluZGV4LCBoaV9pbmRleDogaGlCYXJJbmRleCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52aWV3TW9kZWwuc2V0KHsgbG9faW5kZXg6IGxvQmFySW5kZXgsIGhpX2luZGV4OiBoaUJhckluZGV4IH0pO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVTdGF0cyA9IF8uZGVib3VuY2UoZnVuY3Rpb24oKSB7IHNlbGYuX3VwZGF0ZVN0YXRzKCk7IH0sIDQwMCk7XG4gICAgdXBkYXRlU3RhdHMoKTtcbiAgfSxcblxuICBfZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcblxuICAgIGlmICh0aGlzLl9pc1pvb21lZCgpKSB7XG4gICAgICBkYXRhID0gdGhpcy56b29tZWREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICBfb25DaGFuZ2VGaWx0ZXJFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoXCIuanMtZmlsdGVyXCIpLnRvZ2dsZUNsYXNzKCdpcy1oaWRkZW4nLCAhdGhpcy52aWV3TW9kZWwuZ2V0KCdmaWx0ZXJfZW5hYmxlZCcpKTtcbiAgfSxcblxuICBfb25DaGFuZ2Vab29tRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kKFwiLmpzLXpvb21cIikudG9nZ2xlQ2xhc3MoJ2lzLWhpZGRlbicsICF0aGlzLnZpZXdNb2RlbC5nZXQoJ3pvb21fZW5hYmxlZCcpKTtcbiAgfSxcblxuICBfY2hhbmdlSGVhZGVyVmFsdWU6IGZ1bmN0aW9uKGNsYXNzTmFtZSwgd2hhdCwgc3VmZml4KSB7XG4gICAgaWYgKHRoaXMudmlld01vZGVsLmdldCh3aGF0KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLiQoY2xhc3NOYW1lKS50ZXh0KCcwICcgKyBzdWZmaXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2FkZFRpdGxlRm9yVmFsdWUoY2xhc3NOYW1lLCB3aGF0LCBzdWZmaXgpO1xuXG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdGVWYWx1ZXMoe1xuICAgICAgZWw6IHRoaXMuJGVsXG4gICAgfSk7XG5cbiAgICBhbmltYXRvci5hbmltYXRlVmFsdWUodGhpcy52aWV3TW9kZWwsIHdoYXQsIGNsYXNzTmFtZSwgYW5pbWF0aW9uVGVtcGxhdGUsIHtcbiAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLmZvcm1hdE51bWJlcixcbiAgICAgIHRlbXBsYXRlRGF0YTogeyBzdWZmaXg6IFwiIFwiICsgc3VmZml4IH1cbiAgICB9KTtcbiAgfSxcblxuICBfb25DaGFuZ2VOdWxsczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlSGVhZGVyVmFsdWUoJy5qcy1udWxscycsICdudWxscycsICdOVUxMIFJPV1MnKTtcbiAgfSxcblxuICBfb25DaGFuZ2VUb3RhbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlSGVhZGVyVmFsdWUoJy5qcy12YWwnLCAndG90YWwnLCAnU0VMRUNURUQnKTtcbiAgfSxcblxuICBfb25DaGFuZ2VNYXg6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NoYW5nZUhlYWRlclZhbHVlKCcuanMtbWF4JywgJ21heCcsICdNQVgnKTtcbiAgfSxcblxuICBfb25DaGFuZ2VNaW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NoYW5nZUhlYWRlclZhbHVlKCcuanMtbWluJywgJ21pbicsICdNSU4nKTtcbiAgfSxcblxuICBfb25DaGFuZ2VBdmc6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NoYW5nZUhlYWRlclZhbHVlKCcuanMtYXZnJywgJ2F2ZycsICdBVkcnKTtcbiAgfSxcblxuICBfYWRkVGl0bGVGb3JWYWx1ZTogZnVuY3Rpb24oY2xhc3NOYW1lLCB3aGF0LCB1bml0KSB7XG4gICAgdGhpcy4kKGNsYXNzTmFtZSkuYXR0cigndGl0bGUnLCB0aGlzLl9mb3JtYXROdW1iZXJXaXRoQ29tbWFzKHRoaXMudmlld01vZGVsLmdldCh3aGF0KS50b0ZpeGVkKDIpKSArICcgJyArIHVuaXQpO1xuICB9LFxuXG4gIF9mb3JtYXROdW1iZXJXaXRoQ29tbWFzOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHgudG9TdHJpbmcoKS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBcIixcIik7XG4gIH0sXG5cbiAgX3VwZGF0ZVN0YXRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMub3JpZ2luYWxEYXRhO1xuXG4gICAgaWYgKHRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnpvb21lZERhdGE7XG4gICAgfVxuXG4gICAgdmFyIG51bGxzID0gdGhpcy5tb2RlbC5nZXQoJ251bGxzJyk7XG5cbiAgICB2YXIgbWluLCBtYXg7XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCkge1xuXG4gICAgICB2YXIgbG9CYXJJbmRleCA9IHRoaXMudmlld01vZGVsLmdldCgnbG9faW5kZXgnKSB8fCAwO1xuICAgICAgdmFyIGhpQmFySW5kZXggPSB0aGlzLnZpZXdNb2RlbC5nZXQoJ2hpX2luZGV4JykgfHwgZGF0YS5sZW5ndGg7XG5cbiAgICAgIHZhciBzdW0gPSB0aGlzLl9jYWxjU3VtKGRhdGEsIGxvQmFySW5kZXgsIGhpQmFySW5kZXgpO1xuICAgICAgdmFyIGF2ZyA9IHRoaXMuX2NhbGNBdmcoZGF0YSwgbG9CYXJJbmRleCwgaGlCYXJJbmRleCk7XG5cbiAgICAgIGlmIChsb0JhckluZGV4ID49IDAgJiYgbG9CYXJJbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIG1pbiA9IGRhdGFbbG9CYXJJbmRleF0uc3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChoaUJhckluZGV4ID49IDAgJiYgaGlCYXJJbmRleCAtIDEgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICBtYXggPSBkYXRhW2hpQmFySW5kZXggLSAxXS5lbmQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlld01vZGVsLnNldCh7IHRvdGFsOiBzdW0sIG51bGxzOiBudWxscywgbWluOiBtaW4sIG1heDogbWF4LCBhdmc6IGF2ZyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgX2NhbGNBdmc6IGZ1bmN0aW9uKGRhdGEsIHN0YXJ0LCBlbmQpIHtcblxuICAgIHZhciBzZWxlY3RlZERhdGEgPSBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgdmFyIHRvdGFsID0gdGhpcy5fY2FsY1N1bShkYXRhLCBzdGFydCwgZW5kLCB0b3RhbCk7XG5cbiAgICBpZiAoIXRvdGFsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgYXJlYSA9IF8ucmVkdWNlKHNlbGVjdGVkRGF0YSwgZnVuY3Rpb24obWVtbywgZCkge1xuICAgICAgcmV0dXJuIChkLmF2ZyAmJiBkLmZyZXEpID8gKGQuYXZnICogZC5mcmVxKSArIG1lbW8gOiBtZW1vO1xuICAgIH0sIDApO1xuXG4gICAgcmV0dXJuIGFyZWEgLyB0b3RhbDtcbiAgfSxcblxuICBfY2FsY1N1bTogZnVuY3Rpb24oZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBfLnJlZHVjZShkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpLCBmdW5jdGlvbihtZW1vLCBkKSB7XG4gICAgICByZXR1cm4gZC5mcmVxICsgbWVtbztcbiAgICB9LCAwKTtcbiAgfSxcblxuICBfb25DaGFuZ2Vab29tZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnZpZXdNb2RlbC5nZXQoJ3pvb21lZCcpKSB7XG4gICAgICB0aGlzLl9vblpvb21JbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vblpvb21PdXQoKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uWm9vbUluOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zaG93TWluaVJhbmdlKCk7XG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuZXhwYW5kKDIwKTtcblxuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LnJlbW92ZVNoYWRvd0JhcnMoKTtcblxuICAgIHRoaXMubW9kZWwuc2V0KHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCwgYmluczogbnVsbCwgb3duX2ZpbHRlcjogMSB9KTtcbiAgICB0aGlzLm1vZGVsLl9mZXRjaCgpO1xuICAgIHRoaXMubG9ja2VkQnlVc2VyID0gZmFsc2U7XG4gIH0sXG5cbiAgX3pvb206IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubG9ja2VkQnlVc2VyID0gdHJ1ZTtcbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQoeyB6b29tZWQ6IHRydWUsIHpvb21fZW5hYmxlZDogZmFsc2UgfSk7XG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVtb3ZlU2VsZWN0aW9uKCk7XG4gIH0sXG5cbiAgX29uWm9vbU91dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sb2NrZWRCeVVzZXIgICA9IHRydWU7XG4gICAgdGhpcy5sb2NrWm9vbWVkRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMudW5zZXR0aW5nUmFuZ2UgPSB0cnVlO1xuXG4gICAgdGhpcy5tb2RlbC5zZXQoeyBzdGFydDogdGhpcy5zdGFydCwgZW5kOiB0aGlzLmVuZCwgYmluczogdGhpcy5iaW5zQ291bnQsIG93bl9maWx0ZXI6IG51bGwgfSk7XG5cbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQoeyB6b29tX2VuYWJsZWQ6IGZhbHNlLCBmaWx0ZXJfZW5hYmxlZDogZmFsc2UsIGxvX2luZGV4OiBudWxsLCBoaV9pbmRleDogbnVsbCB9KTtcblxuICAgIHRoaXMuZmlsdGVyLnVuc2V0UmFuZ2UoKTtcblxuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LmNvbnRyYWN0KHRoaXMuZGVmYXVsdHMuY2hhcnRIZWlnaHQpO1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LnJlc2V0SW5kZXhlcygpO1xuXG4gICAgdGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3LmhpZGUoKTtcbiAgfSxcblxuICBfc2hvd01pbmlSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcblxuICAgIHZhciBsb0JhckluZGV4ID0gdGhpcy52aWV3TW9kZWwuZ2V0KCdsb19pbmRleCcpO1xuICAgIHZhciBoaUJhckluZGV4ID0gdGhpcy52aWV3TW9kZWwuZ2V0KCdoaV9pbmRleCcpO1xuXG4gICAgdGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3LnNlbGVjdFJhbmdlKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpO1xuICAgIHRoaXMubWluaUhpc3RvZ3JhbUNoYXJ0Vmlldy5zaG93KCk7XG4gIH0sXG5cbiAgX2NsZWFyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZW1vdmVTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQoeyB6b29tZWQ6IGZhbHNlLCB6b29tX2VuYWJsZWQ6IGZhbHNlIH0pO1xuICAgIHRoaXMudmlld01vZGVsLnRyaWdnZXIoJ2NoYW5nZTp6b29tZWQnKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWhlYWRlclwiPiA8ZGl2IGNsYXNzPVwianMtdGl0bGVcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGl0bGUgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxoMyBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZ1wiPicrXG4oKF9fdD0oIHRpdGxlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvaDM+IDwvZGl2PiA8L2Rpdj4gPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXJcIj4gPGR0IGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvSXRlbSBqcy1udWxsc1wiPjAgTlVMTCBST1dTPC9kdD4gPGR0IGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvSXRlbSBqcy1taW5cIj4wIE1JTjwvZHQ+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW0ganMtYXZnXCI+MCBBVkc8L2R0PiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIGpzLW1heFwiPjAgTUFYPC9kdD4gPC9kbD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnQganMtY29udGVudFwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC10b29sdGlwIGpzLXRvb2x0aXBcIj48L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtZmlsdGVyIENEQi1XaWRnZXQtY29udGVudFNwYWNlZCBqcy1maWx0ZXIgaXMtaGlkZGVuXCI+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1ib2xkIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLXVwcGVyIGpzLXZhbFwiPjwvcD4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtZmlsdGVyQnV0dG9uc1wiPiA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1saW5rIENEQi1XaWRnZXQtZmlsdGVyQnV0dG9uIGpzLXpvb21cIj56b29tPC9idXR0b24+IDxidXR0b24gY2xhc3M9XCJDREItV2lkZ2V0LWxpbmsgQ0RCLVdpZGdldC1maWx0ZXJCdXR0b24ganMtY2xlYXJcIj5jbGVhcjwvYnV0dG9uPiA8L2Rpdj4gPC9kaXY+IDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCIgdGl0bGU9XCInK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2gzPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1vcHRpb25zIENEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPiA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1idXR0b25JY29uIENEQi1XaWRnZXQtYnV0dG9uSWNvbi0tY2lyY2xlIGpzLXNpemVzICcrXG4oKF9fdD0oIGlzU2l6ZXNBcHBsaWVkID8gJ2lzLXNlbGVjdGVkJyA6ICcnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyAnK1xuKChfX3Q9KCBpc1NpemVzQXBwbGllZCA/ICdqcy1jYW5jZWxTaXplcycgOiAnanMtYXBwbHlTaXplcycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCIgZGF0YS10b29sdGlwPVwiJytcbigoX190PSggaXNTaXplc0FwcGxpZWQgPyAnUmVtb3ZlIHNpemVzJyA6ICdBcHBseSBzaXplcycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxpIGNsYXNzPVwiQ0RCLUljb24gQ0RCLUljb24tc3lyaW5nZSBDREItSWNvbi0tdG9wXCI+PC9pPiA8L2J1dHRvbj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1TaGFwZS10aHJlZVBvaW50cyBqcy1jb2xsYXBzZVwiIGRhdGEtdG9vbHRpcD1cIicrXG4oKF9fdD0oIGlzQ29sbGFwc2VkID8gJ1Nob3cnIDogJ0hpZGUnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiA8c3BhbiBjbGFzcz1cIkNEQi1TaGFwZS10aHJlZVBvaW50c0l0ZW1cIj48L3NwYW4+IDwvYnV0dG9uPiA8L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyICQgPSBjZGIuJDtcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBUb29sdGlwVmlldyA9IHJlcXVpcmUoJy4uL3dpZGdldC10b29sdGlwLXZpZXcnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaGlzdG9ncmFtX3RpdGxlX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqICBTaG93IHRpdGxlICsgc2hvdyBpZiBoaXN0b2dyYW0gc2l6ZXMgYXJlIGFwcGxpZWQgb3Igbm90XG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtdGl0bGUgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLWFwcGx5U2l6ZXMnOiAnX2FwcGx5U2l6ZXMnLFxuICAgICdjbGljayAuanMtY2FuY2VsU2l6ZXMnOiAnX2NhbmNlbFNpemVzJyxcbiAgICAnY2xpY2sgLmpzLWNvbGxhcHNlJzogJ190b2dnbGVDb2xsYXBzZSdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICB0aXRsZTogdGhpcy5kYXRhTW9kZWwuZ2V0KCd0aXRsZScpLFxuICAgICAgICBpc1NpemVzQXBwbGllZDogdGhpcy5kYXRhTW9kZWwuZ2V0KCdoaXN0b2dyYW1TaXplcycpLFxuICAgICAgICBpc0NvbGxhcHNlZDogdGhpcy5kYXRhTW9kZWwuaXNDb2xsYXBzZWQoKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuX2luaXRWaWV3cygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuYmluZCgnY2hhbmdlOmhpc3RvZ3JhbVNpemVzIGNoYW5nZTpjb2xsYXBzZWQnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLmRhdGFNb2RlbCk7XG4gIH0sXG5cbiAgX2luaXRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNpemVzVG9vbHRpcCA9IG5ldyBUb29sdGlwVmlldyh7XG4gICAgICB0YXJnZXQ6IHRoaXMuJCgnLmpzLXNpemVzJylcbiAgICB9KTtcbiAgICAkKCdib2R5JykuYXBwZW5kKHNpemVzVG9vbHRpcC5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHNpemVzVG9vbHRpcCk7XG5cbiAgICB2YXIgY29sbGFwc2VUb29sdGlwID0gbmV3IFRvb2x0aXBWaWV3KHtcbiAgICAgIHRhcmdldDogdGhpcy4kKCcuanMtY29sbGFwc2UnKVxuICAgIH0pO1xuICAgICQoJ2JvZHknKS5hcHBlbmQoY29sbGFwc2VUb29sdGlwLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoY29sbGFwc2VUb29sdGlwKTtcbiAgfSxcblxuICBfYXBwbHlTaXplczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuc2V0KCdoaXN0b2dyYW1TaXplcycsIHRydWUpO1xuICB9LFxuXG4gIF9jYW5jZWxTaXplczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuc2V0KCdoaXN0b2dyYW1TaXplcycsIGZhbHNlKTtcbiAgfSxcblxuICBfdG9nZ2xlQ29sbGFwc2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLnRvZ2dsZUNvbGxhcHNlZCgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBXaWRnZXRNb2RlbCA9IHJlcXVpcmUoJy4uL3dpZGdldF9tb2RlbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldE1vZGVsLmV4dGVuZCh7XG5cbiAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICBpZiAodGhpcy5nZXQoJ2NvbHVtblR5cGUnKSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2NvbHVtbl90eXBlPScgKyB0aGlzLmdldCgnY29sdW1uVHlwZScpKTtcbiAgICB9XG4gICAgaWYgKF8uaXNOdW1iZXIodGhpcy5nZXQoJ3N0YXJ0JykpKSB7XG4gICAgICBwYXJhbXMucHVzaCgnc3RhcnQ9JyArIHRoaXMuZ2V0KCdzdGFydCcpKTtcbiAgICB9XG4gICAgaWYgKF8uaXNOdW1iZXIodGhpcy5nZXQoJ2VuZCcpKSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2VuZD0nICsgdGhpcy5nZXQoJ2VuZCcpKTtcbiAgICB9XG4gICAgaWYgKF8uaXNOdW1iZXIodGhpcy5nZXQoJ2JpbnMnKSkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdiaW5zPScgKyB0aGlzLmdldCgnYmlucycpKTtcbiAgICB9XG4gICAgaWYgKF8uaXNOdW1iZXIodGhpcy5nZXQoJ293bl9maWx0ZXInKSkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdvd25fZmlsdGVyPScgKyB0aGlzLmdldCgnb3duX2ZpbHRlcicpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpICYmIHRoaXMuZ2V0KCdzdWJtaXRCQm94JykpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdiYm94PScgKyB0aGlzLmdldCgnYm91bmRpbmdCb3gnKSk7XG4gICAgfVxuXG4gICAgdmFyIHVybCA9IHRoaXMuZ2V0KCd1cmwnKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXJsICs9ICc/JyArIHBhcmFtcy5qb2luKCcmJyk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdHMpIHtcbiAgICBXaWRnZXRNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuX2RhdGEgPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbih0aGlzLmdldCgnZGF0YScpKTtcblxuICAgIC8vIEJCb3ggc2hvdWxkIG9ubHkgYmUgaW5jbHVkZWQgdW50aWwgYWZ0ZXIgdGhlIGZpcnN0IGZldGNoLCBzaW5jZSB3ZSB3YW50IHRvIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIGZ1bGwgZGF0YXNldFxuICAgIHRoaXMub25jZSgnY2hhbmdlOmRhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0KCdzdWJtaXRCQm94JywgdHJ1ZSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmxheWVyLmJpbmQoJ2NoYW5nZTptZXRhJywgdGhpcy5fb25DaGFuZ2VMYXllck1ldGEsIHRoaXMpO1xuICB9LFxuXG4gIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnRvSlNPTigpO1xuICB9LFxuXG4gIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnNpemUoKTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBudW1iZXJPZkJpbnMgPSBkYXRhLmJpbnNfY291bnQ7XG4gICAgdmFyIHdpZHRoID0gZGF0YS5iaW5fd2lkdGg7XG4gICAgdmFyIG51bGxzID0gZGF0YS5udWxsc19jb3VudDtcbiAgICB2YXIgc3RhcnQgPSBkYXRhLmJpbnNfc3RhcnQ7XG5cbiAgICB2YXIgYnVja2V0cyA9IG5ldyBBcnJheShudW1iZXJPZkJpbnMpO1xuXG4gICAgXy5lYWNoKGRhdGEuYmlucywgZnVuY3Rpb24oYikge1xuICAgICAgYnVja2V0c1tiLmJpbl0gPSBiO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZkJpbnM7IGkrKykge1xuICAgICAgYnVja2V0c1tpXSA9IF8uZXh0ZW5kKHtcbiAgICAgICAgYmluOiBpLFxuICAgICAgICBzdGFydDogc3RhcnQgKyAoaSAqIHdpZHRoKSxcbiAgICAgICAgZW5kOiBzdGFydCArICgoaSArIDEpICogd2lkdGgpLFxuICAgICAgICBmcmVxOiAwXG4gICAgICB9LCBidWNrZXRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhLnJlc2V0KGJ1Y2tldHMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGJ1Y2tldHMsXG4gICAgICBudWxsczogZGF0YS5udWxsc1xuICAgIH07XG4gIH0sXG5cbiAgLy8gc2V0IGJpbnMgZm9yIHRoZSBoaXN0b2dyYW1zXG4gIC8vIEBiaW5zIHNob3VsZCBiZSBhbiBhcnJheSB3aXRoIHRoZSBmb3JtYXQgW3sgc3RhcnQ6IC4uLiwgZW5kOiAuLi4sIGZyZXE6IC4uLiwgbWluOiAuLi4sIG1heDogICB9LCAuLi5dXG4gIC8vICAgIC0gc3RhcnQsIGVuZDogYXJlIHRoZSBidWNrZXQgYm91bmRzXG4gIC8vICAgIC0gbWluLCBtYXg6IHRoZSBtaW4gYW5kIHRoZSBtYXggdmFsdWUgZm9yIGFsbCB0aGUgcG9pbnRzIGluIHRoYXQgYnVja2V0XG4gIC8vICAgIC0gZnJlcTogY291bnRcbiAgc2V0QmluczogZnVuY3Rpb24oYmlucywgb3B0aW9ucykge1xuICAgIHRoaXMuX2RhdGEucmVzZXQoYmlucywgb3B0aW9ucyk7XG4gICAgdGhpcy5zZXQoJ2RhdGEnLCB7IGJpbnM6IGJpbnMgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaGlzdG9ncmFtXCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNvbHVtbjogdGhpcy5nZXQoJ2NvbHVtbicpLFxuICAgICAgICBiaW5zOiB0aGlzLmdldCgnYmlucycpXG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBfb25DaGFuZ2VMYXllck1ldGE6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZmlsdGVyLnNldCgnY29sdW1uVHlwZScsIHRoaXMubGF5ZXIuZ2V0KCdtZXRhJykuY29sdW1uX3R5cGUpO1xuICB9LFxuXG4gIF9vbkNoYW5nZUJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICBXaWRnZXRNb2RlbC5wcm90b3R5cGUuX29uQ2hhbmdlQmluZHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTpoaXN0b2dyYW1TaXplcycsIGZ1bmN0aW9uKG1kbCwgaXNTaXplc0FwcGxpZWQsIGQpIHtcbiAgICAgIGlmIChpc1NpemVzQXBwbGllZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpc3RvZ3JhbVNpemVzJywgdGhpcyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8dWwgY2xhc3M9XCJDREItV2lkZ2V0LWNoYXJ0IENEQi1XaWRnZXQtY2hhcnQtLWZha2VcIj4gJztcbiBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpKyspIHsgXG5fX3ArPScgPGxpIGNsYXNzPVwiQ0RCLVdpZGdldC1jaGFydEl0ZW0gQ0RCLVdpZGdldC1jaGFydEl0ZW0tLScrXG4oKF9fdD0oIF8uc2FtcGxlKFsnc21hbGwnLCAnbWVkaXVtJywgJ2JpZyddLCAxKVswXSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgV2lkZ2V0LWNoYXJ0SXRlbS0tZmFrZVwiPjwvbGk+ICc7XG4gfSBcbl9fcCs9JyA8L3VsPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtaGVhZGVyXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRpdGxlIENEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPiA8aDMgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRCaWdcIiB0aXRsZT1cIicrXG4oKF9fdD0oIHRpdGxlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIHRpdGxlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvaDM+IDwvZGl2PiA8ZGwgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9cIj4gPGR0IGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvSXRlbSBDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLXVwcGVyXCI+JytcbigoX190PSggaXRlbXNDb3VudCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgcm93czwvZHQ+IDwvZGw+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50IENEQi1XaWRnZXQtY29udGVudC0tbm9TaWRlc01hcmdpblwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0V3JhcHBlciBqcy1jb250ZW50XCI+PC9kaXY+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1mb290ZXIganMtZm9vdGVyXCI+PC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBmb3JtYXQgPSBjZGIuY29yZS5mb3JtYXQ7XG52YXIgV2lkZ2V0Q29udGVudFZpZXcgPSByZXF1aXJlKCcuLi9zdGFuZGFyZC93aWRnZXRfY29udGVudF92aWV3Jyk7XG52YXIgV2lkZ2V0TGlzdEl0ZW1zVmlldyA9IHJlcXVpcmUoJy4vaXRlbXNfdmlldycpO1xudmFyIFdpZGdldExpc3RQYWdpbmF0b3JWaWV3ID0gcmVxdWlyZSgnLi9wYWdpbmF0b3JfdmlldycpO1xudmFyIFdpZGdldExpc3RFZGdlc1ZpZXcgPSByZXF1aXJlKCcuL2VkZ2VzX3ZpZXcnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vY29udGVudF90ZW1wbGF0ZS50cGwnKTtcbnZhciB0ZW1wbGF0ZVBsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9wbGFjZWhvbGRlcl90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBEZWZhdWx0IHdpZGdldCBjb250ZW50IHZpZXc6XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0Q29udGVudFZpZXcuZXh0ZW5kKHtcblxuICBvcHRpb25zOiB7XG4gICAgc2hvd1Njcm9sbDogZmFsc2VcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICB0aXRsZTogdGhpcy5tb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIGl0ZW1zQ291bnQ6ICFpc0RhdGFFbXB0eSA/IGZvcm1hdC5mb3JtYXRWYWx1ZShkYXRhLmxlbmd0aCkgOiAnLSdcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGlmIChpc0RhdGFFbXB0eSkge1xuICAgICAgdGhpcy5fYWRkUGxhY2Vob2xkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5pdFZpZXdzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5tb2RlbC5nZXRTaXplKCk7XG5cbiAgICAvLyBMaXN0IHZpZXcgLT4gaXRlbXMgdmlld1xuICAgIHRoaXMuX2xpc3QgPSBuZXcgV2lkZ2V0TGlzdEl0ZW1zVmlldyh7XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuJCgnLmpzLWNvbnRlbnQnKS5odG1sKHRoaXMuX2xpc3QucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyh0aGlzLl9saXN0KTtcblxuICAgIHZhciBpc1Njcm9sbExpc3QgPSAodGhpcy5fbGlzdC4kZWwuZ2V0KDApLnNjcm9sbEhlaWdodCAtIHRoaXMuX2xpc3QuJGVsLm91dGVySGVpZ2h0KCkpID4gMDtcblxuICAgIGlmIChpc1Njcm9sbExpc3QgfHzCoHRoaXMub3B0aW9ucy5zaG93U2Nyb2xsKSB7XG4gICAgICAvLyBQYWdpbmF0b3JcbiAgICAgIHRoaXMuX3BhZ2luYXRpb24gPSBuZXcgV2lkZ2V0TGlzdFBhZ2luYXRvclZpZXcoe1xuICAgICAgICAkdGFyZ2V0OiB0aGlzLl9saXN0LiRlbFxuICAgICAgfSk7XG4gICAgICB0aGlzLiQoJy5qcy1mb290ZXInKS5hcHBlbmQodGhpcy5fcGFnaW5hdGlvbi5yZW5kZXIoKS5lbCk7XG4gICAgICB0aGlzLmFkZFZpZXcodGhpcy5fcGFnaW5hdGlvbik7XG5cbiAgICAgIC8vIEVkZ2VzXG4gICAgICB0aGlzLl9lZGdlcyA9IG5ldyBXaWRnZXRMaXN0RWRnZXNWaWV3KHtcbiAgICAgICAgJHRhcmdldDogdGhpcy5fbGlzdC4kZWxcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kKCcuanMtY29udGVudCcpLmFwcGVuZCh0aGlzLl9lZGdlcy5yZW5kZXIoKS5lbCk7XG4gICAgICB0aGlzLmFkZFZpZXcodGhpcy5fZWRnZXMpO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG5cbi8qKlxuICogIExpc3QgZWRnZXMgdmlldzpcbiAqXG4gKiAgLSBJdCBzaG93cyB0aGUgYm9yZGVycyBhbmQgdGhlIHNoYWRvd3MsIGlmIG5lZWRlZC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgX1RFTVBMQVRFOiAnICcgK1xuICAgICc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0RWRnZSBDREItV2lkZ2V0LWxpc3RFZGdlLS10b3BcIj4nK1xuICAgICAgJzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RFZGdlU2hhZG93IGpzLXRvcFNoYWRvd1wiPjwvZGl2PicrXG4gICAgICAnPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEVkZ2VCb3JkZXJcIj48L2Rpdj4nK1xuICAgICc8L2Rpdj4nK1xuICAgICc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0RWRnZSBDREItV2lkZ2V0LWxpc3RFZGdlLS1ib3R0b21cIj4nK1xuICAgICAgJzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RFZGdlU2hhZG93IGpzLWJvdHRvbVNoYWRvd1wiPjwvZGl2PicrXG4gICAgICAnPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEVkZ2VCb3JkZXJcIj48L2Rpdj4nK1xuICAgICc8L2Rpdj4nLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuXyR0YXJnZXQgPSB0aGlzLm9wdGlvbnMuJHRhcmdldDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUodGhpcy5fVEVNUExBVEUpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoKSk7XG4gICAgdGhpcy5fY2hlY2tTY3JvbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fJHRhcmdldC5iaW5kKCdzY3JvbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2NoZWNrU2Nyb2xsKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX3VuYmluZFNjcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fJHRhcmdldC51bmJpbmQoJ3Njcm9sbCcpO1xuICB9LFxuXG4gIF9jaGVja1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRTY3JvbGwgPSB0aGlzLl8kdGFyZ2V0LnNjcm9sbFRvcCgpO1xuICAgIHZhciBtYXhTY3JvbGwgPSB0aGlzLl8kdGFyZ2V0LmdldCgwKS5zY3JvbGxIZWlnaHQgLSB0aGlzLl8kdGFyZ2V0Lm91dGVySGVpZ2h0KCk7XG4gICAgdGhpcy4kKCcuanMtdG9wU2hhZG93JykudG9nZ2xlKGN1cnJlbnRTY3JvbGwgIT09IDApO1xuICAgIHRoaXMuJCgnLmpzLWJvdHRvbVNoYWRvdycpLnRvZ2dsZShjdXJyZW50U2Nyb2xsICE9PSBtYXhTY3JvbGwpO1xuICB9LFxuXG4gIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bmJpbmRTY3JvbGwoKTtcbiAgICBWaWV3LnByb3RvdHlwZS5jbGVhbi5jYWxsKHRoaXMpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPScnO1xuIGlmIChpc0NsaWNrYWJsZSkgeyBcbl9fcCs9JyA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1Jbm5lciBDREItV2lkZ2V0LWxpc3RCdXR0b24gQ0RCLVdpZGdldC1saXN0QnV0dG9uLS13aXRoQm9yZGVyIGpzLWJ1dHRvblwiPiAnO1xuIH0gZWxzZSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtSW5uZXIgQ0RCLVdpZGdldC1saXN0SXRlbUlubmVyLS13aXRoQm9yZGVyc1wiPiAnO1xuIH0gXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudFNwYWNlZCBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQtLXRvcEFsaWduZWQgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkLS1zdGFydFwiPiA8ZW0gY2xhc3M9XCJDREItU2hhcGUtZG90IENEQi1XaWRnZXQtbGlzdERvdFwiPjwvZW0+ICc7XG4gaWYgKGl0ZW1zQ291bnQgPiAwKSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnRGdWxsXCI+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGwgQ0RCLVdpZGdldC10ZXh0U21hbGwtLXVwcGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsLS1ib2xkXCIgdGl0bGU9XCInK1xuKChfX3Q9KCBpdGVtc1swXVsxXSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBpdGVtc1swXVsxXSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+ICc7XG4gaWYgKGl0ZW1zQ291bnQgPiAyKSB7IFxuX19wKz0nIDxkbCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5saW5lTGlzdFwiPiAnO1xuIGZvciAodmFyIGkgPSAxLCBsID0gaXRlbXNDb3VudDsgaSA8IGw7IGkrKykgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1pbmxpbmVMaXN0SXRlbSBDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLW5vRWxsaXBcIj4gPGRkIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tYm9sZCBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1kYXJrIHUtclNwYWNlXCIgdGl0bGU9XCInK1xuKChfX3Q9KCBpdGVtc1tpXVsxXSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBpdGVtc1tpXVsxXSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2RkPiA8ZHQgdGl0bGU9XCInK1xuKChfX3Q9KCBpdGVtc1tpXVswXSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBpdGVtc1tpXVswXSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2R0PiA8L2Rpdj4gJztcbiB9IFxuX19wKz0nIDwvZGw+ICc7XG4gfSBlbHNlIGlmIChpdGVtc0NvdW50ID09PSAyKSB7IFxuX19wKz0nIDxkbCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tbm9FbGxpcCB1LXRTcGFjZVwiPiA8ZGQgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1ib2xkIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWRhcmsgdS1yU3BhY2VcIiB0aXRsZT1cIicrXG4oKF9fdD0oIGl0ZW1zWzFdWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIGl0ZW1zWzFdWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvZGQ+IDxkdCB0aXRsZT1cIicrXG4oKF9fdD0oIGl0ZW1zWzFdWzBdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIGl0ZW1zWzFdWzBdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvZHQ+IDwvZGw+ICc7XG4gfSBcbl9fcCs9JyA8L2Rpdj4gJztcbiB9IFxuX19wKz0nIDwvZGl2PiAnO1xuIGlmIChpc0NsaWNrYWJsZSkgeyBcbl9fcCs9JyA8L2Rpdj48L2J1dHRvbj4gJztcbiB9IGVsc2UgeyBcbl9fcCs9JyAgJztcbiB9IFxuX19wKz0nJztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBmb3JtYXQgPSBjZGIuY29yZS5mb3JtYXQ7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2l0ZW1fdGVtcGxhdGUudHBsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIHRhZ05hbWU6ICdsaScsXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbGlzdEl0ZW0nLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtYnV0dG9uJzogJ19vbkl0ZW1DbGljaydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMub3B0aW9ucy52aWV3TW9kZWw7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwudG9KU09OKCk7XG4gICAgdmFyIGhhc0ludGVyYWN0aXZpdHkgPSB0aGlzLl9oYXNJbnRlcmFjdGl2aXR5KGRhdGEpO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX3Nhbml0aXplRGF0YShkYXRhKTtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgICAgaXNDbGlja2FibGU6IGhhc0ludGVyYWN0aXZpdHksXG4gICAgICAgIGl0ZW1zQ291bnQ6IF8uc2l6ZShpdGVtcylcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGNhcnRvZGJfaWQgZGVmaW5lZCwgY2xpY2sgZXZlbnQgc2hvdWxkXG4gICAgLy8gYmUgZGlzYWJsZWRcbiAgICB0aGlzWyBoYXNJbnRlcmFjdGl2aXR5ID8gJ2RlbGVnYXRlRXZlbnRzJyA6ICd1bmRlbGVnYXRlRXZlbnRzJyBdKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gUmVtb3ZlIGNhcnRvZGJfaWQsIGlmIGV4aXN0c1xuICAvLyBSZXBsYWNlIHRpdGxlcyBpZiB0aGVyZSBhcmUgYWx0ZXJuYXRpdmVzXG4gIC8vIENvbnZlcnQgZGF0YSBvYmplY3QgdG8gYXJyYXkgaXRlbXNcbiAgX3Nhbml0aXplRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBoYXNJbnRlcmFjdGl2aXR5ID0gdGhpcy5faGFzSW50ZXJhY3Rpdml0eShkYXRhKTtcbiAgICB2YXIgZGF0YSA9IF8ub21pdChkYXRhLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBrZXkgPT09ICdjYXJ0b2RiX2lkJztcbiAgICB9KTtcblxuICAgIHZhciBjb2x1bW5UaXRsZXMgPSB0aGlzLnZpZXdNb2RlbC5nZXQoJ2NvbHVtbnNfdGl0bGUnKTtcbiAgICBpZiAoaGFzSW50ZXJhY3Rpdml0eSAmJiAhXy5pc0VtcHR5KGNvbHVtblRpdGxlcykpIHtcbiAgICAgIGNvbHVtblRpdGxlcyA9IF8ucmVzdChjb2x1bW5UaXRsZXMsIDEpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdG8gcGFpciBpdGVtcyBhbmQgY2hlY2sgaWYgdGhlcmUgaXMgYSBjb2x1bW4gdGl0bGVcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhciB0aXRsZSA9IGNvbHVtblRpdGxlcyAmJiBjb2x1bW5UaXRsZXNbaV0gfHwga2V5O1xuICAgICAgYXJyLnB1c2goWyB0aXRsZSwgZm9ybWF0LmZvcm1hdFZhbHVlKHZhbHVlKSBdKTtcbiAgICAgICsraTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhcnI7XG4gIH0sXG5cbiAgX2hhc0ludGVyYWN0aXZpdHk6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gIV8uaXNFbXB0eShcbiAgICAgIF8uZmlsdGVyKGRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuICAgICAgICByZXR1cm4ga2V5ID09PSAnY2FydG9kYl9pZCdcbiAgICAgIH0pXG4gICAgKVxuICB9LFxuXG4gIF9vbkl0ZW1DbGljazogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdpdGVtQ2xpY2tlZCcsIHRoaXMubW9kZWwsIHRoaXMpO1xuICB9XG5cbn0pO1xuIiwidmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIFdpZGdldExpc3RJdGVtVmlldyA9IHJlcXVpcmUoJy4vaXRlbV92aWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbGlzdCBqcy1saXN0JyxcbiAgdGFnTmFtZTogJ3VsJyxcblxuICBldmVudHM6IHtcbiAgICAnc2Nyb2xsJzogJ19jaGVja1Njcm9sbCdcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuX3JlbmRlckxpc3QoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfcmVuZGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5nZXREYXRhKCkuZWFjaCh0aGlzLl9hZGRJdGVtLCB0aGlzKTtcbiAgfSxcblxuICBfYWRkSXRlbTogZnVuY3Rpb24obWRsKSB7XG4gICAgdmFyIHYgPSBuZXcgV2lkZ2V0TGlzdEl0ZW1WaWV3KHtcbiAgICAgIG1vZGVsOiBtZGwsXG4gICAgICB2aWV3TW9kZWw6IHRoaXMubW9kZWxcbiAgICB9KTtcbiAgICB2LmJpbmQoJ2l0ZW1DbGlja2VkJywgZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMudHJpZ2dlcignaXRlbUNsaWNrZWQnLCBtZGwsIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuYWRkVmlldyh2KTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodi5yZW5kZXIoKS5lbCk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgV2lkZ2V0TW9kZWwgPSByZXF1aXJlKCcuLi93aWRnZXRfbW9kZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRNb2RlbC5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICBwYWdlOiAwLFxuICAgIHBlcl9wYWdlOiAxMDBcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0cykge1xuICAgIHRoaXMuX2RhdGEgPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbih0aGlzLmdldCgnZGF0YScpKTtcbiAgICBXaWRnZXRNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRzKTtcbiAgfSxcblxuICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcblxuICBnZXRTaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zaXplKCk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgcm93cyA9IGRhdGEucm93cztcbiAgICB0aGlzLl9kYXRhLnJlc2V0KHJvd3MpO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiByb3dzXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxpc3RcIixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY29sdW1uczogdGhpcy5nZXQoJ2NvbHVtbnMnKVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1uYXYgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkJyxcblxuICBfVEVNUExBVEU6ICcgJyArXG4gICAgJzxzcGFuPjwvc3Bhbj4nICtcbiAgICAnPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbmF2QXJyb3dzIENEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPicrXG4gICAgICAnPGJ1dHRvbiBjbGFzcz1cIkNEQi1TaGFwZS1hcnJvdyBDREItU2hhcGUtYXJyb3ctLXVwIGpzLXVwXCI+PC9idXR0b24+JytcbiAgICAgICc8YnV0dG9uIGNsYXNzPVwiQ0RCLVNoYXBlLWFycm93IENEQi1TaGFwZS1hcnJvdy0tZG93biBqcy1kb3duXCI+PC9idXR0b24+JytcbiAgICAnPC9kaXY+JyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLXVwJzogJ19zY3JvbGxVcCcsXG4gICAgJ2NsaWNrIC5qcy1kb3duJzogJ19zY3JvbGxEb3duJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLiR0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IHNob3VsZCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gcGFnaW5hdGUnKTtcbiAgICB9XG4gICAgdGhpcy5fJHRhcmdldCA9IHRoaXMub3B0aW9ucy4kdGFyZ2V0O1xuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuXyR0YXJnZXQuZ2V0KDApLnNjcm9sbEhlaWdodCAtIHRoaXMuXyR0YXJnZXQub3V0ZXJIZWlnaHQoKTtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUodGhpcy5fVEVNUExBVEUpO1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoKSk7XG4gICAgdGhpcy5fY2hlY2tTY3JvbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fJHRhcmdldC5iaW5kKCdzY3JvbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2NoZWNrU2Nyb2xsKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX3VuYmluZFNjcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fJHRhcmdldC51bmJpbmQoJ3Njcm9sbCcpO1xuICB9LFxuXG4gIF9jaGVja1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRTY3JvbGwgPSB0aGlzLl8kdGFyZ2V0LnNjcm9sbFRvcCgpO1xuICAgIHRoaXMuJCgnLmpzLXVwJykudG9nZ2xlQ2xhc3MoJ2lzLWRpc2FibGVkJywgY3VycmVudFNjcm9sbCA9PT0gMCk7XG4gICAgdGhpcy4kKCcuanMtZG93bicpLnRvZ2dsZUNsYXNzKCdpcy1kaXNhYmxlZCcsIGN1cnJlbnRTY3JvbGwgPj0gdGhpcy5fc2Nyb2xsSGVpZ2h0KTtcbiAgfSxcblxuICBfZ2V0RWRnZVZpc2libGVJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWFIZWlnaHQgPSB0aGlzLl8kdGFyZ2V0Lm91dGVySGVpZ2h0KCk7XG4gICAgdmFyIGZpcnN0RWwgPSBudWxsO1xuICAgIHZhciBsYXN0RWwgPSBudWxsO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuXyR0YXJnZXQuY2hpbGRyZW4oJy5DREItV2lkZ2V0LWxpc3RJdGVtJyk7XG5cbiAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIHRvcCA9ICQodGhpcykucG9zaXRpb24oKS50b3A7XG4gICAgICB2YXIgaGVpZ2h0ID0gJCh0aGlzKS5vdXRlckhlaWdodCgpO1xuXG4gICAgICBpZiAodG9wID4gLTEgJiYgZmlyc3RFbCA9PT0gbnVsbCl7IC8vZmlyc3QgZW50aXJlbHkgdmlzaWJsZSBlbGVtZW50XG4gICAgICAgIGZpcnN0RWwgPSB0aGlzO1xuICAgICAgfSBlbHNlIGlmICgodG9wICsgaGVpZ2h0KSA+IGFyZWFIZWlnaHQgJiYgbGFzdEVsID09PSBudWxsKXtcbiAgICAgICAgbGFzdEVsID0gaXRlbXNbaW5kZXgtMV07Ly90aGUgbGFzdCBlbnRpcmVseSB2aXNpYmxlIHdhcyB0aGUgZWxlbWVudCBiZWZvcmVcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBbZmlyc3RFbCxsYXN0RWxdO1xuICB9LFxuXG4gIF9zY3JvbGxEb3duOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGFzdFZpc2libGVJdGVtID0gdGhpcy5fZ2V0RWRnZVZpc2libGVJdGVtcygpWzFdO1xuICAgIHZhciBjdXJyZW50U2Nyb2xsID0gdGhpcy5fJHRhcmdldC5zY3JvbGxUb3AoKTtcbiAgICB2YXIgJG5leHQgPSAkKGxhc3RWaXNpYmxlSXRlbSkubmV4dCgpO1xuICAgIGlmICgkbmV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciB0b3AgPSAkbmV4dC5wb3NpdGlvbigpLnRvcDtcbiAgICAgIHZhciBoZWlnaHQgPSAkbmV4dC5vdXRlckhlaWdodCgpO1xuICAgICAgdmFyIHNjcm9sbFBvcyA9IHRvcCArIGhlaWdodCAtIHRoaXMuXyR0YXJnZXQub3V0ZXJIZWlnaHQoKSArIGN1cnJlbnRTY3JvbGw7XG4gICAgICBpZiAoc2Nyb2xsUG9zID4gMCkge1xuICAgICAgICB0aGlzLl8kdGFyZ2V0LnNjcm9sbFRvcChzY3JvbGxQb3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfc2Nyb2xsVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmaXJzdFZpc2libGVJdGVtID0gdGhpcy5fZ2V0RWRnZVZpc2libGVJdGVtcygpWzBdO1xuICAgIHZhciBjdXJyZW50U2Nyb2xsID0gdGhpcy5fJHRhcmdldC5zY3JvbGxUb3AoKTtcbiAgICB2YXIgJHByZXYgPSAkKGZpcnN0VmlzaWJsZUl0ZW0pLnByZXYoKTtcbiAgICBpZiAoJHByZXYubGVuZ3RoKSB7XG4gICAgICB2YXIgdG9wID0gJHByZXYucG9zaXRpb24oKS50b3A7XG4gICAgICB2YXIgc2Nyb2xsUG9zID0gY3VycmVudFNjcm9sbCArIHRvcDtcbiAgICAgIHRoaXMuXyR0YXJnZXQuc2Nyb2xsVG9wKHNjcm9sbFBvcyk7XG4gICAgfVxuICB9LFxuXG4gIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bmJpbmRTY3JvbGwoKTtcbiAgICBWaWV3LnByb3RvdHlwZS5jbGVhbi5jYWxsKHRoaXMpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8dWwgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3QgQ0RCLVdpZGdldC1saXN0LS13aXRoQm9yZGVyc1wiPiA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtIENEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2xpPiA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtIENEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2xpPiA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtIENEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2xpPiA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RJdGVtIENEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2xpPiA8L3VsPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtaGVhZGVyXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRpdGxlIFdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxoMyBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZ1wiIHRpdGxlPVwiJytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMz4gPC9kaXY+IDxkbCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb1wiPiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXJcIj4nK1xuKChfX3Q9KCBpdGVtc0NvdW50ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyBpdGVtczwvZHQ+IDwvZGw+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50IGpzLWNvbnRlbnRcIj48L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIF8gPSBjZGIuXztcbnZhciBsb2cgPSBjZGIubG9nO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIGQzID0gY2RiLmQzO1xudmFyIGNvbnRlbnRUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vd2lkZ2V0X2NvbnRlbnRfdGVtcGxhdGUudHBsJyk7XG52YXIgcGxhY2Vob2xkZXJUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vd2lkZ2V0X3BsYWNlaG9sZGVyX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIERlZmF1bHQgd2lkZ2V0IGNvbnRlbnQgdmlldzpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1ib2R5JyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXI7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBpc0RhdGFFbXB0eSA9IF8uaXNFbXB0eShkYXRhKSB8fCBfLnNpemUoZGF0YSkgPT09IDA7XG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIGNvbnRlbnRUZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLm1vZGVsLmdldCgndGl0bGUnKSxcbiAgICAgICAgaXRlbXNDb3VudDogIWlzRGF0YUVtcHR5ID8gZGF0YS5sZW5ndGggOiAnLSdcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGlmIChpc0RhdGFFbXB0eSkge1xuICAgICAgdGhpcy5fYWRkUGxhY2Vob2xkZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICB9LFxuXG4gIF9hZGRQbGFjZWhvbGRlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHBsYWNlaG9sZGVyVGVtcGxhdGUpIHtcbiAgICAgIHRoaXMuJCgnLmpzLWNvbnRlbnQnKS5hcHBlbmQocGxhY2Vob2xkZXJUZW1wbGF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmluZm8oJ1BsYWNlaG9sZGVyIHRlbXBsYXRlIGRvZXNuXFwndCBleGlzdCcpO1xuICAgIH1cbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxidXR0b24gY2xhc3M9XCJDREItV2lkZ2V0LWJ1dHRvbiBDREItV2lkZ2V0LWVycm9yQnV0dG9uIGpzLXJlZnJlc2hcIj4gPHNwYW4gY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCBDREItV2lkZ2V0LXRleHRTbWFsbC0tYm9sZFwiPlJFRlJFU0g8L3NwYW4+IDwvYnV0dG9uPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3dpZGdldF9lcnJvcl90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiAgRGVmYXVsdCB3aWRnZXQgZXJyb3IgdmlldzpcbiAqXG4gKiAgSXQgd2lsbCBsaXN0ZW4gb3Igbm90IHRvIGRhdGFNb2RlbCBjaGFuZ2VzIHdoZW5cbiAqICBmaXJzdCBsb2FkIGlzIGRvbmUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtZXJyb3IgaXMtaGlkZGVuJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLXJlZnJlc2gnOiAnX29uUmVmcmVzaENsaWNrJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2Vycm9yJywgdGhpcy5zaG93LCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2xvYWRpbmcnLCB0aGlzLmhpZGUsIHRoaXMpO1xuICB9LFxuXG4gIF9vblJlZnJlc2hDbGljazogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmFkZENsYXNzKCdpcy1oaWRkZW4nKTtcbiAgfVxuXG59KTtcbiIsInZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcblxuLyoqXG4gKiAgRGVmYXVsdCB3aWRnZXQgbG9hZGVyIHZpZXc6XG4gKlxuICogIEl0IHdpbGwgbGlzdGVuIG9yIG5vdCB0byBkYXRhTW9kZWwgY2hhbmdlcyB3aGVuXG4gKiAgZmlyc3QgbG9hZCBpcyBkb25lLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWxvYWRlcicsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdsb2FkaW5nJywgdGhpcy5zaG93LCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ3N5bmMgZXJyb3InLCB0aGlzLmhpZGUsIHRoaXMpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmFkZENsYXNzKCdpcy12aXNpYmxlJyk7XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLiRlbC5yZW1vdmVDbGFzcygnaXMtdmlzaWJsZScpO1xuICAgIH0sIDUwMCk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jzx1bCBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdCBDREItV2lkZ2V0LWxpc3QtLXdpdGhCb3JkZXJzXCI+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0td2l0aEJvcmRlcnMgQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDwvdWw+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBwbGFjZWhvbGRlclRlbXBsYXRlID0gcmVxdWlyZSgnLi9wbGFjZWhvbGRlci50cGwnKTtcbnZhciBIaXN0b2dyYW1WaWV3ID0gcmVxdWlyZSgnLi9oaXN0b2dyYW0tdmlldycpO1xuXG4vKipcbiAqIFdpZGdldCBjb250ZW50IHZpZXcgZm9yIGEgdGltZS1zZXJpZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1ib2R5IENEQi1XaWRnZXQtYm9keS0tdGltZVNlcmllcycsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5vbmNlKCdjaGFuZ2U6ZGF0YScsIHRoaXMuX29uRmlyc3RMb2FkLCB0aGlzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuJGVsLmh0bWwoJycpOyAvLyB0byByZW1vdmUgcGxhY2Vob2xkZXIgaWYgdGhlcmUgaXMgYW55XG5cbiAgICBpZiAodGhpcy5faXNEYXRhRW1wdHkoKSkge1xuICAgICAgdGhpcy4kZWwuYXBwZW5kKHBsYWNlaG9sZGVyVGVtcGxhdGUoe1xuICAgICAgICBoYXNUb3JxdWVMYXllcjogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXBwZW5kVmlldyhuZXcgSGlzdG9ncmFtVmlldyh0aGlzLm9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfb25GaXJzdExvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3N0b3JlQm91bmRzKCk7XG4gICAgdGhpcy5tb2RlbC5vbmNlKCdjaGFuZ2U6ZGF0YScsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLl9mZXRjaCgpO1xuICB9LFxuXG4gIF9zdG9yZUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBzdGFydCA9IGRhdGFbMF0uc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLmVuZDtcbiAgICAgIHRoaXMubW9kZWwuc2V0KHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgYmluczogZGF0YS5sZW5ndGggfSk7XG4gICAgfVxuICB9LFxuXG4gIF9hcHBlbmRWaWV3OiBmdW5jdGlvbih2aWV3KSB7XG4gICAgdGhpcy5hZGRWaWV3KHZpZXcpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcbiAgfSxcblxuICBfaXNEYXRhRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShkYXRhKSB8fCBfLnNpemUoZGF0YSkgPT09IDA7XG4gIH1cbn0pO1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBIaXN0b2dyYW1DaGFydFZpZXcgPSByZXF1aXJlKCcuLi9oaXN0b2dyYW0vY2hhcnQnKTtcblxuLyoqXG4gKiBUaW1lLXNlcmllcyBoaXN0b2dyYW0gdmlldy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1jb250ZW50IENEQi1XaWRnZXQtY29udGVudC0tdGltZVNlcmllcycsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBtb2JpbGVUaHJlc2hvbGQ6IDk2MCwgLy8gcHg7IHNob3VsZCBtYXRjaCBDU1MgbWVkaWEtcXVlcnlcbiAgICBoaXN0b2dyYW1DaGFydEhlaWdodDpcbiAgICAgIDQ4ICsgLy8gaW5saW5lIGJhcnMgaGVpZ2h0XG4gICAgICA0ICsgLy8gYm90dG9tIG1hcmdpblxuICAgICAgMTYgKyAvLyBsYWJlbHNcbiAgICAgIDQsIC8vIG1hcmdpbnNcbiAgICBoaXN0b2dyYW1DaGFydE1vYmlsZUhlaWdodDpcbiAgICAgIDIwICsgLy8gaW5saW5lIGJhcnMgaGVpZ2h0IChubyBib3R0b20gbGFiZWxzKVxuICAgICAgNCAvLyBtYXJnaW5zXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuXG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6ZGF0YScsIHRoaXMuX29uQ2hhbmdlRGF0YSwgdGhpcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB0aGlzLl9jcmVhdGVIaXN0b2dyYW1WaWV3KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2NyZWF0ZUhpc3RvZ3JhbVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NoYXJ0VmlldyA9IG5ldyBIaXN0b2dyYW1DaGFydFZpZXcoe1xuICAgICAgdHlwZTogJ3RpbWUnLFxuICAgICAgYW5pbWF0aW9uU3BlZWQ6IDEwMCxcbiAgICAgIG1hcmdpbjoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIHJpZ2h0OiA0LFxuICAgICAgICBib3R0b206IDQsXG4gICAgICAgIGxlZnQ6IDRcbiAgICAgIH0sXG4gICAgICBoYXNIYW5kbGVzOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uQmFyRGVsYXk6IGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIChpICogMyk7XG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB0aGlzLmRlZmF1bHRzLmhpc3RvZ3JhbUNoYXJ0SGVpZ2h0LFxuICAgICAgZGF0YTogdGhpcy5tb2RlbC5nZXREYXRhKClcbiAgICB9KTtcbiAgICB0aGlzLmFkZFZpZXcodGhpcy5fY2hhcnRWaWV3KTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy5fY2hhcnRWaWV3LnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLl9jaGFydFZpZXcuc2hvdygpO1xuXG4gICAgdGhpcy5fY2hhcnRWaWV3LmJpbmQoJ29uX2JydXNoX2VuZCcsIHRoaXMuX29uQnJ1c2hFbmQsIHRoaXMpO1xuICAgIHRoaXMuX2NoYXJ0Vmlldy5tb2RlbC5iaW5kKCdjaGFuZ2U6d2lkdGgnLCB0aGlzLl9vbkNoYW5nZUNoYXJ0V2lkdGgsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5fY2hhcnRWaWV3Lm1vZGVsKTtcbiAgfSxcblxuICBfb25DaGFuZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY2hhcnRWaWV3KSB7XG4gICAgICB0aGlzLl9jaGFydFZpZXcucmVwbGFjZURhdGEodGhpcy5tb2RlbC5nZXREYXRhKCkpO1xuICAgIH1cbiAgfSxcblxuICBfb25CcnVzaEVuZDogZnVuY3Rpb24obG9CYXJJbmRleCwgaGlCYXJJbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgdGhpcy5maWx0ZXIuc2V0UmFuZ2UoXG4gICAgICBkYXRhW2xvQmFySW5kZXhdLnN0YXJ0LFxuICAgICAgZGF0YVtoaUJhckluZGV4IC0gMV0uZW5kXG4gICAgKTtcbiAgfSxcblxuICBfb25DaGFuZ2VDaGFydFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNNb2JpbGVTaXplID0gJCh3aW5kb3cpLndpZHRoKCkgPCB0aGlzLmRlZmF1bHRzLm1vYmlsZVRocmVzaG9sZDtcblxuICAgIHRoaXMuX2NoYXJ0Vmlldy50b2dnbGVMYWJlbHMoIWlzTW9iaWxlU2l6ZSk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gaXNNb2JpbGVTaXplXG4gICAgICA/IHRoaXMuZGVmYXVsdHMuaGlzdG9ncmFtQ2hhcnRNb2JpbGVIZWlnaHRcbiAgICAgIDogdGhpcy5kZWZhdWx0cy5oaXN0b2dyYW1DaGFydEhlaWdodDtcbiAgICB0aGlzLl9jaGFydFZpZXcubW9kZWwuc2V0KCdoZWlnaHQnLCBoZWlnaHQpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXIgQ0RCLVdpZGdldC1oZWFkZXItLXRpbWVTZXJpZXNcIj4gJztcbiBpZiAoaGFzVG9ycXVlTGF5ZXIpIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGltZVNlcmllc0Zha2VDb250cm9sXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRpbWVTZXJpZXNUaW1lSW5mbyBDREItV2lkZ2V0LXRpbWVTZXJpZXNUaW1lSW5mby0tZmFrZVwiPjwvZGl2PiAnO1xuIH0gXG5fX3ArPScgPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnQgQ0RCLVdpZGdldC1jb250ZW50LS10aW1lU2VyaWVzXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRpbWVTZXJpZXNGYWtlQ2hhcnQgJztcbiBpZiAoaGFzVG9ycXVlTGF5ZXIpIHsgXG5fX3ArPSdDREItV2lkZ2V0LXRpbWVTZXJpZXNGYWtlQ2hhcnQtLXRvcnF1ZSc7XG4gfSBcbl9fcCs9J1wiPiAnO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7IGkrKykgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC10aW1lU2VyaWVzRmFrZUNoYXJ0SXRlbVwiIHN0eWxlPVwiaGVpZ2h0OiAnK1xuKChfX3Q9KCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyVcIj48L2Rpdj4gJztcbiB9IFxuX19wKz0nIDwvZGl2PiA8L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIHRvcnF1ZVRlbXBsYXRlID0gcmVxdWlyZSgnLi90b3JxdWUtdGVtcGxhdGUudHBsJyk7XG52YXIgcGxhY2Vob2xkZXJUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vcGxhY2Vob2xkZXIudHBsJyk7XG52YXIgVG9ycXVlQ29udHJvbHNWaWV3ID0gcmVxdWlyZSgnLi90b3JxdWUtY29udHJvbHMtdmlldycpO1xudmFyIFRvcnF1ZVRpbWVJbmZvVmlldyA9IHJlcXVpcmUoJy4vdG9ycXVlLXRpbWUtaW5mby12aWV3Jyk7XG52YXIgVG9ycXVlSGlzdG9ncmFtVmlldyA9IHJlcXVpcmUoJy4vdG9ycXVlLWhpc3RvZ3JhbS12aWV3Jyk7XG5cbi8qKlxuICogV2lkZ2V0IGNvbnRlbnQgdmlldyBmb3IgYSBUb3JxdWUgdGltZS1zZXJpZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1ib2R5IENEQi1XaWRnZXQtYm9keS0tdGltZVNlcmllcycsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5vbmNlKCdjaGFuZ2U6ZGF0YScsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuXG4gICAgaWYgKHRoaXMuX2lzRGF0YUVtcHR5KCkpIHtcbiAgICAgIHRoaXMuJGVsLmh0bWwocGxhY2Vob2xkZXJUZW1wbGF0ZSh7XG4gICAgICAgIGhhc1RvcnF1ZUxheWVyOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlckNvbnRlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfcmVuZGVyQ29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0b3JxdWVUZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl9hcHBlbmRWaWV3KFxuICAgICAgbmV3IFRvcnF1ZUNvbnRyb2xzVmlldyh7IG1vZGVsOiB0aGlzLm9wdGlvbnMudG9ycXVlTGF5ZXJNb2RlbCB9KSxcbiAgICAgICcuanMtaGVhZGVyJ1xuICAgICk7XG4gICAgdGhpcy5fYXBwZW5kVmlldyhcbiAgICAgIG5ldyBUb3JxdWVUaW1lSW5mb1ZpZXcoeyBtb2RlbDogdGhpcy5vcHRpb25zLnRvcnF1ZUxheWVyTW9kZWwgfSksXG4gICAgICAnLmpzLWhlYWRlcidcbiAgICApO1xuICAgIHRoaXMuX2FwcGVuZFZpZXcobmV3IFRvcnF1ZUhpc3RvZ3JhbVZpZXcodGhpcy5vcHRpb25zKSk7XG4gIH0sXG5cbiAgX2FwcGVuZFZpZXc6IGZ1bmN0aW9uKHZpZXcsIHNlbGVjdG9yKSB7XG4gICAgdGhpcy5hZGRWaWV3KHZpZXcpO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgdGhpcy4kKHNlbGVjdG9yKS5hcHBlbmQodmlldy5lbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh2aWV3LmVsKTtcbiAgICB9XG4gICAgdmlldy5yZW5kZXIoKTtcbiAgfSxcblxuICBfaXNEYXRhRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShkYXRhKSB8fCBfLnNpemUoZGF0YSkgPT09IDA7XG4gIH1cbn0pO1xuIiwidmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90b3JxdWUtY29udHJvbHMudHBsJyk7XG5cbi8qKlxuICogVG9ycXVlIGFuaW1hdGlvbiBjb250cm9scywgdG8gbWFuYWdlIHJ1biBzdGF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICB0YWdOYW1lOiAnYnV0dG9uJyxcbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1jb250cm9sQnV0dG9uJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2snOiAnX29uQ2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6aXNSdW5uaW5nJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgaWNvbkNsYXNzOiAnQ0RCLVdpZGdldC1jb250cm9sQnV0dG9uLWljb24gQ0RCLVdpZGdldC1jb250cm9sQnV0dG9uLWljb24tLScgKyAoXG4gICAgICAgICAgdGhpcy5tb2RlbC5nZXQoJ2lzUnVubmluZycpXG4gICAgICAgICAgICA/ICdwYXVzZSdcbiAgICAgICAgICAgIDogJ3BsYXknKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX29uQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnaXNSdW5uaW5nJykpIHtcbiAgICAgIHRoaXMubW9kZWwucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb2RlbC5wbGF5KCk7XG4gICAgfVxuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udHJvbEJ1dHRvbi1jb250ZW50XCI+IDxpIGNsYXNzPVwiJytcbigoX190PSggaWNvbkNsYXNzICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPjwvaT4gPC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBIaXN0b2dyYW1DaGFydFZpZXcgPSByZXF1aXJlKCcuLi9oaXN0b2dyYW0vY2hhcnQnKTtcbnZhciBUb3JxdWVUaW1lU2xpZGVyVmlldyA9IHJlcXVpcmUoJy4vdG9ycXVlLXRpbWUtc2xpZGVyLXZpZXcnKTtcblxuLyoqXG4gKiBUb3JxdWUgdGltZS1zZXJpZXMgaGlzdG9ncmFtIHZpZXcuXG4gKiBFeHRlbmRzIHRoZSBjb21tb24gaGlzdG9ncmFtIGNoYXJ0IHZpZXcgd2l0aCB0aW1lLWNvbnRyb2xcbiAqIHRoaXMubW9kZWwgaXMgYSBoaXN0b2dyYW0gbW9kZWxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1jb250ZW50IENEQi1XaWRnZXQtY29udGVudC0tdGltZVNlcmllcycsXG5cbiAgLy8gVE9ETyBjb3VsZCBiZSBjYWxjdWxhdGVkIGZyb20gZWxlbWVudCBzdHlsZXMgaW5zdGVhZCBvZiBkdXBsaWNhdGVkIG51bWJlcnMgaGVyZT9cbiAgZGVmYXVsdHM6IHtcbiAgICBtb2JpbGVUaHJlc2hvbGQ6IDk2MCwgLy8gcHg7IHNob3VsZCBtYXRjaCBDU1MgbWVkaWEtcXVlcnlcbiAgICBoaXN0b2dyYW1DaGFydEhlaWdodDpcbiAgICAgIDQ4ICsgLy8gaW5saW5lIGJhcnMgaGVpZ2h0XG4gICAgICA0ICsgLy8gYm90dG9tIG1hcmdpblxuICAgICAgMTYgKyAvLyBib3R0b20gbGFiZWxzXG4gICAgICA0LCAvLyBtYXJnaW5zXG4gICAgaGlzdG9ncmFtQ2hhcnRNb2JpbGVIZWlnaHQ6XG4gICAgICAyMCArIC8vIGlubGluZSBiYXJzIGhlaWdodCAobm8gYm90dG9tIGxhYmVscylcbiAgICAgIDQgLy8gbWFyZ2luc1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnRvcnF1ZUxheWVyTW9kZWwpIHRocm93IG5ldyBFcnJvcigndG9ycWVMYXllck1vZGVsIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucmFuZ2VGaWx0ZXIpIHRocm93IG5ldyBFcnJvcigncmFuZ2VGaWx0ZXIgaXMgcmVxdWlyZWQnKTtcblxuICAgIHRoaXMuX3JhbmdlRmlsdGVyID0gdGhpcy5vcHRpb25zLnJhbmdlRmlsdGVyO1xuICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwgPSB0aGlzLm9wdGlvbnMudG9ycXVlTGF5ZXJNb2RlbDtcblxuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOmRhdGEnLCB0aGlzLl9vbkNoYW5nZURhdGEsIHRoaXMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy5fY3JlYXRlSGlzdG9ncmFtVmlldygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9jcmVhdGVIaXN0b2dyYW1WaWV3OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jaGFydFZpZXcgPSBuZXcgSGlzdG9ncmFtQ2hhcnRWaWV3KHtcbiAgICAgIHR5cGU6ICd0aW1lJyxcbiAgICAgIGFuaW1hdGlvblNwZWVkOiAxMDAsXG4gICAgICBhbmltYXRpb25CYXJEZWxheTogZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gKGkgKiAzKTtcbiAgICAgIH0sXG4gICAgICBtYXJnaW46IHtcbiAgICAgICAgdG9wOiA0LFxuICAgICAgICByaWdodDogNCxcbiAgICAgICAgYm90dG9tOiA0LFxuICAgICAgICBsZWZ0OiA0XG4gICAgICB9LFxuICAgICAgaGFzSGFuZGxlczogdHJ1ZSxcbiAgICAgIGhlaWdodDogdGhpcy5kZWZhdWx0cy5oaXN0b2dyYW1DaGFydEhlaWdodCxcbiAgICAgIGRhdGE6IHRoaXMubW9kZWwuZ2V0RGF0YSgpLFxuICAgICAgc2hhZG93RGF0YTogdGhpcy5tb2RlbC5nZXREYXRhKClcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkVmlldyh0aGlzLl9jaGFydFZpZXcpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLl9jaGFydFZpZXcucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuX2NoYXJ0Vmlldy5zaG93KCk7XG5cbiAgICB0aGlzLl9jaGFydFZpZXcuYmluZCgnb25fYnJ1c2hfZW5kJywgdGhpcy5fb25CcnVzaEVuZCwgdGhpcyk7XG4gICAgdGhpcy5fY2hhcnRWaWV3Lm1vZGVsLmJpbmQoJ2NoYW5nZTp3aWR0aCcsIHRoaXMuX29uQ2hhbmdlQ2hhcnRXaWR0aCwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLl9jaGFydFZpZXcubW9kZWwpO1xuXG4gICAgdmFyIHRpbWVTbGlkZXJWaWV3ID0gbmV3IFRvcnF1ZVRpbWVTbGlkZXJWaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLCAvLyBhIGhpc3RvZ3JhbSBtb2RlbFxuICAgICAgY2hhcnRWaWV3OiB0aGlzLl9jaGFydFZpZXcsXG4gICAgICB0b3JxdWVMYXllck1vZGVsOiB0aGlzLl90b3JxdWVMYXllck1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy5hZGRWaWV3KHRpbWVTbGlkZXJWaWV3KTtcbiAgICB0aW1lU2xpZGVyVmlldy5yZW5kZXIoKTtcbiAgfSxcblxuICBfb25DaGFuZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY2hhcnRWaWV3KSB7XG4gICAgICB0aGlzLl9jaGFydFZpZXcucmVwbGFjZURhdGEodGhpcy5tb2RlbC5nZXREYXRhKCkpO1xuICAgIH1cbiAgfSxcblxuICBfb25CcnVzaEVuZDogZnVuY3Rpb24obG9CYXJJbmRleCwgaGlCYXJJbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgdGhpcy5fcmFuZ2VGaWx0ZXIuc2V0UmFuZ2UoXG4gICAgICBkYXRhW2xvQmFySW5kZXhdLnN0YXJ0LFxuICAgICAgZGF0YVtoaUJhckluZGV4IC0gMV0uZW5kXG4gICAgKTtcbiAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLnNldFN0ZXBzUmFuZ2UobG9CYXJJbmRleCwgaGlCYXJJbmRleCk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlQ2hhcnRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlzTW9iaWxlU2l6ZSA9ICQod2luZG93KS53aWR0aCgpIDwgdGhpcy5kZWZhdWx0cy5tb2JpbGVUaHJlc2hvbGQ7XG5cbiAgICB0aGlzLl9jaGFydFZpZXcudG9nZ2xlTGFiZWxzKCFpc01vYmlsZVNpemUpO1xuXG4gICAgdmFyIGhlaWdodCA9IGlzTW9iaWxlU2l6ZVxuICAgICAgPyB0aGlzLmRlZmF1bHRzLmhpc3RvZ3JhbUNoYXJ0TW9iaWxlSGVpZ2h0XG4gICAgICA6IHRoaXMuZGVmYXVsdHMuaGlzdG9ncmFtQ2hhcnRIZWlnaHQ7XG4gICAgdGhpcy5fY2hhcnRWaWV3Lm1vZGVsLnNldCgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtaGVhZGVyIENEQi1XaWRnZXQtaGVhZGVyLS10aW1lU2VyaWVzIGpzLWhlYWRlclwiPjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgZDMgPSBjZGIuZDM7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RvcnF1ZS10aW1lLWluZm8udHBsJyk7XG5cbi8qKlxuICogVmlldyByZW5kZXJpbmcgdGhlIGN1cnJlbnQgc3RlcCB0aW1lXG4gKlxuICogTW9kZWwgaXMgZXhwZWN0ZWQgdG8gYmUgYSB0b3JxdWUgbGF5ZXIgbW9kZWxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC10aW1lU2VyaWVzVGltZUluZm8nLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOnN0ZXAnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG5cbiAgICAvLyBmb3IgZm9ybWF0IHJ1bGVzIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvd2lraS9UaW1lLUZvcm1hdHRpbmdcbiAgICB0aGlzLl90aW1lRm9ybWF0dGVyID0gZDMudGltZS5mb3JtYXQoJyVIOiVNJyk7XG4gICAgdGhpcy5fZGF0ZUZvcm1hdHRlciA9IGQzLnRpbWUuZm9ybWF0KCcleCcpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGUgPSB0aGlzLm1vZGVsLmdldCgndGltZScpO1xuXG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIGlzTmFOKGRhdGUgJiYgZGF0ZS5nZXRUaW1lKCkpXG4gICAgICAgID8gJydcbiAgICAgICAgOiB0ZW1wbGF0ZSh7XG4gICAgICAgICAgICB0aW1lOiB0aGlzLl90aW1lRm9ybWF0dGVyKGRhdGUpLFxuICAgICAgICAgICAgZGF0ZTogdGhpcy5fZGF0ZUZvcm1hdHRlcihkYXRlKVxuICAgICAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRCaWdcIj4gJytcbigoX190PSggdGltZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgPC9wPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZyBDREItV2lkZ2V0LXRleHQtLXNlY29uZGFyeVwiPiAnK1xuKChfX3Q9KCBkYXRlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyA8L3A+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIGQzID0gY2RiLmQzO1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG5cbi8qKlxuICogVGltZS1zbGlkZXIsIGV4cGVjdGVkIHRvIGJlIHVzZWQgaW4gYSBoaXN0b2dyYW0gdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHdpZHRoOiA0LFxuICAgIGhlaWdodDogOFxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLm1vZGVsKSB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY2hhcnRWaWV3KSB0aHJvdyBuZXcgRXJyb3IoJ2NoYXJ0VmlldyBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnRvcnF1ZUxheWVyTW9kZWwpIHRocm93IG5ldyBFcnJvcigndG9ycWVMYXllck1vZGVsIGlzIHJlcXVpcmVkJyk7XG5cbiAgICB0aGlzLl9jaGFydFZpZXcgPSB0aGlzLm9wdGlvbnMuY2hhcnRWaWV3O1xuICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwgPSB0aGlzLm9wdGlvbnMudG9ycXVlTGF5ZXJNb2RlbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBNb2RlbCgpO1xuXG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5iaW5kKCdjaGFuZ2U6c3RlcCcsIHRoaXMuX29uQ2hhbmdlU3RlcCwgdGhpcyk7XG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5iaW5kKCdjaGFuZ2U6c3RlcHMnLCB0aGlzLl9vbkNoYW5nZVN0ZXBzLCB0aGlzKTtcbiAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLmJpbmQoJ2NoYW5nZTpzdGVwc1JhbmdlJywgdGhpcy5fb25TdGVwc1JhbmdlLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwpO1xuXG4gICAgdGhpcy5fY2hhcnRWaWV3Lm1vZGVsLmJpbmQoJ2NoYW5nZTp3aWR0aCcsIHRoaXMuX29uQ2hhbmdlQ2hhcnRXaWR0aCwgdGhpcyk7XG4gICAgdGhpcy5fY2hhcnRWaWV3Lm1vZGVsLmJpbmQoJ2NoYW5nZTpoZWlnaHQnLCB0aGlzLl9vbkNoYW5nZUNoYXJ0SGVpZ2h0LCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX2NoYXJ0Vmlldy5tb2RlbCk7XG5cbiAgICB0aGlzLl91cGRhdGVYU2NhbGUoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE1ha2UgdGhlIHJlbmRlciBjYWxsIGlkZW1wb3RlbnQ7IG9ubHkgY3JlYXRlIHRpbWUgc2xpZGVyIG9uY2VcbiAgICBpZiAoIXRoaXMudGltZVNsaWRlcikge1xuICAgICAgdmFyIGRyYWdCZWhhdmlvciA9IGQzLmJlaGF2aW9yLmRyYWcoKVxuICAgICAgICAub24oJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpXG4gICAgICAgIC5vbignZHJhZycsIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKVxuICAgICAgICAub24oJ2RyYWdlbmQnLCB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMudGltZVNsaWRlciA9IHRoaXMuX2NoYXJ0Vmlldy5jYW52YXMuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1UaW1lU2xpZGVyJylcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5kZWZhdWx0cy53aWR0aClcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuX2NhbGNIZWlnaHQoKSlcbiAgICAgICAgLmF0dHIoJ3J4JywgMylcbiAgICAgICAgLmF0dHIoJ3J5JywgMylcbiAgICAgICAgLmRhdGEoW3sgeDogMCwgeTogMCB9XSlcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIHRoaXMuX3RyYW5zbGF0ZVhZKVxuICAgICAgICAuY2FsbChkcmFnQmVoYXZpb3IpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50aW1lU2xpZGVyKSB7XG4gICAgICB0aGlzLnRpbWVTbGlkZXIucmVtb3ZlKCk7XG4gICAgfVxuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgX29uRHJhZ1N0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNSdW5uaW5nID0gdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5nZXQoJ2lzUnVubmluZycpO1xuICAgIGlmIChpc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwucGF1c2UoKTtcbiAgICB9XG4gICAgdGhpcy52aWV3TW9kZWwuc2V0KHtcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICB3YXNSdW5uaW5nOiBpc1J1bm5pbmdcbiAgICB9KTtcbiAgfSxcblxuICBfb25EcmFnOiBmdW5jdGlvbihkLCBpKSB7XG4gICAgdmFyIG5leHRYID0gZC54ICsgZDMuZXZlbnQuZHg7XG4gICAgaWYgKHRoaXMuX2lzV2l0aGluUmFuZ2UobmV4dFgpKSB7XG4gICAgICBkLnggPSBuZXh0WDtcbiAgICAgIHRoaXMudGltZVNsaWRlci5hdHRyKCd0cmFuc2Zvcm0nLCB0aGlzLl90cmFuc2xhdGVYWSk7XG5cbiAgICAgIHZhciBzdGVwID0gTWF0aC5yb3VuZCh0aGlzLl94U2NhbGUuaW52ZXJ0KGQueCkpO1xuICAgICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5zZXRTdGVwKHN0ZXApO1xuICAgIH1cbiAgfSxcblxuICBfb25EcmFnRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQoJ2lzRHJhZ2dpbmcnLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMudmlld01vZGVsLmdldCgnd2FzUnVubmluZycpKSB7XG4gICAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLnBsYXkoKTtcbiAgICB9XG4gIH0sXG5cbiAgX3RyYW5zbGF0ZVhZOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIFtkLngsIGQueV0gKyAnKSc7XG4gIH0sXG5cbiAgX2lzV2l0aGluUmFuZ2U6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCA+PSAwICYmIHggPD0gdGhpcy5fd2lkdGgoKTtcbiAgfSxcblxuICBfb25DaGFuZ2VTdGVwOiBmdW5jdGlvbigpIHtcbiAgICAvLyBUaW1lIHNsaWRlciBtaWdodCBub3QgYmUgY3JlYXRlZCB3aGVuIHRoaXMgbWV0aG9kIGlzIGZpcnN0IGNhbGxlZFxuICAgIGlmICh0aGlzLnRpbWVTbGlkZXIgJiYgIXRoaXMudmlld01vZGVsLmdldCgnaXNEcmFnZ2luZycpKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMudGltZVNsaWRlci5kYXRhKCk7XG4gICAgICB2YXIgbmV3WCA9IHRoaXMuX3hTY2FsZSh0aGlzLl90b3JxdWVMYXllck1vZGVsLmdldCgnc3RlcCcpKTtcbiAgICAgIGlmICghaXNOYU4obmV3WCkpIHtcbiAgICAgICAgZGF0YVswXS54ID0gbmV3WDtcbiAgICAgICAgdGhpcy50aW1lU2xpZGVyXG4gICAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgLmVhc2UoJ2xpbmVhcicpXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIHRoaXMuX3RyYW5zbGF0ZVhZKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX29uQ2hhbmdlU3RlcHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VwZGF0ZVhTY2FsZSgpO1xuICB9LFxuXG4gIF9vblN0ZXBzUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5nZXQoJ3N0ZXBzUmFuZ2UnKTtcbiAgICBpZiAoci5zdGFydCA9PT0gMCAmJiByLmVuZCA9PT0gdGhpcy5tb2RlbC5nZXQoJ2JpbnMnKSkge1xuICAgICAgdGhpcy5fY2hhcnRWaWV3LnJlbW92ZVNlbGVjdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jaGFydFZpZXcuc2VsZWN0UmFuZ2Uoci5zdGFydCwgci5lbmQpO1xuICAgIH1cbiAgfSxcblxuICBfb25DaGFuZ2VDaGFydFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91cGRhdGVYU2NhbGUoKTtcbiAgICB0aGlzLl9vbkNoYW5nZVN0ZXAoKTtcbiAgfSxcblxuICBfb25DaGFuZ2VDaGFydEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lU2xpZGVyLmF0dHIoJ2hlaWdodCcsIHRoaXMuX2NhbGNIZWlnaHQoKSk7XG4gIH0sXG5cbiAgX2NhbGNIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydFZpZXcuY2hhcnRIZWlnaHQoKSArIHRoaXMuZGVmYXVsdHMuaGVpZ2h0O1xuICB9LFxuXG4gIF91cGRhdGVYU2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3hTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAuZG9tYWluKFswLCB0aGlzLl90b3JxdWVMYXllck1vZGVsLmdldCgnc3RlcHMnKV0pXG4gICAgICAucmFuZ2UoWzAsIHRoaXMuX3dpZHRoKCldKTtcbiAgfSxcblxuICBfd2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydFZpZXcubW9kZWwuZ2V0KCd3aWR0aCcpO1xuICB9XG59KTtcbiIsInZhciBfID0gY2RiLl87XG5cbnZhciBXaWRnZXRNb2RlbEZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgdHlwZXMgPSB0eXBlcyB8fCB7fTtcbiAgdGhpcy50eXBlcyA9IHt9O1xuICBmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XG4gICAgdmFyIGNyZWF0ZU1vZGVsID0gdHlwZXNbdHlwZV07XG4gICAgdGhpcy5hZGRUeXBlKHR5cGUsIGNyZWF0ZU1vZGVsKTtcbiAgfVxufTtcblxuV2lkZ2V0TW9kZWxGYWN0b3J5LnByb3RvdHlwZS5hZGRUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGNyZWF0ZU1vZGVsKSB7XG4gIGlmICghXy5pc1N0cmluZyh0eXBlKSkgbmV3IEVycm9yKCd0eXBlIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbicpO1xuICBpZiAoIV8uaXNGdW5jdGlvbihjcmVhdGVNb2RlbCkpIG5ldyBFcnJvcignY3JlYXRlTW9kZWwgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMudHlwZXNbdHlwZV0gPSBjcmVhdGVNb2RlbDtcbn07XG5cbldpZGdldE1vZGVsRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTW9kZWwgPSBmdW5jdGlvbiAobGF5ZXIsIGxheWVySW5kZXgsIGF0dHJzKSB7XG4gIGlmICghYXR0cnMuaWQpIHRocm93IG5ldyBFcnJvcignYXR0cnMuaWQgaXMgcmVxdWlyZWQnKTtcblxuICB2YXIgY3JlYXRlTW9kZWwgPSB0aGlzLnR5cGVzW2F0dHJzLnR5cGVdO1xuICBpZiAoY3JlYXRlTW9kZWwpIHtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGxheWVyOiBsYXllclxuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU1vZGVsKGF0dHJzLCBvcHRzLCBsYXllckluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG1vZGVsIGZvdW5kIGZvciBhcmd1bWVudHMgJyArIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0TW9kZWxGYWN0b3J5O1xuIiwidmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIF8gPSBjZGIuXztcblxuLyoqXG4gKiBTdGFuZGFyZCB3aWRnZXQgdG9vbHRpcCB2aWV3XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LXRvb2x0aXAnLFxuXG4gIG9wdGlvbnM6IHtcbiAgICBhdHRyaWJ1dGU6ICdkYXRhLXRvb2x0aXAnLFxuICAgIG9mZnNldFg6IDEwLFxuICAgIG9mZnNldFk6IC0yOFxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMudGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgICB0aGlzLl8kdGFyZ2V0ID0gdGhpcy5vcHRpb25zLnRhcmdldDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuXyR0YXJnZXQuYXR0cih0aGlzLm9wdGlvbnMuYXR0cmlidXRlKTtcbiAgICB0aGlzLiRlbC5odG1sKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl8kdGFyZ2V0LmhvdmVyKFxuICAgICAgXy5iaW5kKHRoaXMuc2hvdywgdGhpcyksXG4gICAgICBfLmJpbmQodGhpcy5oaWRlLCB0aGlzKVxuICAgICk7XG4gIH0sXG5cbiAgX3NldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5fJHRhcmdldC5vZmZzZXQoKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLiRlbC5vdXRlcldpZHRoKCk7XG5cbiAgICB0aGlzLiRlbC5jc3Moe1xuICAgICAgdG9wOiBwb3MudG9wICsgdGhpcy5vcHRpb25zLm9mZnNldFksXG4gICAgICBsZWZ0OiBwb3MubGVmdCAtICh3aWR0aC8yKSArIHRoaXMub3B0aW9ucy5vZmZzZXRYXG4gICAgfSk7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIFZpZXcucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzKTtcbiAgfSxcblxuICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fJHRhcmdldC5vZmYoJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFdpZGdldFZpZXcgPSByZXF1aXJlKCcuL3dpZGdldC12aWV3Jyk7XG5cbnZhciBXaWRnZXRWaWV3RmFjdG9yeSA9IGZ1bmN0aW9uKGRlZnMpIHtcbiAgdGhpcy5kZWZzID0gW107XG4gIF8uZWFjaChkZWZzLCBmdW5jdGlvbihkZWYpIHtcbiAgICB0aGlzLmFkZFR5cGUoZGVmKTtcbiAgfSwgdGhpcyk7XG59O1xuXG5XaWRnZXRWaWV3RmFjdG9yeS5wcm90b3R5cGUuREVGQVVMVF9DTEFTU19OQU1FUyA9ICdDREItV2lkZ2V0IENEQi1XaWRnZXQtLWxpZ2h0JztcblxuV2lkZ2V0Vmlld0ZhY3RvcnkucHJvdG90eXBlLmFkZFR5cGUgPSBmdW5jdGlvbihkZWYpIHtcbiAgaWYgKCFkZWYubWF0Y2gpIHtcbiAgICBpZiAoZGVmLnR5cGUpIHtcbiAgICAgIGRlZi5tYXRjaCA9IGZ1bmN0aW9uKHdpZGdldCkge1xuICAgICAgICByZXR1cm4gd2lkZ2V0LmdldCgndHlwZScpID09PSB0aGlzLnR5cGU7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgRXJyb3IoJ2RlZi50eXBlIG9yIGRlZi5tYXRjaCBtdXN0IGJlIHByb3ZpZGVkIGZvciBjcmVhdGVDb250ZW50VmlldyB0byB3b3JrJyk7XG4gICAgfVxuICB9XG4gIGlmICghXy5pc0Z1bmN0aW9uKGRlZi5jcmVhdGVDb250ZW50VmlldykpIG5ldyBFcnJvcignZGVmLmNyZWF0ZUNvbnRlbnRWaWV3IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLmRlZnMucHVzaChkZWYpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7T2JqZWN0LCB1bmRlZmluZWR9IFJldHVybnMgbm90aGluZyBpZiB0aGVyZSBpcyBub3QgbWF0Y2hpbmcgdmlldyBmb3IgdGhlIGdpdmVuIG1vZGVsXG4gKi9cbldpZGdldFZpZXdGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVXaWRnZXRWaWV3ID0gZnVuY3Rpb24od2lkZ2V0KSB7XG4gIHZhciBkZWYgPSBfLmZpbmQodGhpcy5kZWZzLCBmdW5jdGlvbihkZWYpIHtcbiAgICByZXR1cm4gZGVmLm1hdGNoKHdpZGdldCk7XG4gIH0pO1xuXG4gIGlmIChkZWYpIHtcbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuREVGQVVMVF9DTEFTU19OQU1FUyxcbiAgICAgIG1vZGVsOiB3aWRnZXQsXG4gICAgICBjb250ZW50VmlldzogZGVmLmNyZWF0ZUNvbnRlbnRWaWV3KHdpZGdldClcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBXaWRnZXRWaWV3KFxuICAgICAgXy5pc0Z1bmN0aW9uKGRlZi5jdXN0b21pemVXaWRnZXRBdHRycylcbiAgICAgICAgPyBkZWYuY3VzdG9taXplV2lkZ2V0QXR0cnMoYXR0cnMpXG4gICAgICAgIDogYXR0cnNcbiAgICApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldFZpZXdGYWN0b3J5O1xuIiwidmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIFdpZGdldExvYWRlclZpZXcgPSByZXF1aXJlKCcuL3N0YW5kYXJkL3dpZGdldF9sb2FkZXJfdmlldycpO1xudmFyIFdpZGdldEVycm9yVmlldyA9IHJlcXVpcmUoJy4vc3RhbmRhcmQvd2lkZ2V0X2Vycm9yX3ZpZXcnKTtcblxuLyoqXG4gKiBEZWZhdWx0IHdpZGdldCB2aWV3XG4gKiBUaGUgbW9kZWwgaXMgYSBleHBlY3RlZCB0byBiZSB3aWRnZXQgbW9kZWxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldCBDREItV2lkZ2V0LS1saWdodCcsXG5cbiAgb3B0aW9uczoge1xuICAgIGNvbHVtbnNfdGl0bGU6IFtdLFxuICAgIHN5bmM6IHRydWVcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmxheWVyLmJpbmQoJ2NoYW5nZTp2aXNpYmxlJywgdGhpcy5fb25DaGFuZ2VMYXllclZpc2libGUsIHRoaXMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbG9hZGVyID0gbmV3IFdpZGdldExvYWRlclZpZXcoe1xuICAgICAgbW9kZWw6IHRoaXMubW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy5fbG9hZGVyLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcodGhpcy5fbG9hZGVyKTtcblxuICAgIHRoaXMuX2Vycm9yID0gbmV3IFdpZGdldEVycm9yVmlldyh7XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLl9lcnJvci5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHRoaXMuX2Vycm9yKTtcblxuICAgIHZhciBjb250ZW50VmlldyA9IHRoaXMub3B0aW9ucy5jb250ZW50VmlldztcbiAgICB0aGlzLiRlbC5hcHBlbmQoY29udGVudFZpZXcucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhjb250ZW50Vmlldyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfb25DaGFuZ2VMYXllclZpc2libGU6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgLy8gISEgdG8gZm9yY2UgYSBib29sZWFuIHZhbHVlLCBzbyBvbmx5IGEgdHJ1ZSB2YWx1ZSBhY3R1YWxseSBzaG93cyB0aGUgdmlld1xuICAgIHRoaXMuJGVsLnRvZ2dsZSghIWxheWVyLmdldCgndmlzaWJsZScpKTtcbiAgfVxufSk7XG4iLCJ2YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxuLyoqXG4gKiAgVmlldyBtb2RlbCwgc3BlY2lhbCBmb3Igd2lkZ2V0cyB3aXRoIHNlYXJjaCBhbmQgY29sbGFwc2VcbiAqICBmdW5jdGlvbmFsaXRpZXNcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgc2VhcmNoOiBmYWxzZVxuICB9LFxuXG4gIHRvZ2dsZVNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXQoJ3NlYXJjaCcsICF0aGlzLmdldCgnc2VhcmNoJykpO1xuICB9LFxuXG4gIGVuYWJsZVNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXQoJ3NlYXJjaCcsIHRydWUpO1xuICB9LFxuXG4gIGRpc2FibGVTZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdzZWFyY2gnLCBmYWxzZSk7XG4gIH0sXG5cbiAgaXNTZWFyY2hFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3NlYXJjaCcpO1xuICB9XG5cbn0pO1xuIiwidmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG5cbi8qKlxuICogRGVmYXVsdCB3aWRnZXQgbW9kZWxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBNb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgdXJsOiAnJyxcbiAgICBkYXRhOiBbXSxcbiAgICBjb2x1bW5zOiBbXSxcbiAgICBzeW5jOiB0cnVlLFxuICAgIGJib3g6IHRydWUsXG4gICAgY29sbGFwc2VkOiBmYWxzZVxuICB9LFxuXG4gIHVybDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd1cmwnKSArICc/YmJveD0nICsgdGhpcy5nZXQoJ2JvdW5kaW5nQm94Jyk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHRoaXMubGF5ZXIgPSBvcHRzLmxheWVyO1xuICAgIHRoaXMuZmlsdGVyID0gb3B0cy5maWx0ZXI7IC8vIG9wdGlvbmFsL21pZ2h0IGJlIHVuZGVmaW5lZFxuXG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbmNlKCdjaGFuZ2U6dXJsJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLl9mZXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fb25DaGFuZ2VCaW5kcygpO1xuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyBSZXRyaWdnZXIgYW4gZXZlbnQgd2hlbiB0aGUgZmlsdGVyIGNoYW5nZXNcbiAgICBpZiAodGhpcy5maWx0ZXIpIHtcbiAgICAgIHRoaXMuZmlsdGVyLmJpbmQoJ2NoYW5nZScsIHRoaXMuX29uRmlsdGVyQ2hhbmdlZCwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkNoYW5nZUJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTp1cmwnLCBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMuZ2V0KCdzeW5jJykgJiYgIXRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICB0aGlzLl9mZXRjaCgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuYmluZCgnY2hhbmdlOmJvdW5kaW5nQm94JywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5nZXQoJ2Jib3gnKSAmJiAhdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIHRoaXMuX2ZldGNoKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTpjb2xsYXBzZWQnLCBmdW5jdGlvbihtZGwsIGlzQ29sbGFwc2VkKSB7XG4gICAgICBpZiAoIWlzQ29sbGFwc2VkKSB7XG4gICAgICAgIGlmIChtZGwuY2hhbmdlZEF0dHJpYnV0ZXModGhpcy5fcHJldmlvdXNBdHRycykpIHtcbiAgICAgICAgICB0aGlzLl9mZXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0F0dHJzID0ge1xuICAgICAgICAgIHVybDogdGhpcy5nZXQoJ3VybCcpLFxuICAgICAgICAgIGJvdW5kaW5nQm94OiB0aGlzLmdldCgnYm91bmRpbmdCb3gnKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIF9mZXRjaDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mZXRjaCh7XG4gICAgICBzdWNjZXNzOiBjYWxsYmFjayxcbiAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdlcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZldGNoKCk7XG4gIH0sXG5cbiAgaXNDb2xsYXBzZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnY29sbGFwc2VkJyk7XG4gIH0sXG5cbiAgdG9nZ2xlQ29sbGFwc2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnY29sbGFwc2VkJywgIXRoaXMuZ2V0KCdjb2xsYXBzZWQnKSk7XG4gIH0sXG5cbiAgX29uRmlsdGVyQ2hhbmdlZDogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6ZmlsdGVyJywgdGhpcywgZmlsdGVyKTtcbiAgfSxcblxuICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2RhdGEnKTtcbiAgfSxcblxuICBnZXRQcmV2aW91c0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCdkYXRhJyk7XG4gIH0sXG5cbiAgZmV0Y2g6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB0aGlzLnRyaWdnZXIoXCJsb2FkaW5nXCIsIHRoaXMpO1xuICAgIHJldHVybiBNb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLG9wdHMpO1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b0pTT04gc2hvdWxkIGJlIGRlZmluZWQgZm9yIGVhY2ggd2lkZ2V0Jyk7XG4gIH1cbn0pO1xuIiwidmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xudmFyIF8gPSBjZGIuXztcblxuLyoqXG4gKiAgQ29sbGVjdGlvbiB0aGF0IGNvbnRyb2xzIHdpZGdldCBtb2RlbHMgcGVyIGxheWVyXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiBhIGNhdGVnb3J5IG1vZGVsIGFwcGxpZXMgdGhlIGNhdGVnb3J5IGNvbG9ycywgcmVzdCBzaG91bGQgcmVtb3ZlL2Rpc2FibGVcbiAgICAvLyB0aGUgY2F0ZWdvcnkgY29sb3JzIGFwcGxpZWQgYmVmb3JlLlxuICAgIHRoaXMuYmluZCgnY2hhbmdlOmNhdGVnb3J5Q29sb3JzJywgZnVuY3Rpb24obSwgaXNDb2xvckNhdGVnb3JpemVkKSB7XG4gICAgICBpZiAoaXNDb2xvckNhdGVnb3JpemVkKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihtZGwpIHtcbiAgICAgICAgICBpZiAobWRsICE9PSBtICYmIG1kbC5nZXQoJ2NhdGVnb3J5Q29sb3JzJykpIHtcbiAgICAgICAgICAgIG1kbC5zZXQoJ2NhdGVnb3J5Q29sb3JzJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIElmIGEgaGlzdG9ncmFtIG1vZGVsIGFwcGxpZXMgdGhlIGhpc3RvZ3JhbSBzaXplcywgcmVzdCBzaG91bGQgcmVtb3ZlL2Rpc2FibGVcbiAgICAvLyB0aGUgc2l6ZXMgYXBwbGllZCBiZWZvcmUuXG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6aGlzdG9ncmFtU2l6ZXMnLCBmdW5jdGlvbihtLCBpc1NpemVzQXBwbGllZCkge1xuICAgICAgaWYgKGlzU2l6ZXNBcHBsaWVkKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihtZGwpIHtcbiAgICAgICAgICBpZiAobWRsICE9PSBtICYmIG1kbC5nZXQoJ2hpc3RvZ3JhbVNpemVzJykpIHtcbiAgICAgICAgICAgIG1kbC5zZXQoJ2hpc3RvZ3JhbVNpemVzJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG59KTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIExaTUEgPSBjZGIuTFpNQTtcbnZhciB1dGlsID0gY2RiLmNvcmUudXRpbDtcbnZhciBXaW5kc2hhZnREYXNoYm9hcmRJbnN0YW5jZSA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLWluc3RhbmNlJyk7XG5cbnZhciB2YWxpZGF0ZVByZXNlbmNlT2ZPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywgcmVxdWlyZWRPcHRpb25zKSB7XG4gIHZhciBtaXNzaW5nT3B0aW9ucyA9IF8uZmlsdGVyKHJlcXVpcmVkT3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgcmV0dXJuICFvcHRpb25zW29wdGlvbl07XG4gIH0pO1xuICBpZiAobWlzc2luZ09wdGlvbnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgJ1RoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgcmVxdWlyZWQ6ICcgKyBtaXNzaW5nT3B0aW9ucy5qb2luKCcsICcpO1xuICB9XG59O1xuXG4vKipcbiAqIFdpbmRzaGFmdCBjbGllbnQuIEl0IHByb3ZpZGVzIGEgbWV0aG9kIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgZGFzaGJvYXJkcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgdG8gc2V0IHVwIHRoZSBjbGllbnRcbiAqL1xuV2luZHNoYWZ0Q2xpZW50ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YWxpZGF0ZVByZXNlbmNlT2ZPcHRpb25zKG9wdGlvbnMsIFsndXJsVGVtcGxhdGUnLCAndXNlck5hbWUnLCAnZW5kcG9pbnQnLCAnc3RhdFRhZyddKTtcblxuICB0aGlzLnVybFRlbXBsYXRlID0gb3B0aW9ucy51cmxUZW1wbGF0ZTtcbiAgdGhpcy51c2VyTmFtZSA9IG9wdGlvbnMudXNlck5hbWU7XG4gIHRoaXMuZW5kcG9pbnQgPSBvcHRpb25zLmVuZHBvaW50O1xuICB0aGlzLnN0YXRUYWcgPSBvcHRpb25zLnN0YXRUYWc7XG4gIHRoaXMuZm9yY2VDb3JzID0gb3B0aW9ucy5mb3JjZUNvcnMgfHwgZmFsc2U7XG5cbiAgdGhpcy51cmwgPSB0aGlzLnVybFRlbXBsYXRlLnJlcGxhY2UoJ3t1c2VyfScsIHRoaXMudXNlck5hbWUpO1xufTtcblxuV2luZHNoYWZ0Q2xpZW50LkRFRkFVTFRfQ09NUFJFU1NJT05fTEVWRUwgPSAzO1xuV2luZHNoYWZ0Q2xpZW50Lk1BWF9HRVRfU0laRSA9IDIwMzM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIG1hcCBpbiBXaW5kc2hhZnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBEZWZpbml0aW9uIEFuIG9iamVjdCB0aGF0IHJlc3BvbmRzIHRvIC50b0pTT04gd2l0aCB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgbWFwXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgQSBjYWxsYmFjayB0aGF0IHdpbGwgZ2V0IHRoZSBwdWJsaWMgb3IgcHJpdmF0ZSBtYXBcbiAqIEByZXR1cm4ge2NkYi53aW5kc2hhZnQuRGFzaGJvYXJkSW5zdGFuY2V9IFRoZSBpbnN0YW5jZSBvZiB0aGUgZGFzaGJvYXJkXG4gKi9cbldpbmRzaGFmdENsaWVudC5wcm90b3R5cGUuaW5zdGFudGlhdGVNYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBtYXBEZWZpbml0aW9uID0gb3B0aW9ucy5tYXBEZWZpbml0aW9uO1xuICB2YXIgZmlsdGVycyA9IG9wdGlvbnMuZmlsdGVycztcbiAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IG9wdGlvbnMuc3VjY2VzcztcbiAgdmFyIGVycm9yQ2FsbGJhY2sgPSBvcHRpb25zLmVycm9yO1xuICB2YXIgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KG1hcERlZmluaXRpb24pO1xuXG4gIHZhciBvcHRpb25zID0ge1xuICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmVycm9ycykge1xuICAgICAgICBlcnJvckNhbGxiYWNrKGRhdGEuZXJyb3JzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudXJsVGVtcGxhdGUgPSB0aGlzLnVybFRlbXBsYXRlO1xuICAgICAgICBkYXRhLnVzZXJOYW1lID0gdGhpcy51c2VyTmFtZTtcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKG5ldyBXaW5kc2hhZnREYXNoYm9hcmRJbnN0YW5jZShkYXRhKSk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpLFxuICAgIGVycm9yOiBmdW5jdGlvbih4aHIpIHtcbiAgICAgIHZhciBlcnIgPSB7IGVycm9yczogWydVbmtub3duIGVycm9yJ10gfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVyciA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICBlcnJvckNhbGxiYWNrKGVyci5lcnJvcnNbMF0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiBNb3ZlIHRoaXNcbiAgdmFyIHBhcmFtcyA9IFtcbiAgICBbXCJzdGF0X3RhZ1wiLCB0aGlzLnN0YXRUYWddLmpvaW4oXCI9XCIpXG4gIF07XG5cbiAgdmFyIGZpbHRlcnMgPSBmaWx0ZXJzIHx8IHt9O1xuICBpZiAoT2JqZWN0LmtleXMoZmlsdGVycykubGVuZ3RoKSB7XG4gICAgcGFyYW1zLnB1c2goW1wiZmlsdGVyc1wiLCBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoZmlsdGVycykpXS5qb2luKCc9JykpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3VzZVBPU1QocGF5bG9hZCwgcGFyYW1zKSkge1xuICAgIHRoaXMuX3Bvc3QocGF5bG9hZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9nZXQocGF5bG9hZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxufVxuXG5XaW5kc2hhZnRDbGllbnQucHJvdG90eXBlLl91c2VQT1NUID0gZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zKSB7XG4gIGlmICh1dGlsLmlzQ09SU1N1cHBvcnRlZCgpICYmIHRoaXMuZm9yY2VDb3JzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQubGVuZ3RoID49IHRoaXMuY29uc3RydWN0b3IuTUFYX0dFVF9TSVpFO1xufVxuXG5XaW5kc2hhZnRDbGllbnQucHJvdG90eXBlLl9wb3N0ID0gZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICQuYWpheCh7XG4gICAgY3Jvc3NPcmlnaW46IHRydWUsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIHVybDogdGhpcy5fZ2V0VVJMKHBhcmFtcyksXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgICBzdWNjZXNzOiBvcHRpb25zLnN1Y2Nlc3MsXG4gICAgZXJyb3I6IG9wdGlvbnMuZXJyb3JcbiAgfSk7XG59XG5cbldpbmRzaGFmdENsaWVudC5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgb3B0aW9ucykge1xuICB2YXIgY29tcHJlc3NGdW5jdGlvbiA9IHRoaXMuX2dldENvbXByZXNzb3IocGF5bG9hZCk7XG4gIGNvbXByZXNzRnVuY3Rpb24ocGF5bG9hZCwgdGhpcy5jb25zdHJ1Y3Rvci5ERUZBVUxUX0NPTVBSRVNTSU9OX0xFVkVMLCBmdW5jdGlvbihkYXRhUGFyYW1ldGVyKSB7XG4gICAgcGFyYW1zLnB1c2goZGF0YVBhcmFtZXRlcik7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogdGhpcy5fZ2V0VVJMKHBhcmFtcyksXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgZGF0YVR5cGU6ICdqc29ucCcsXG4gICAgICBqc29ucENhbGxiYWNrOiB0aGlzLl9qc29ucENhbGxiYWNrTmFtZShwYXlsb2FkKSxcbiAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgc3VjY2Vzczogb3B0aW9ucy5zdWNjZXNzLFxuICAgICAgZXJyb3I6IG9wdGlvbnMuZXJyb3JcbiAgICB9KTtcbiAgfS5iaW5kKHRoaXMpKTtcbn1cblxuV2luZHNoYWZ0Q2xpZW50LnByb3RvdHlwZS5fZ2V0Q29tcHJlc3NvciA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQubGVuZ3RoIDwgdGhpcy5jb25zdHJ1Y3Rvci5NQVhfR0VUX1NJWkUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgbGV2ZWwsIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhcImNvbmZpZz1cIiArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihkYXRhLCBsZXZlbCwgY2FsbGJhY2spIHtcbiAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkoeyBjb25maWc6IGRhdGEgfSk7XG4gICAgTFpNQS5jb21wcmVzcyhkYXRhLCBsZXZlbCwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgY2FsbGJhY2soXCJsem1hPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWwuYXJyYXkyaGV4KGVuY29kZWQpKSk7XG4gICAgfSk7XG4gIH07XG59XG5cblxuV2luZHNoYWZ0Q2xpZW50LnByb3RvdHlwZS5fZ2V0VVJMID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBbdGhpcy51cmwsIHRoaXMuZW5kcG9pbnRdLmpvaW4oJy8nKSArICc/JyArIHBhcmFtcy5qb2luKCcmJyk7XG59XG5cbldpbmRzaGFmdENsaWVudC5wcm90b3R5cGUuX2pzb25wQ2FsbGJhY2tOYW1lID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICByZXR1cm4gJ19jZGJjXycgKyB1dGlsLnVuaXF1ZUNhbGxiYWNrTmFtZShwYXlsb2FkKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kc2hhZnRDbGllbnQ7XG4iLCJ2YXIgY29uZmlnID0ge307XG5jb25maWcuTUFQU19BUElfQkFTRV9VUkwgPSAnYXBpL3YxL21hcCdcblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgV2luZHNoYWZ0Q29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciBFTVBUWV9HSUYgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBN1wiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgVElMRV9FWFRFTlNJT05TX0JZX0xBWUVSX1RZUEU6IHtcbiAgICAnbWFwbmlrJzogJy5wbmcnLFxuICAgICd0b3JxdWUnOiAnLmpzb24udG9ycXVlJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gVE9ETzogV2hhdCBwYXJhbXMgYXJlIHJlYWxseSB1c2VkP1xuICAgIHRoaXMucG5nUGFyYW1zID0gWydtYXBfa2V5JywgJ2FwaV9rZXknLCAnY2FjaGVfcG9saWN5JywgJ3VwZGF0ZWRfYXQnXTtcbiAgICB0aGlzLmdyaWRQYXJhbXMgPSBbJ21hcF9rZXknLCAnYXBpX2tleScsICdjYWNoZV9wb2xpY3knLCAndXBkYXRlZF9hdCddO1xuICB9LFxuXG4gIGlzTG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldCgnbGF5ZXJncm91cGlkJyk7XG4gIH0sXG5cbiAgZ2V0QmFzZVVSTDogZnVuY3Rpb24oc3ViaG9zdCkge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLl9nZXRIb3N0KHN1Ymhvc3QpLFxuICAgICAgV2luZHNoYWZ0Q29uZmlnLk1BUFNfQVBJX0JBU0VfVVJMLFxuICAgICAgdGhpcy5fZ2V0TWFwSWQoKSxcbiAgICBdLmpvaW4oJy8nKTtcbiAgfSxcblxuICBfZ2V0TWFwSWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnbGF5ZXJncm91cGlkJyk7XG4gIH0sXG5cbiAgX2dldEhvc3Q6IGZ1bmN0aW9uKHN1Ymhvc3QpIHtcbiAgICB2YXIgdXNlck5hbWUgPSB0aGlzLmdldCgndXNlck5hbWUnKTtcbiAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLl91c2VIVFRQUygpID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgICB2YXIgc3ViaG9zdCA9IHN1Ymhvc3QgPyBzdWJob3N0ICsgJy4nIDogJyc7XG4gICAgdmFyIGhvc3QgPSB0aGlzLmdldCgndXJsVGVtcGxhdGUnKS5yZXBsYWNlKCd7dXNlcn0nLCB1c2VyTmFtZSk7XG4gICAgdmFyIGNkbkhvc3QgPSB0aGlzLmdldCgnY2RuX3VybCcpICYmIHRoaXMuZ2V0KCdjZG5fdXJsJylbcHJvdG9jb2xdO1xuICAgIGlmIChjZG5Ib3N0KSB7XG4gICAgICBob3N0ID0gW3Byb3RvY29sLCAnOi8vJywgc3ViaG9zdCwgY2RuSG9zdCwgJy8nLCB1c2VyTmFtZV0uam9pbignJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3Q7XG4gIH0sXG5cbiAgX3VzZUhUVFBTOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3VybFRlbXBsYXRlJykuaW5kZXhPZignaHR0cHMnKSA9PT0gMDtcbiAgfSxcblxuICBnZXRUaWxlczogZnVuY3Rpb24obGF5ZXJUeXBlLCBwYXJhbXMpIHtcbiAgICB2YXIgZ3JpZHMgPSBbXTtcbiAgICB2YXIgdGlsZXMgPSBbXTtcblxuICAgIHZhciBwbmdQYXJhbXMgPSB0aGlzLl9lbmNvZGVQYXJhbXMocGFyYW1zLCB0aGlzLnBuZ1BhcmFtcyk7XG4gICAgdmFyIGdyaWRQYXJhbXMgPSB0aGlzLl9lbmNvZGVQYXJhbXMocGFyYW1zLCB0aGlzLmdyaWRQYXJhbXMpO1xuICAgIHZhciBzdWJkb21haW5zID0gWycwJywgJzEnLCAnMicsICczJ107XG5cbiAgICBpZih0aGlzLl91c2VIVFRQUygpKSB7XG4gICAgICBzdWJkb21haW5zID0gWycnXTtcbiAgICB9XG5cbiAgICBsYXllclR5cGUgPSBsYXllclR5cGUgfHwgJ21hcG5payc7XG5cbiAgICB2YXIgbGF5ZXJJbmRleGVzID0gdGhpcy5fZ2V0TGF5ZXJJbmRleGVzQnlUeXBlKGxheWVyVHlwZSk7XG4gICAgaWYgKGxheWVySW5kZXhlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBncmlkVGVtcGxhdGUgPSAnL3t6fS97eH0ve3l9JztcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN1YmRvbWFpbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN1YmRvbWFpbiA9IHN1YmRvbWFpbnNbaV07XG4gICAgICAgIHZhciB0aWxlVVJMVGVtcGxhdGUgPSBbXG4gICAgICAgICAgdGhpcy5nZXRCYXNlVVJMKHN1YmRvbWFpbiksXG4gICAgICAgICAgJy8nLFxuICAgICAgICAgIGxheWVySW5kZXhlcy5qb2luKCcsJyksXG4gICAgICAgICAgJy97en0ve3h9L3t5fScsXG4gICAgICAgICAgdGhpcy5USUxFX0VYVEVOU0lPTlNfQllfTEFZRVJfVFlQRVtsYXllclR5cGVdLFxuICAgICAgICAgIChwbmdQYXJhbXMgPyBcIj9cIiArIHBuZ1BhcmFtczogJycpXG4gICAgICAgIF0uam9pbignJyk7XG5cbiAgICAgICAgdGlsZXMucHVzaCh0aWxlVVJMVGVtcGxhdGUpO1xuXG4gICAgICAgIC8vIGZvciBtYXBuaWsgbGF5ZXJzIGFkZCBncmlkIGpzb24gdG9vXG4gICAgICAgIGlmIChsYXllclR5cGUgPT09ICdtYXBuaWsnKSB7XG4gICAgICAgICAgZm9yKHZhciBsYXllciA9IDA7IGxheWVyIDwgdGhpcy5nZXQoJ21ldGFkYXRhJykubGF5ZXJzLmxlbmd0aDsgKytsYXllcikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZ2V0TGF5ZXJJbmRleEJ5VHlwZShsYXllciwgXCJtYXBuaWtcIik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICB2YXIgZ3JpZFVSTFRlbXBsYXRlID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QmFzZVVSTChzdWJkb21haW4pLFxuICAgICAgICAgICAgICAgIFwiL1wiLFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGdyaWRUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBcIi5ncmlkLmpzb25cIixcbiAgICAgICAgICAgICAgICAoZ3JpZFBhcmFtcyA/IFwiP1wiICsgZ3JpZFBhcmFtczogJycpXG4gICAgICAgICAgICAgIF0uam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgZ3JpZHNbbGF5ZXJdID0gZ3JpZHNbbGF5ZXJdIHx8IFtdO1xuICAgICAgICAgICAgICBncmlkc1tsYXllcl0ucHVzaChncmlkVVJMVGVtcGxhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBDbGllbnRzIG9mIHRoaXMgbWV0aG9kIHNob3VsZCBkZWNpZGUgd2hhdCB0byByZW5kZXIgaWYgbm8gbGF5ZXJzIGFyZSBwcmVzZW50XG4gICAgICB0aWxlcyA9IFtFTVBUWV9HSUZdO1xuICAgIH1cblxuICAgIHRoaXMudXJscyA9IHtcbiAgICAgIHRpbGVzOiB0aWxlcyxcbiAgICAgIGdyaWRzOiBncmlkc1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMudXJscztcbiAgfSxcblxuICBnZXRMYXllck1ldGE6IGZ1bmN0aW9uKGxheWVySW5kZXgpIHtcbiAgICB2YXIgbGF5ZXJNZXRhID0ge307XG4gICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0KCdtZXRhZGF0YScpICYmIHRoaXMuZ2V0KCdtZXRhZGF0YScpLmxheWVycztcbiAgICBpZiAobGF5ZXJzICYmIGxheWVyc1tsYXllckluZGV4XSkge1xuICAgICAgICBsYXllck1ldGEgPSBsYXllcnNbbGF5ZXJJbmRleF0ubWV0YSB8fCB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGxheWVyTWV0YTtcbiAgfSxcblxuICBfZW5jb2RlUGFyYW1zOiBmdW5jdGlvbihwYXJhbXMsIGluY2x1ZGVkKSB7XG4gICAgaWYoIXBhcmFtcykgcmV0dXJuICcnO1xuICAgIHZhciB1cmxfcGFyYW1zID0gW107XG4gICAgaW5jbHVkZWQgPSBpbmNsdWRlZCB8fCBfLmtleXMocGFyYW1zKTtcbiAgICBmb3IodmFyIGkgaW4gaW5jbHVkZWQpIHtcbiAgICAgIHZhciBrID0gaW5jbHVkZWRbaV07XG4gICAgICB2YXIgcCA9IHBhcmFtc1trXTtcbiAgICAgIGlmKHApIHtcbiAgICAgICAgaWYgKF8uaXNBcnJheShwKSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBwLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB1cmxfcGFyYW1zLnB1c2goayArIFwiW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQocFtqXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcSA9IGVuY29kZVVSSUNvbXBvbmVudChwKTtcbiAgICAgICAgICBxID0gcS5yZXBsYWNlKC8lN0J4JTdEL2csXCJ7eH1cIikucmVwbGFjZSgvJTdCeSU3RC9nLFwie3l9XCIpLnJlcGxhY2UoLyU3QnolN0QvZyxcInt6fVwiKTtcbiAgICAgICAgICB1cmxfcGFyYW1zLnB1c2goayArIFwiPVwiICsgcSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybF9wYXJhbXMuam9pbignJicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIGxheWVyIG9mIGEgZ2l2ZW4gdHlwZSwgYXMgdGhlIHRpbGVyIGt3b3dzIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdHlwZXMgLSBUeXBlIG9yIHR5cGVzIG9mIGxheWVyc1xuICAgKi9cbiAgX2dldExheWVySW5kZXhlc0J5VHlwZTogZnVuY3Rpb24odHlwZXMpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXQoJ21ldGFkYXRhJykgJiYgdGhpcy5nZXQoJ21ldGFkYXRhJykubGF5ZXJzO1xuXG4gICAgaWYgKCFsYXllcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxheWVySW5kZXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICB2YXIgaXNWYWxpZFR5cGUgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlcyAmJiB0eXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzVmFsaWRUeXBlID0gdHlwZXMuaW5kZXhPZihsYXllci50eXBlKSAhPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ZhbGlkVHlwZSkge1xuICAgICAgICBsYXllckluZGV4ZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVySW5kZXhlcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgYSBsYXllciBvZiBhIGdpdmVuIHR5cGUsIGFzIHRoZSB0aWxlciBrd293cyBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBpbmRleCAtIG51bWJlciBvZiBsYXllciBvZiB0aGUgc3BlY2lmaWVkIHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyVHlwZSAtIHR5cGUgb2YgdGhlIGxheWVyc1xuICAgKi9cbiAgX2dldExheWVySW5kZXhCeVR5cGU6IGZ1bmN0aW9uKGluZGV4LCBsYXllclR5cGUpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXQoJ21ldGFkYXRhJykgJiYgdGhpcy5nZXQoJ21ldGFkYXRhJykubGF5ZXJzO1xuXG4gICAgaWYgKCFsYXllcnMpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICB2YXIgdGlsZXJMYXllckluZGV4ID0ge307XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGF5ZXJzW2ldLnR5cGUgPT0gbGF5ZXJUeXBlKSB7XG4gICAgICAgIHRpbGVyTGF5ZXJJbmRleFtqXSA9IGk7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbGVyTGF5ZXJJbmRleFtpbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZXJMYXllckluZGV4W2luZGV4XTtcbiAgfSxcblxuICBnZXRXaWRnZXRVUkw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgd2lkZ2V0SWQgPSBvcHRpb25zLndpZGdldElkO1xuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2w7XG4gICAgdmFyIHVybDtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXQoJ21ldGFkYXRhJykgJiYgdGhpcy5nZXQoJ21ldGFkYXRhJykubGF5ZXJzO1xuXG4gICAgXy5lYWNoKGxheWVycywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIHZhciB3aWRnZXRzID0gbGF5ZXIud2lkZ2V0cztcbiAgICAgIGZvciAodmFyIGlkIGluIHdpZGdldHMpIHtcbiAgICAgICAgaWYgKHdpZGdldElkID09PSBpZCkge1xuICAgICAgICAgIHVybCA9IHdpZGdldHNbaWRdLnVybFtwcm90b2NvbF07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXJsO1xuICB9XG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgV2luZHNoYWZ0RmlsdGVyc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2ZpbHRlcnMvY29sbGVjdGlvbicpO1xudmFyIFdpbmRzaGFmdEZpbHRlcnNCb3VuZGluZ0JveEZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVycy9ib3VuZGluZ19ib3gnKTtcbnZhciBXaW5kc2hhZnREYXNoYm9hcmRJbnN0YW5jZSA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLWluc3RhbmNlJyk7XG5cbnZhciBXaW5kc2hhZnREYXNoYm9hcmQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIEJPVU5ESU5HX0JPWF9GSUxURVJfV0FJVCA9IDUwMDtcblxuICB0aGlzLmxheWVyR3JvdXAgPSBvcHRpb25zLmxheWVyR3JvdXA7XG4gIHRoaXMubGF5ZXJzID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24ob3B0aW9ucy5sYXllcnMpO1xuICB0aGlzLndpZGdldHMgPSBvcHRpb25zLndpZGdldHM7XG4gIHRoaXMubWFwID0gb3B0aW9ucy5tYXA7XG4gIHRoaXMuY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG4gIHRoaXMuc3RhdFRhZyA9IG9wdGlvbnMuc3RhdFRhZztcbiAgdGhpcy5jb25maWdHZW5lcmF0b3IgPSBvcHRpb25zLmNvbmZpZ0dlbmVyYXRvcjtcblxuICB0aGlzLmluc3RhbmNlID0gbmV3IFdpbmRzaGFmdERhc2hib2FyZEluc3RhbmNlKCk7XG5cbiAgdGhpcy5tYXAuYmluZCgnY2hhbmdlOmNlbnRlciBjaGFuZ2U6em9vbScsIF8uZGVib3VuY2UodGhpcy5fYm91bmRpbmdCb3hDaGFuZ2VkLCBCT1VORElOR19CT1hfRklMVEVSX1dBSVQpLCB0aGlzKTtcblxuICB0aGlzLmxheWVycy5iaW5kKCdjaGFuZ2UnLCB0aGlzLl9sYXllckNoYW5nZWQsIHRoaXMpO1xuICB0aGlzLndpZGdldHMuYmluZCgnY2hhbmdlOmZpbHRlcicsIHRoaXMuX2ZpbHRlckNoYW5nZWQsIHRoaXMpO1xuXG4gIHRoaXMuX2NyZWF0ZUluc3RhbmNlKCk7XG59O1xuXG5XaW5kc2hhZnREYXNoYm9hcmQucHJvdG90eXBlLl9jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBkYXNoYm9hcmRDb25maWcgPSB0aGlzLmNvbmZpZ0dlbmVyYXRvci5nZW5lcmF0ZSh7XG4gICAgbGF5ZXJzOiB0aGlzLmxheWVycy5tb2RlbHMsXG4gICAgd2lkZ2V0czogdGhpcy53aWRnZXRzXG4gIH0pO1xuXG5cbiAgdmFyIGZpbHRlcnNGcm9tVmlzaWJsZUxheWVycyA9IHRoaXMud2lkZ2V0cy5jaGFpbigpXG4gICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IHJldHVybiB3LmxheWVyLmlzVmlzaWJsZSgpIH0pXG4gICAgLm1hcChmdW5jdGlvbih3KSB7IHJldHVybiB3LmZpbHRlciB9KVxuICAgIC5jb21wYWN0KCkgLy8gbm90IGFsbCB3aWRnZXRzIGhhdmUgZmlsdGVyc1xuICAgIC52YWx1ZSgpO1xuXG4gIHZhciBmaWx0ZXJzID0gbmV3IFdpbmRzaGFmdEZpbHRlcnNDb2xsZWN0aW9uKGZpbHRlcnNGcm9tVmlzaWJsZUxheWVycyk7XG5cbiAgdGhpcy5jbGllbnQuaW5zdGFudGlhdGVNYXAoe1xuICAgIG1hcERlZmluaXRpb246IGRhc2hib2FyZENvbmZpZyxcbiAgICBmaWx0ZXJzOiBmaWx0ZXJzLnRvSlNPTigpLFxuICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhc2hib2FyZEluc3RhbmNlKSB7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGFzaGJvYXJkIGluc3RhbmNlIHdpdGggdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5ldyBvbmVcbiAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0KGRhc2hib2FyZEluc3RhbmNlLnRvSlNPTigpKTtcblxuICAgICAgLy8gVE9ETzogU2V0IHRoZSBVUkwgb2YgdGhlIGF0dHJpYnV0ZXMgc2VydmljZSBvbmNlIGl0J3MgYXZhaWxhYmxlXG4gICAgICB0aGlzLmxheWVyR3JvdXAgJiYgdGhpcy5sYXllckdyb3VwLnNldCh7XG4gICAgICAgIGJhc2VVUkw6IGRhc2hib2FyZEluc3RhbmNlLmdldEJhc2VVUkwoKSxcbiAgICAgICAgdXJsczogZGFzaGJvYXJkSW5zdGFuY2UuZ2V0VGlsZXMoJ21hcG5paycpXG4gICAgICB9KTtcblxuICAgICAgLy8gdXBkYXRlIG90aGVyIGtpbmQgb2YgbGF5ZXJzIHRvb1xuICAgICAgdGhpcy5sYXllcnMuZWFjaChmdW5jdGlvbihsYXllciwgbGF5ZXJJbmRleCkge1xuICAgICAgICBpZiAobGF5ZXIuZ2V0KCd0eXBlJykgPT09ICd0b3JxdWUnKSB7XG4gICAgICAgICAgbGF5ZXIuc2V0KCdtZXRhJywgZGFzaGJvYXJkSW5zdGFuY2UuZ2V0TGF5ZXJNZXRhKGxheWVySW5kZXgpKTtcbiAgICAgICAgICBsYXllci5zZXQoJ3VybHMnLCBkYXNoYm9hcmRJbnN0YW5jZS5nZXRUaWxlcygndG9ycXVlJykpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdXBkYXRlV2lkZ2V0VVJMcyh7XG4gICAgICAgIGxheWVySWQ6IG9wdGlvbnMubGF5ZXJJZFxuICAgICAgfSk7XG5cbiAgICB9LmJpbmQodGhpcyksXG4gICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZygnRXJyb3IgY3JlYXRpbmcgZGFzaGJvYXJkIGluc3RhbmNlOiAnICsgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG59O1xuXG5XaW5kc2hhZnREYXNoYm9hcmQucHJvdG90eXBlLl9ib3VuZGluZ0JveENoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaW5zdGFuY2UuaXNMb2FkZWQoKSkge1xuICAgIHRoaXMuX3VwZGF0ZVdpZGdldFVSTHMoKTtcbiAgfVxufTtcblxuV2luZHNoYWZ0RGFzaGJvYXJkLnByb3RvdHlwZS5fdXBkYXRlV2lkZ2V0VVJMcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBib3VuZGluZ0JveEZpbHRlciA9IG5ldyBXaW5kc2hhZnRGaWx0ZXJzQm91bmRpbmdCb3hGaWx0ZXIodGhpcy5tYXAuZ2V0Vmlld0JvdW5kcygpKTtcbiAgdmFyIGJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3hGaWx0ZXIudG9TdHJpbmcoKTtcbiAgdmFyIGxheWVySWQgPSBvcHRpb25zLmxheWVySWQ7XG5cbiAgdGhpcy53aWRnZXRzLmVhY2goZnVuY3Rpb24od2lkZ2V0KSB7XG4gICAgdmFyIHVybCA9IHRoaXMuaW5zdGFuY2UuZ2V0V2lkZ2V0VVJMKHtcbiAgICAgIHdpZGdldElkOiB3aWRnZXQuZ2V0KCdpZCcpLFxuICAgICAgcHJvdG9jb2w6ICdodHRwJ1xuICAgIH0pO1xuXG4gICAgdmFyIGxheWVyTWV0YSA9IHdpZGdldC5sYXllci5nZXQoJ21ldGEnKSB8fCB7fTtcbiAgICB2YXIgZXh0cmFBdHRycyA9IHt9O1xuICAgIGlmIChsYXllck1ldGEuc3RlcHMgJiYgbGF5ZXJNZXRhLmNvbHVtbl90eXBlICYmIF8uaXNOdW1iZXIobGF5ZXJNZXRhLnN0YXJ0KSAmJiBfLmlzTnVtYmVyKGxheWVyTWV0YS5lbmQpKSB7XG4gICAgICBleHRyYUF0dHJzID0ge1xuICAgICAgICBiaW5zOiBsYXllck1ldGEuc3RlcHMsXG4gICAgICAgIGNvbHVtblR5cGU6IGxheWVyTWV0YS5jb2x1bW5fdHlwZSxcbiAgICAgICAgc3RhcnQ6IGxheWVyTWV0YS5zdGFydCAgLyAxMDAwLFxuICAgICAgICBlbmQ6ICBsYXllck1ldGEuZW5kIC8gMTAwMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB3aWRnZXQuc2V0KF8uZXh0ZW5kKHtcbiAgICAgICd1cmwnOiB1cmwsXG4gICAgICAnYm91bmRpbmdCb3gnOiBib3VuZGluZ0JveFxuICAgIH0sIGV4dHJhQXR0cnMpLCB7XG4gICAgICBzaWxlbnQ6IGxheWVySWQgJiYgbGF5ZXJJZCAhPT0gd2lkZ2V0LmxheWVyLmdldCgnaWQnKVxuICAgIH0pO1xuICB9LCB0aGlzKTtcbn07XG5cbldpbmRzaGFmdERhc2hib2FyZC5wcm90b3R5cGUuX2ZpbHRlckNoYW5nZWQgPSBmdW5jdGlvbih3KSB7XG4gIHRoaXMuX2NyZWF0ZUluc3RhbmNlKHtcbiAgICBsYXllcklkOiB3LmxheWVyLmdldCgnaWQnKVxuICB9KTtcbn07XG5cbldpbmRzaGFmdERhc2hib2FyZC5wcm90b3R5cGUuX2xheWVyQ2hhbmdlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gIHZhciBsYXllcklkID0gbGF5ZXIuZ2V0KCdpZCcpO1xuICB0aGlzLl9jcmVhdGVJbnN0YW5jZSh7XG4gICAgbGF5ZXJJZDogbGF5ZXJJZFxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2luZHNoYWZ0RGFzaGJvYXJkO1xuIiwidmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBcIkZpbHRlcnMgbXVzdCBpbXBsZW1lbnQgdGhlIC5pc0VtcHR5IG1ldGhvZFwiO1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgXCJGaWx0ZXJzIG11c3QgaW1wbGVtZW50IHRoZSAudG9KU09OIG1ldGhvZFwiO1xuICB9XG59KTtcbiIsInZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgdGhpcy5zZXRCb3VuZHMoYm91bmRzKTtcbiAgfSxcblxuICBzZXRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgIHRoaXMuc2V0KHtcbiAgICAgIHdlc3Q6IGJvdW5kc1swXVsxXSxcbiAgICAgIHNvdXRoOiBib3VuZHNbMF1bMF0sXG4gICAgICBlYXN0OiBib3VuZHNbMV1bMV0sXG4gICAgICBub3J0aDogYm91bmRzWzFdWzBdXG4gICAgfSk7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLmdldCgnd2VzdCcpLFxuICAgICAgdGhpcy5nZXQoJ3NvdXRoJyksXG4gICAgICB0aGlzLmdldCgnZWFzdCcpLFxuICAgICAgdGhpcy5nZXQoJ25vcnRoJylcbiAgICBdLmpvaW4oJywnKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xudmFyIFdpbmRzaGFmdEZpbHRlckJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxuLyoqXG4gKiAgRmlsdGVyIHVzZWQgYnkgdGhlIGNhdGVnb3J5IHdpZGdldFxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBXaW5kc2hhZnRGaWx0ZXJCYXNlLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICByZWplY3RBbGw6IGZhbHNlXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWplY3RlZENhdGVnb3JpZXMgPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy5iaW5kKCdhZGQgcmVtb3ZlJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldCgncmVqZWN0QWxsJywgZmFsc2UpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLmJpbmQoJ2FkZCByZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0KCdyZWplY3RBbGwnLCBmYWxzZSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnNpemUoKSA9PT0gMCAmJiB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy5zaXplKCkgPT09IDAgJiYgIXRoaXMuZ2V0KCdyZWplY3RBbGwnKTtcbiAgfSxcblxuICBhY2NlcHQ6IGZ1bmN0aW9uKHZhbHVlcywgYXBwbHlGaWx0ZXIpIHtcbiAgICB2YWx1ZXMgPSAhXy5pc0FycmF5KHZhbHVlcykgPyBbdmFsdWVzXSA6IHZhbHVlcztcbiAgICB2YXIgYWNjZXB0ZWRDb3VudCA9IHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLnNpemUoKTtcblxuICAgIF8uZWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZCA9IHsgbmFtZTogdmFsdWUgfTtcbiAgICAgIHZhciByZWplY3RlZE1kbHMgPSB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy53aGVyZShkKTtcbiAgICAgIHZhciBhY2NlcHRlZE1kbHMgPSB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy53aGVyZShkKTtcbiAgICAgIGlmIChyZWplY3RlZE1kbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy5yZW1vdmUocmVqZWN0ZWRNZGxzKTtcbiAgICAgIH1cbiAgICAgIGlmICghYWNjZXB0ZWRNZGxzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy5hZGQoZCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoYXBwbHlGaWx0ZXIgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFwcGx5RmlsdGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIGFjY2VwdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXQoJ3JlamVjdEFsbCcsIGZhbHNlKTtcbiAgICB0aGlzLmNsZWFuRmlsdGVyKCk7XG4gIH0sXG5cbiAgaXNBY2NlcHRlZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy53aGVyZSh7IG5hbWU6IG5hbWUgfSkubGVuZ3RoID4gMDtcbiAgfSxcblxuICBnZXRBY2NlcHRlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzO1xuICB9LFxuXG4gIHJlamVjdDogZnVuY3Rpb24odmFsdWVzLCBhcHBseUZpbHRlcikge1xuICAgIHZhbHVlcyA9ICFfLmlzQXJyYXkodmFsdWVzKSA/IFt2YWx1ZXNdIDogdmFsdWVzO1xuXG4gICAgXy5lYWNoKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBkID0geyBuYW1lOiB2YWx1ZSB9O1xuICAgICAgdmFyIGFjY2VwdGVkTWRscyA9IHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLndoZXJlKGQpO1xuICAgICAgdmFyIHJlamVjdGVkTWRscyA9IHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLndoZXJlKGQpO1xuICAgICAgaWYgKGFjY2VwdGVkTWRscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLnJlbW92ZShhY2NlcHRlZE1kbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFyZWplY3RlZE1kbHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5yZWplY3RlZENhdGVnb3JpZXMuYWRkKGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoYXBwbHlGaWx0ZXIgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFwcGx5RmlsdGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIGlzUmVqZWN0ZWQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVqZWN0Q291bnQgPSB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy5zaXplKCk7XG4gICAgdmFyIGFjY2VwdENvdW50ID0gdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMuc2l6ZSgpO1xuICAgIGlmICh0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy53aGVyZSh7IG5hbWU6IG5hbWUgfSkubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChhY2NlcHRDb3VudCA+IDAgJiYgdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMud2hlcmUoeyBuYW1lOiBuYW1lIH0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldCgncmVqZWN0QWxsJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGdldFJlamVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3RlZENhdGVnb3JpZXM7XG4gIH0sXG5cbiAgcmVqZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgncmVqZWN0QWxsJywgdHJ1ZSk7XG4gICAgdGhpcy5jbGVhbkZpbHRlcigpO1xuICB9LFxuXG4gIGNsZWFuRmlsdGVyOiBmdW5jdGlvbih0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMucmVzZXQoKTtcbiAgICB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy5yZXNldCgpO1xuICAgIGlmICh0cmlnZ2VyQ2hhbmdlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5hcHBseUZpbHRlcigpO1xuICAgIH1cbiAgfSxcblxuICBhcHBseUZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzKTtcbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmaWx0ZXIgPSB7fTtcbiAgICB2YXIgcmVqZWN0Q291bnQgPSB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy5zaXplKCk7XG4gICAgdmFyIGFjY2VwdENvdW50ID0gdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMuc2l6ZSgpO1xuICAgIHZhciBhY2NlcHRlZENhdHMgPSB7wqBhY2NlcHQ6IF8ucGx1Y2sodGhpcy5hY2NlcHRlZENhdGVnb3JpZXMudG9KU09OKCksICduYW1lJykgfTtcbiAgICB2YXIgcmVqZWN0ZWRDYXRzID0geyByZWplY3Q6IF8ucGx1Y2sodGhpcy5yZWplY3RlZENhdGVnb3JpZXMudG9KU09OKCksICduYW1lJykgfTtcblxuICAgIGlmICh0aGlzLmdldCgncmVqZWN0QWxsJykpIHtcbiAgICAgIGZpbHRlciA9IHsgYWNjZXB0OiBbXSB9O1xuICAgIH0gZWxzZSBpZiAoYWNjZXB0Q291bnQgPiAwKSB7XG4gICAgICBmaWx0ZXIgPSBhY2NlcHRlZENhdHM7XG4gICAgfSBlbHNlIGlmIChyZWplY3RDb3VudCA+IDAgJiYgYWNjZXB0Q291bnQgPT09IDApIHtcbiAgICAgIGZpbHRlciA9IHJlamVjdGVkQ2F0cztcbiAgICB9XG5cbiAgICB2YXIganNvbiA9IHt9O1xuICAgIGpzb25bdGhpcy5nZXQoJ3dpZGdldElkJyldID0gZmlsdGVyO1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICB2YXIganNvbiA9IHt9O1xuICAgIHZhciBhY3RpdmVGaWx0ZXJzID0gdGhpcy5nZXRBY3RpdmVGaWx0ZXJzKCk7XG4gICAgaWYgKGFjdGl2ZUZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICBqc29uLmxheWVycyA9IFtdO1xuICAgICAgXy5lYWNoKGFjdGl2ZUZpbHRlcnMsIGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICBpZiAoIWZpbHRlci5pc0VtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBmaWx0ZXIuZ2V0KCdsYXllckluZGV4Jyk7XG4gICAgICAgICAgaWYgKGpzb24ubGF5ZXJzW2luZGV4XSkge1xuICAgICAgICAgICAgXy5leHRlbmQoanNvbi5sYXllcnNbaW5kZXhdLGZpbHRlci50b0pTT04oKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpzb24ubGF5ZXJzW2luZGV4XSA9IGZpbHRlci50b0pTT04oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gZmlsbCB0aGUgaG9sZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvbi5sYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAganNvbi5sYXllcnNbaV0gPSBqc29uLmxheWVyc1tpXSB8fCB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfSxcblxuICBnZXRBY3RpdmVGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICByZXR1cm4gIWZpbHRlci5pc0VtcHR5KCk7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBXaW5kc2hhZnRGaWx0ZXJCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2luZHNoYWZ0RmlsdGVyQmFzZS5leHRlbmQoe1xuXG4gIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLmlzVW5kZWZpbmVkKHRoaXMuZ2V0KCdtaW4nKSkgJiYgXy5pc1VuZGVmaW5lZCh0aGlzLmdldCgnbWF4JykpO1xuICB9LFxuXG4gIHNldFJhbmdlOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHRoaXMuc2V0KHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9KTtcbiAgfSxcblxuICB1bnNldFJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldFJhbmdlKHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHZhciBqc29uID0ge307XG4gICAganNvblt0aGlzLmdldCgnd2lkZ2V0SWQnKV0gPSB7XG4gICAgICBtaW46IHRoaXMuZ2V0KCdtaW4nKSxcbiAgICAgIG1heDogdGhpcy5nZXQoJ21heCcpLFxuICAgICAgY29sdW1uX3R5cGU6IHRoaXMuZ2V0KCdjb2x1bW5UeXBlJylcbiAgICB9O1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBXaW5kc2hhZnRQcml2YXRlRGFzaGJvYXJkQ29uZmlnID0ge307XG5cbldpbmRzaGFmdFByaXZhdGVEYXNoYm9hcmRDb25maWcuZ2VuZXJhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBsYXllcnMgPSBvcHRpb25zLmxheWVycztcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIF8uZWFjaChsYXllcnMsIGZ1bmN0aW9uKGxheWVyLCBpbmRleCl7XG4gICAgY29uZmlnWydsYXllcicgKyBpbmRleF0gPSBsYXllci5pc1Zpc2libGUoKSA/IDEgOiAwO1xuICB9KTtcblxuICAvLyBUT0RPOiBXZSBzaG91bGQgYWRkIHRoZSBwYXJhbXNcbiAgLy8gVE9ETzogV2Ugc2hvdWxkIGFkZCB0aGUgYXV0aF90b2tlblxuICByZXR1cm4gY29uZmlnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kc2hhZnRQcml2YXRlRGFzaGJvYXJkQ29uZmlnO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBXaW5kc2hhZnRQdWJsaWNEYXNoYm9hcmRDb25maWcgPSB7fTtcblxuV2luZHNoYWZ0UHVibGljRGFzaGJvYXJkQ29uZmlnLmdlbmVyYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgbGF5ZXJzID0gb3B0aW9ucy5sYXllcnM7XG4gIHZhciB3aWRnZXRzID0gb3B0aW9ucy53aWRnZXRzO1xuICB2YXIgY29uZmlnID0geyBsYXllcnM6IFtdIH07XG4gIF8uZWFjaChsYXllcnMsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgaWYgKGxheWVyLmlzVmlzaWJsZSgpKSB7XG4gICAgICB2YXIgbGF5ZXJDb25maWcgPSB7XG4gICAgICAgIHR5cGU6IGxheWVyLmdldCgndHlwZScpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBzcWw6IGxheWVyLmdldCgnc3FsJyksXG4gICAgICAgICAgY2FydG9jc3M6IGxheWVyLmdldCgnY2FydG9jc3MnKSxcbiAgICAgICAgICBjYXJ0b2Nzc192ZXJzaW9uOiBsYXllci5nZXQoJ2NhcnRvY3NzX3ZlcnNpb24nKSxcbiAgICAgICAgICBpbnRlcmFjdGl2aXR5OiBsYXllci5nZXRJbnRlcmFjdGl2ZUNvbHVtbk5hbWVzKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChsYXllci5nZXRJbmZvd2luZG93RmllbGROYW1lcygpLmxlbmd0aCkge1xuICAgICAgICBsYXllckNvbmZpZy5vcHRpb25zLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgaWQ6IFwiY2FydG9kYl9pZFwiLFxuICAgICAgICAgIGNvbHVtbnM6IGxheWVyLmdldEluZm93aW5kb3dGaWVsZE5hbWVzKClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbGF5ZXJDb25maWcub3B0aW9ucy53aWRnZXRzID0ge307XG4gICAgICB2YXIgbGF5ZXJJZCA9IGxheWVyLmdldCgnaWQnKTtcbiAgICAgIHdpZGdldHMuZWFjaChmdW5jdGlvbih3aWRnZXQpIHtcbiAgICAgICAgaWYgKGxheWVySWQgPT09IHdpZGdldC5sYXllci5nZXQoJ2lkJykpIHtcbiAgICAgICAgICBsYXllckNvbmZpZy5vcHRpb25zLndpZGdldHNbd2lkZ2V0LmdldCgnaWQnKV0gPSB3aWRnZXQudG9KU09OKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uZmlnLmxheWVycy5wdXNoKGxheWVyQ29uZmlnKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRzaGFmdFB1YmxpY0Rhc2hib2FyZENvbmZpZztcbiJdfQ==
